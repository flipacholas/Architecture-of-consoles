---
date: 2022-06-08
name: Xbox 360
short_title: Xbox 360 架构
long_title: Xbox 360的架构
subtitle: 为普通人而生的超算
generation: 7
release_date: 2005-11-22
aliases:
  - /writings/consoles/xbox-360-private
seo_image_pos: "Bottom"
top_tabs:
  Motherboard:
    caption: "图中为“Xenon”版本（第一个修订版），取自我在 2005 年购买的 xbox 360。 Xenon 主板也因为设计缺陷而出名（由于过热而停止工作！）。 缺失的 GDDR3 芯片在背面。"
    bib_source: copetti
  Models:
    - 
      active: true
      caption: "初版 Xbox 360 顶部插有外置硬盘。<br> 2005 年 11 月 22 日于美国，2005 年 12 月 10 日于日本发售"
      title: 原版
      file: original
      img_class: reduced-width
      latex_height: 85
    - 
      caption: "“新”Xbox 360 （又称“薄版”或“S版”）<br>2010年6月18日于美国，2010年6月24日于日本，2010年7月16日于欧洲发布"
      title: 薄版
      file: the-s
      img_class: reduced-width
      latex_height: 90
    - 
      caption: "<br>2013年6月10日于美国，2013年6月20日于欧洲和日本发售"
      title: E型机
      file: the-e
      img_class: reduced-width
      latex_height: 90
---

## 快速入门

Xbox 360比其主要竞争对手提前一年发布，而且它已经在宣称产生了对尚未面世的PlayStation 3技术上的优势。 尽管Xbox 360可能是第七代游戏机的旗舰产品，但一旦任天堂和索尼开始占据零售空间，它将需要激烈竞争。

这个新的[游戏机架构系列](consoles)将为您提供另一种视角，了解在21世纪初，技术是如何被设想的，重点是新兴的“多核”处理器和组件之间非同寻常的共生关系，所有这些使工程师能够以成本效益的解决方案解决无法解决的挑战。

### 预读须知 (强烈推荐)

这篇文章的第一部分（标题为“CPU”）反复提到了IBM和索尼的合资企业，Cell。 如果你不太了解这个组件，我强烈建议你先阅读我之前关于[PS3](playstation-3)的文章。 后文写得就像是Xbox 360从未存在过一样，这是有意为之，以避免让读者对循环引用感到困惑。 因此，新文章通过加入Xbox 360来完善时间线。

对于那些已经熟悉PS3架构的读者，我已经将这项研究结构安排得类似于PS3的文章，所以如果您选择这样做，你将能够客观地比较两者。

### 个人视频介绍

因为这篇文章比我之前的文章长得多，我还制作了一个小视频，在视频中我尝试介绍这篇文章，并让您对文章内容有个大致了解。 [您可以在这里观看](https://youtu.be/uZXHQT3NRss)。 这是我第一次做“个人介绍”，所以请您原谅我偶尔的口头禅:)。

## {.supporting-imagery}

## 中央处理器 (CPU)

再一次，我们遇到了一种新型CPU，它与市面上见过的任何产品都不同。 毕竟，这是另一款第七世代游戏机，反映了那个时代对创新的痴迷需求。

### 简介

在我们讨论架构之前，我会先从一些历史背景开始，以便让您了解情况。 接下来的段落将聚焦于Xbox 360的CPU的商业方面，其事件序列至少可以说是有趣的。

我会尽量简短，这样我们就可以专注于[这个系列](consoles)的主要话题。但如果您最后感兴趣想了解更多，你可能会喜欢一本名为《新游戏机的竞赛》（The Race For A New Game Machine）的书，这本书是由IBM的前高管撰写的。

#### 从编译者到统治者 {.tabs.active}

![在2005年E3展会上，微软的展示开场，Robbie Bach、J Allard和Peter Moore公布了Xbox 360[@cpu-microsoft_e3]。 ](e3/start.jpg) {.tab-float}

在享受[初代Xbox](xbox)令人惊喜的成功之后，微软开始着手开发继任产品。 公司首先寻找能够对抗索尼即将推出的技术的供应商。然而，与之前的发展不同，微软现在在即将进行的谈判中占据了上风。

为了了解背景，回到初代Xbox项目还处于早期阶段时，英特尔和英伟达都不愿意与微软分享他们的知识产权。 这个决定限制了微软根据Xbox的特定需求塑造英伟达或英特尔的芯片的能力。

例如，保护游戏机免受未授权代码执行的安全子系统是在这两块关键芯片之外实现的。 这使得它容易受到[嗅探攻击](xbox#tab-5-2-bootstrap-search)，最终导致自制软件和盗版游戏在机子上的执行。 此外，微软也无法控制制造阶段，因此Xbox游戏机的生产取决于英特尔和英伟达的供应。

现在，微软在游戏机市场上获得了更多的杠杆，他们不再愿意放弃这些权利。

#### 共享同样的问题 {.tab}

![初代Xbox的CPU（2001）。 英特尔设计制造。](_diagrams/cpu/coppermine.webp) {.tab-float}

![同构CPU的概念。 这正是微软为他们的下一代CPU所设想的。 ](images/consoles/ps3/_diagrams/cell/paradigm/homogeneous.webp) {.tab-float}

与计算机行业的任何其他公司一样，21世纪初的[创新危机](playstation-3#tab-1-2-new-design-philosophies)无差别地影响了微软和索尼。 然而，不同之处在于，这两家公司为他们的 CPU 设计下了不同的赌注。 初代Xbox依赖于流行的现成产品（英特尔的[奔腾III](xbox#cpu)）并进行了一些定制，这是一个单核CPU，通过向量化指令和复杂的缓存设计进行了扩展。 另一方面，索尼的向量化冒险（[情感引擎（EE）](playstation-2#cpu)）由一个低端CPU组成，周围环绕着专有的但功能强大的助手。

对于他们的新一代产品，微软决定采用保守的设计，并结合一些实验性想法。 根据他们的清单，新的CPU将是**多核**的（即，一个芯片内包含许多对称且同构的CPU核心），供应商必须与微软**共享他们的知识产权（IP）**[@cpu-takahashi]。

最后一个条件与第一个条件一样关键，因为它将使Xbox团队能够**在芯片内集成一个安全系统**（与初代Xbox不同，这次它将得到适当的庇护）。 此外，知识产权将授予微软选择**第三方制造商**来处理需求并谈判更好的成本，从而制造出具有竞争力的定价的新游戏机。

因此，微软开始与英特尔会面，尽管谈话并没有持续很长时间，因为英特尔不愿意透露其秘方。 所以，微软继续寻找。

#### 怀恨在心的老朋友 {.tab}

![2019年6月我在计算机历史博物馆（加利福尼亚州圣何塞）参观时发现的一台 IBM 个人电脑。 出于某种原因，他们不允许你使用它……](photos/ibm_pc.jpeg) {.tab-float}

碰巧，微软的潜在候选人之一竟然是IBM。 也许我看过的戏剧性纪录片太多了，但我总是把这两家公司想象成那种只在有其他人在场时才会相互微笑的消极攻击性“朋友”。

您看，过去IBM和微软形成了许多合作关系，但最终双方都心存怨恨。 尽管如此，他们的协议最终打破了全球市场的现状，为新的消费产品和开发铺平了道路。 举几个例子：

- 1981年IBM**个人电脑**的问世导致了“个人电脑”市场的诞生，随后微软的“MS-DOS”被选为默认操作系统。 这让微软在未来几年在PC业务中获得了垄断地位。
- 在90年代，随着家庭网络、价格合理的服务器和工作站的兴起，IBM和微软的新冒险导致了**OS/2**的诞生，这是一个针对高端IBM计算机的新操作系统。 然而，在微软突然发布Windows NT后，IBM被独自留在了一个已经倒向Windows的竞技场上。

到了世纪之交，IBM将注意力转向内部产品，包括与苹果和摩托罗拉的合作，这导致了一系列具有独特架构的CPU的诞生，其名为**PowerPC**。

当微软向IBM提出一个新的_无缝合作_时，IBM已经在与东芝和索尼合作，创建一个用于科学应用的更高级的 PowerPC 处理器。 尽管如此，IBM对新的商业机会持开放态度。

#### 新的 CPU 合作伙伴  {.tabs-close}

在事件的发展中，IBM同意分享其知识产权，并设计一个新的多核处理器，因此**Xbox 360的CPU供应商变成了 IBM**。 然而，[您可能还记得](playstation-3#tab-1-1-the-state-of-progress)，这正是与索尼和东芝签订协议生产PlayStation 3 CPU（“Cell”）的同一家IBM。 显然，IBM以为微软对Cell项目并不知情[@cpu-alexander]，并且他们与索尼的当前合同并未禁止他们向第三方销售。

> 这三家公司[IBM、东芝和索尼]……在法律上都有权将任何这些技术、任何这些处理器核心应用到其他领域。 (...) 非常常见的是，开发出一个有趣、前沿的新技术，然后利用这项技术在多个平台上。 (...) 我猜大家都没有预料到的是——在我们甚至还没有完成Cell芯片和PS3产品之前——**我们就会特别向竞争对手展示这一点**。 [@cpu-alexander]
> 
> ——<cite>David Shippy，[Power处理单元](playstation-3#the-powerpc-processing-unit)（PPU）的首席架构师</cite>

讽刺的是，截至2022年，IBM的PowerPC芯片已经从台式机和视频游戏机中消失了，这可能树立了一个不好的先例，极大地影响了IBM在未来业务中的信任？ 我稍后会讨论这种影响。

总结一下，IBM在2001年与索尼和东芝签订协议开发Cell。 两年后的2003年，IBM同意向微软提供一个新的低功耗多核CPU。 微软的CPU将被称为**Xenon**，并将继承Cell的一部分技术，同时加上微软的额外投入（专注于多核同构计算和定制安全系统）。 此外，虽然IBM将Cell与其“BladeCenter”系列服务器相搭配，但Xenon只能安装在Xbox 360的主板上。

### Cell的半个兄弟
<!-- TODO: Explain Power mac g5 prototype?? -->

现在我们已经把微软和IBM放在了地图上，让我们来谈谈新的CPU。 这就是Xenon在Xbox 360项目结束时如何成型的 @fig-xenon

![Xenon的简化示意图。](_diagrams/cpu/xenon.webp) {#fig-xenon.toleft}

![为了比较，这里是Cell的示意图。 Cell也包括32 KB的ROM，这里没有显示。 ](images/consoles/ps3/_diagrams/cell/cell.webp) {.toright}

别担心，这篇文章将解释所有这些组件，从左上角显示的PPE块开始。

#### 对CPU历史的新看法

Cell项目，因其对向量化计算的痴迷，引入了非常有趣的方法来彻底解决阻碍技术进步的持续限制。 然而，这些限制非常复杂。 因此，说Cell的方法是最好的解决方案，甚至是不公平的。 换句话说，通过研究Xenon的架构（它与Cell一起竞争）我们可以获得不同的视角，了解CPU架构在那个时代（21世纪初）是如何发展的，并随后影响了接下来十年的CPU。

![Xenon芯片，周围环绕着一支去耦电容大军](photos/xenon.jpg) {.open-float}

这样做，你会发现Xenon采取了一种比Cell更保守的方法。 如果我们再看看之前Xenon的图表，你可以注意到后者配备了著名的[**PowerPC处理元件**](playstation-3#inside-cell-the-leader)（PPEs），这也是Cell最重要的部分。 然而，Xenon现在配备了**三个**。 此外，[**协同处理元件**](playstation-3#inside-cell-the-assistants)（SPUs）已经不存在了。

毕竟，微软不希望他们CPU中的处理器性质差异太大。 他们指示IBM组成三个强大的核心，并用游戏开发者期望找到的成分来增强它们。 通过这种方法，IBM和微软还能够添加非标准特性，而不会破坏开发者的传统_工作方式_。

{.close-float}

说实话，这也导致了预算的削减，以保持这个设计（以及系统的其余部分）在具有竞争力的价格范围内。 为了说明这一点，IBM在构建Xenon时，多核CPU还没有出现在PC的货架上，而当它们在2005年首次亮相时（恰好也是Xbox 360进入商店的那一年），AMD他们的最便宜的速龙X2定价为537美元（相当于2021年的约452英镑），而英特尔为他们的低端奔腾D收费241美元（相当于2021年的约203英镑）——别忘了盒子只包括CPU。

### 我们如何进行研究

现在，我们将来看看构成索尼对应产品的主要组件。 为了避免重复[现有的信息](playstation-3#how-this-study-is-organised)，我将专注于Xenon的新颖之处。

虽然这么说，这款新的CPU运行频率为**3.2 GHz**，并且集成了如此多的电路，以至于在这项研究中，我们不得不将其分为不同的组别：

- 首先是三个执行程序指令的**领导者**。 首先，它们每个都类似于Cell处理器中的**PowerPC 处理元件**（PPE），但很快你就会发现它们实际上是其超集。 此外，由于我们现在有三个这样的核心，整个芯片可能看起来像是一个_三头犬_怪物，每个核心都可能声明控制整个系统。 然而，在计算机中这是不可行的，所以第一个核心被指定为**主核心**，而其他核心将扮演**辅助角色**。
- 接下来是一个**单一的接口**，它将核心与系统的其余部分连接起来。 这个总线被称为**XBAR**（读作“Crossbar”）。
  - 就像在Cell处理器中一样，还有其他专有的接口用于调试或维护（例如温度），但这些将在我们到达“反盗版”部分时再提及。
- 最后是**安全模块**，由微软监督实施反盗版系统。 这是一个非常复杂的部分，为了避免让你信息过载，我将在“反盗版”部分进行解释。

#### Xenon的不同方法

为了解释前面提到的各个组别，我已经按照这个顺序组织了对Xenon的研究：

1. 首先是连接所有核心的总线，即**XBAR**和其特殊的**L2缓存块**。
2. 然后是**PowerPC处理元件**（PPE）的新改进。
3. 接下来是**通用内存**的异常丰富。
4. 微软提出（并在某种程度上强制执行）的新**编程模型**。 深入 Xenon：信使 原始芯片（Cell）需要容纳十二个独立节点来积极移动数据，这迫使 IBM 工程师设计了一个复杂的系统，以解决出现的瓶颈问题，这个系统就是元素互连总线（EIB）。而在 Xbox 360 中，Xenon 只需要容纳三个单元（三个 PPE），所以 EIB 在这里没有用途。因此，产生了一个更简单的解决方案，称为 XBAR，专门关注这三个 PPE，并留有空间以增加额外功能。

### 深入Xenon：信使

原始芯片（Cell）需要容纳**十二个**独立节点来积极移动数据，这迫使IBM工程师设计了一个复杂的系统，以解决出现的瓶颈问题，这个系统就是[元件互连总线](playstation-3#inside-cell-the-heart)（EIB）。 而在Xbox 360中，Xenon只需要容纳三个单元（三个PPE），所以EIB在这里没有用途。 因此，产生了一个更简单的解决方案，称为**XBAR**，专门关注这三个PPE，并留有空间以增加额外功能。

XBAR依赖于一种**网状拓扑**结构，它不是以令牌方式引导流量。 相反，每个节点都提供了一个专用通道来移动其数据[@cpu-brown]。 这看起来可能比EIB的令牌拓扑结构更优化，但这是因为XBAR只需要服务于少数节点。 此外，XBAR以全速（**3.2 GHz**）运行。

![这是XBAR/Crossbar与L2组件结合的简化示意图。 ](_diagrams/cpu/crossbar.webp) {.toleft}

![为了比较，这是Cell处理器中EIB的架构（在PS3中找到）。 ](images/consoles/ps3/_diagrams/cell/eib.webp) {.toright}

公平地说，到目前为止，我只谈到了连接PPE的特定接口。 好吧，XBAR只是IBM为Xenon设计的庞大块状结构中的一部分。 事实证明，剩余的空间让他们有机会整合另一个非常重要的块，以加速PPE与系统其他部分之间的交易：**L2缓存**。

#### 共享缓存

PPE通过XBAR可以访问**1 MB的L2**。 L2块也是以网状方式连接的，每个PPE都有一个独立的**256位总线**，但现在时钟频率为**1.6 GHz**（PPE速度的一半）

巧合的是，Cell处理器也为它的单个PPE配备了[512 KB的L2](playstation-3#composition-of-the-ppe)。 我在之前的一篇文章中只用了一句话来描述它。 但现在，我们面临的情况是缓存空间更大，而且它们被三个核心共享，因此我觉得有必要深入探讨L2缓存块的特性，这样我们才能理解它将如何影响PPE的性能。

首先，每当缓存从内存中获取数据时（在发生“缓存未命中”的情况下），它都是通过拉取一个被称为“缓存行”的大块数据来完成的，在Cell和Xenon的情况下，这个缓存行是**128字节宽**。 然后，L2会在一个内部列表上记录这个缓存行，以便将来能够找到它。 此外，在Xenon/Cell中，L2是**8路关联**的，这意味着缓存集可以存储多达八个不同的缓存行。 如果你不知道这是什么意思，也不用担心，CPU缓存背后的理论可能很难理解，特别是如果你只想了解游戏机的话。 用通俗的话来说，关联度越高，缓存未命中的概率就越小，但遍历内部列表的速度也会越慢。

![Xenon中的缓存布局 ](_diagrams/cpu/caches.webp)

选择8路关联缓存对Xenon来说并非一时冲动，因为提供八个关联可以缓解六个同时运行的线程（每个PPE都是双线程的）试图同时访问L2缓存块的压力。 这也在频繁的缓存未命中和查找时间之间取得了平衡。 所有这些，同时还要控制成本。 作为比较，昂贵的英特尔“Smithfield”（2005年的Pentium D）为每个核心提供了2 MB的L2缓存！ [@cpu-shimpi_intel]

微软为了[降低成本而削减缓存](xbox#tab-1-5-the-core)这并不是第一次，所以开发者需要优化其使用。 为了帮助做到这一点，XBAR集成了额外的逻辑，如“缓存锁定”，这将在“图形”部分进一步解释。

### Xenon的内部：领导者（们）

关于XBAR和L2的描述就到这里，现在让我们来谈谈实际的CPU。 提醒一下，因为我已经在PS3的文章中剖析了标准的PPE（在Cell中找到），所以这里我将专注于新的特点。

首先，Xenon的PPE不再包含[PowerPC处理器存储子系统（PPSS）](playstation-3#composition-of-the-ppe)，可能是因为接口部分由XBAR处理，而且L2现在是在三个单元之间共享的。

![Xenon的PowerPC处理元件（PPE）的简化示意图。 ](_diagrams/cpu/ppe.webp) {.toleft}

![为了比较，这是Cell的PPE。 ](images/consoles/ps3/_diagrams/cell/ppe.webp) {.toright}

说实话，我不确定为什么技术手册总是把Xenon的PPE称为“PPE”，因为它们更像是一个[PPU](playstation-3#the-powerpc-processing-unit)。

不管怎样，让我们来看看微软喜欢在与PlayStation 3比较时吹嘘的显著变化。

#### 新的向量单元

由于[协同处理器元件](playstation-3#inside-cell-the-assistants)（SPEs）是索尼的秘密武器，而微软只对同构系统感兴趣，IBM提出了一种加速Xenon中向量（vector）和矩阵（matrix）操作的新方法。 简而言之，IBM增强了[VMX单元](playstation-3#tab-3-3-arithmetic)（在PPE中能找到的SIMD单元），它演变成了**VMX128**，现在拥有更多的寄存器和操作码。

PlayStation 3中最初实现的VMX规范提供了32个128位寄存器和操作指令，可以操作多达三个32位标量。 这对于依赖SIMD操作的一般应用来说是可接受的，尽管只有加入SPEs，真正的性能才能被释放。 相比之下，微软希望程序员能够轻松地移植那些需要SIMD的应用程序，新的VMX128单元反映了这一点。

VMX128提供了**128个128位**寄存器，以及一个修改后的指令集来操作更广泛的寄存器集。 为了实现这一点，IBM改变了操作码格式，分配了7位（而不是5位）来引用其扩展的寄存器文件。[@cpu-gschwind] 这是通过在32位操作码的最后五位应用一些技巧来实现的[@cpu-biallas]。 最后五位大多数情况下，但并非完全，未被VMX使用。 因此，VMX128与VMX指令的子集（与整数乘法和加法相关）不兼容。

此外，VMX128增加了新的指令，可以计算由多达三个32位浮点数组成的两个向量的**点积**；以及其他处理**Direct3D数据压缩格式**的指令[@cpu-brown]。值得注意的是，DirectX是这个游戏机编程的唯一API。 最后，由于Xenon的对称设计及其多线程模型（双发射），VMX128的寄存器文件被复制，因此每个核心有**256个128位寄存器**！

在这个部分的最后，还有一个问题没有回答：对于向量操作来说，哪个更快，1个VMX加上6个SPEs（如PS3）还是3个VMX128单元（如Xbox 360）？ 嗯，他们的设计太不同了，很难量化。 有人可能会说“SPE可以每个周期执行多达两个指令，而Xenon需要12个周期来把两个向量加起来（由于PPE的长流水线）”，但这是相对的，因为SPE的内存范围仅限于其本地内存（需要DMA调用与外部交互），而Xenon的PPEs可以访问任何内存位置。 所以，总的来说，这是两个截然不同的模型，程序员只能尽力发挥它们的最佳性能。

#### 一个新的但短命的指令

随着更大缓存系统的出现，微软和IBM扩展了PowerPC指令集，以适应一些从程序端操作这些块的指令，以防程序员希望进行手动干预（如提前缓存数据或节省L2空间）。 无论如何，标准的PowerPC规范已经提供了`dcbt`（Data Cache Block Touch，“数据缓存块触摸”）指令，用于从内存中获取数据到L1（每个核心单独）。 然而，微软更进一步，增加了`xdcbt`（Extended Data Cache Block Touch，“扩展数据缓存块触摸”）来填充L1，甚至不经过L2（所有核心共享）。 这很有意义，因为共享的L2是Xenon的新增功能。 然而，绕过L2是一种风险操作，因为两个核心可能会看到不同的数据（缓存不一致），所以需要程序员正确处理以保持缓存一致性和避免竞态条件。

不幸的是，`xdcbt`在微软开始收到游戏工作室的错误报告之前一直运行良好[@cpu-dawson]。 最初，微软依赖这个指令用于他们API中提供的常见例程（如`memcpy()`），但他们没有考虑到随后的缓存一致性缺乏。 因此，他们从API中删除了`xdcbt`的使用。 然而，工作室发现了一个更大的问题：`xdcbt`之后的分支指令总是执行后者。 事实证明，分支预测器将尝试执行`xdcbt`（就像任何可能在后来被[撤销](gamecube#the-powerpc-gekko)的指令一样，如果预测结果被证明是不正确的），除非缓存块被破坏，否则无法撤销（这将成为一个[冒险](playstation#delay-galore)）。 因此，程序不会同步缓存，因为它假设`xdcbt`没有被触发，导致PPEs处于混乱状态。

最终，由于`xdcbt`的非确定性（因此不可预测）行为，微软从编译器中清除了它，剩下的只是一个轶事。

#### 重访旧范式

在2005年的重要著作中，如乔恩·斯托克斯（Jon Stokes）的《深入Xbox 360》 [@cpu-stokes]或安南德·拉尔·西姆皮（Anand Lal Shimpi）的《理解Cell微处理器》[@cpu-shimpi]，有一个反复出现的话题，那就是早期PowerPC芯片如Gekko中首次出现，但在Cell和Xenon中却**完全缺席的乱序执行（out-of-order execution）**，。 如果你还记得我两年前写的关于[GameCube的文章](gamecube#the-powerpc-gekko)，Gekko是一个乱序CPU，这意味着它能够分析指令流，并在指令进来后重新排序，以更好地分配Gekko内部单元的负载。

那时，采用乱序执行技术的CPU核心已然成为当时的顺位。 IBM的PowerPC 604（1994年）将其引入高端Macintosh电脑，Intel的P6（1995年）将其引入x86系列，MIPS则通过R10000 CPU（1996年）实现，这是[任天堂64](nintendo-64#cpu)上R4000的继任者。 之后，突然之间，Cell和Xenon以顺序执行的方式出现……_想解释一下这是为什么吗_？

为了理解这一转变，让我们更仔细地看看乱序执行（OoO）模型。 OoO并不是工程师安装后就继续下一步的乐高积木。 流水线式的CPU容易受到一系列新的[冒险](playstation#delay-galore)的影响，这意味着最微小的添加可能导致彻底的重新设计。 例如，OoO需要改变寄存器文件以适应**寄存器重命名**[@cpu-etsion]，这是一种聪明的技术，CPU包含的寄存器比指令集引用的更多，使CPU能够存储程序状态的多个副本，并防止在改变指令原始顺序后出现的依赖问题。 总的来说，虽然这些解决方案很有趣，但它们增加了CPU芯片的复杂性，这可能对未来可扩展性构成威胁。

PowerPC处理器元件（PPE）源自POWER4，它本身就是一个OoO核心。 然而，POWER4本身是一个独立的（且耗电的）芯片，而PPE要么被7个SPE包围（如PlayStation 3/Cell），要么被两个更多的PPE包围（如Xbox 360/Xenon）。 这些变化占据了空间，而CPU芯片的尺寸在价格和热耗散方面至关重要。 所以，最终，我想象IBM没有看到在PS3或Xbox 360这样特定应用的机器上应用OoO的足够优势。

##### 另一种解决方案

这样想，OoO最初是为了什么而发明的呢？ 是为了防止CPU空闲（因为空闲等于浪费资源）。 那么，应用程序（如3D游戏）容易遇到这个问题吗？ 也许会，但同样正确的是，OoO并不是解决这个问题的唯一可能的解决方案！ 隆重介绍**线程级并行**（Thread level parallelism，TLP）。

如果我们不是去确定哪些指令应该首先执行，而是将资源复制成两组（或更多）称为“线程”的组，并让程序在认为更适合的不同资源组之间切换（多线程），会怎样呢？ 这就是IBM工程师选择的方法，也是PPE[双发射](playstation-3#tab-3-1-instructions)的原因。 这种新技术称为**线程级并行（TLP）**，它与**指令级并行（ILP）**的不同之处在于，它让程序而不是CPU来提出自己的解决方案。 在Xenon和Cell上，现在由编译器和程序的多线程实现来产生一个有效的指令序列。

有趣的是，这两种方法没有好坏之分，市场上仍然可以找到乱序处理器（Intel/AMD仍然支持OoO，以及大量的其他技术，而ARM在2007年通过[Cortex-A9](playstation-vita#the-core)采用了OoO）。 此外，这些CPU具有多线程核心，甚至在同一芯片中集成了多个核心，因此你得到了两种技术的混合（TLP和ILP）。

##### 关系侵蚀

然而，尽管从技术角度来看，省略乱序执行可能是合理的，但这最终会削弱人们对IBM长期能力的信任。 苹果公司意识到未来的PowerPC芯片将无法与英特尔抗衡[@cpu-race_takahashi]，于是在2005年率先放弃与IBM的合作，转而采用英特尔的处理器（正好赶上了[Yonah处理器](xbox#p6-and-the-end-of-pentium-numbers)）。 然而，这并没有让IBM感到担忧，他们更愿意专注于服务器和游戏领域。

但PowerPC CPU的长期结果却是灭绝。 上述技术限制（毕竟IBM[曾经是乱序设计的先驱](gamecube#tab-1-1-the-commercial-milestone)），加上可疑的商业伦理（IBM同时秘密为两个竞争对手设计），导致其失去了整个游戏机市场：索尼和微软为他们的下一代游戏机选择了AMD CPU。 十年后，任天堂的[Wii U](wiiu#the-last-venture-of-powerpc)将成为最后一个捆绑PowerPC芯片的游戏机。

### Xenon内部：主内存

与装备有[256MB XDR DRAM的竞争对手](playstation-3#outside-cell-main-memory)不同，Xenon旁边没有安装任何外部内存。 没错，与日本竞争对手相比，这是一个100%的减少。

好吧…让我重新表述一下。 在主板上，多个芯片总共提供了**512MB的GDDR3 SDRAM**，但它们位于GPU旁边，**而不是CPU旁边**。 所以…你可能已经猜到了。 与[初代Xbox](xbox#memory-layout)一样，微软选择了统一内存架构（UMA）布局，其中所有组件共享相同的RAM芯片。 这提供了更大的灵活性，可以根据需要为CPU或GPU保留更多内存。 然而，对于各种组件来说，单一访问点意味着距离较远的组件（如CPU）将遭受比假设CPU有专用内存时更高的延迟。 这一点被IBM和微软的工程师注意到，并随后通过前述的L2缓存以及额外的电路（这将在“图形”部分解释）来解决这个问题。

![Xenon旁边的“Xenos”（GPU）守护着256MB的GDDR3，剩下的一半在背面。](photos/mem_path.jpg)

内存芯片的类型（GDDR3）与[Wii](wii#what-about-memory)和[PS3](playstation-3#organising-the-content)中发现的相同。 相反，Xbox 360因为包含最大的内存量而获得好评。 实际上，有报道称微软**最初计划安装256MB内存**，但后来因为担心索尼的即将推出的竞争对手而将内存量翻倍[@cpu-takahashi]。 不过，与索尼不同，微软在零售价格上更加谨慎，因此不得不削减其他功能。 这就是为什么**硬盘驱动器变成了选装件**。 此外，微软期望其内存供应商三星提供工作频率为1.4GHz的芯片，但在发货时却只能以**700MHz**的频率交付。

#### 内存控制器

说完这些，Xenon如何访问这个内存呢？ 好吧，CPU通过一个称为**前端总线**（Front-side Bus，FSB）的接口与GPU通信，这将串行和并行通信模型结合起来，以尽可能降低成本和减少延迟[@cpu-brown]。

在外部，有两个单向通道名为“PHY”，每个由**16条总线**组成，以异常快的速度运行在**5.4 GHz**[@cpu-siljenberg]。 在那里，信息以串行形式传输。 然而，在内部，CPU和GPU只理解整个字。 因此，两个端点都负责在通过PHY发送之前将数据序列化，并在接收后将其反序列化（移位寄存）。 CPU的内部接口为**64位宽，运行频率为1.35 GHz**，而GPU的为**128位宽，运行频率为675 MHz**[@cpu-brown]。 如果我们做数学计算，两条通道提供的带宽为10.8 GB/s。

前端总线路由只带你到GPU。 因此，在GPU和GDDR3芯片之间，GPU内的**两个内存控制器**用**每个使一个1024位总线**来管理这个连接。 为了减少延迟，内存控制器使用[地址镶嵌（tiling）](playstation-3#tab-6-5-pixel-operations)进行与GPU相关的操作，并使用路径查找来减少CPU拥塞。 一般而言，微软表示GPU和内存之间的带宽为**22.4 GB/s**。

这一切在纸面上看起来都很棒，但我们不要忘记CPU仍然需要走很长的路才能到达内存。 直观地设想一下，如果你使用PIX（随SDK一起提供的CPU分析器）并运行该实用程序附带的样本测试，你会看到每次缓存未命中时，CPU花费**约600个周期**才能到达内存！ 这是基于UMA的系统的_特征_之一，你不会经常看到它在市场上被宣传:），但它也帮助你理解为什么缓存如此重要。

### Xenon内部：编程风格

说完这些，任何人如何利用这个_迷人的_芯片呢？ 好吧，只有一种方法：多线程。

从编程的角度来看，由多个共享相同内存的相同核心组成的CPU就是我们所说的**对称多处理（Symmetric Multi-Processing，SMP）**设计。 这将决定应用程序的设计和实现方式。 截至2022年，这是消费者多核CPU（即x86和ARM）的事实上的布局。

SMP编程使用“虚拟线程”抽象访问物理CPU核心。 虚拟线程是程序员定义的指令序列。 然后，线程可以被提交给“调度器”以执行。 调度器是另一个程序（通常是操作系统的一部分），它处理虚拟线程如何分派到物理CPU核心。

这个抽象层允许程序员避免区分所使用的核心类型（因此使程序与**类似平台兼容**）和硬编码核心数量（使其**可扩展**）。

![Xenon上多线程范式的表示。 一个程序可以创建n个线程（在这个例子中是两个），然后操作系统的调度器负责将线程分派到物理核心。 请注意，操作系统也作为一个线程运行。](_diagrams/cpu/programming.webp)

这种风格成为未来游戏机世代的标准并不奇怪，因为与不对称系统（即 Cell）相比，对称系统更容易扩展和编程。 后者通常依赖于不寻常的编程风格，侵蚀了与其他系统的兼容性。

此外，值得一提的是，虽然SMP编程不一定局限于一个平台，但Xbox 360开发者将只为Xenon编写线程（总共提供六个线程）。 这使他们能够为Xbox平台优化他们的多线程设计。

## 图形

这是Xenon的一个奇特方面。 虽然Xenon芯片本身集成了有趣的技术，使其成为对抗竞争对手的强大竞争者，但Xenon从未被设想为一个独奏者。 为了使整个游戏机具有极强的竞争力和持久的生命力，Xenon与另一个芯片——GPU紧密结合在一起。

::: {.subfigures .tabs-nested}

![刺客信条（Assassin's Creed，2007）](screenshots/games/assassins.jpg){.active title="刺客信条"}

![半条命2（橙盒版）（Half-life 2，2007）](screenshots/games/half_life.jpg){title="半条命"}

![传送门2（Portal 2，2011）](screenshots/games/portal2.jpg){title="传送门"}

![无主之地2（Borderlands 2，2012）](screenshots/games/borderlands.jpg){title="无主之地"}

![侠盗猎车手V（Grand Theft Auto V，2013）](screenshots/games/gta.jpg){title="GTA"}

Xbox 360游戏的一些例子。 它们全部以最大分辨率（1280x720像素）呈现。

:::

这款显卡芯片的设计制造商不是别人，正是[英伟达](playstation-3#graphics)的老对手——**ATI**。 回溯这段历史，一家名为‘ArtX’的新公司由曾参与开发任天堂64图形芯片[Reality协处理器](nintendo-64#graphics)的SGI前员工创立。 之后任天堂再度委托其打造GameCube主机的“Flipper”芯片……而彼时ATI正处在收购ArtX的过程中[@graphics-ati_merger]。 当时的ATI正凭借“ATI Rage”系列显卡在PC领域厮杀，不久便将吸纳Flipper芯片的原班工程师。 时间快进至2005年，英伟达（此时已为索尼供货）又与ATI在主机市场狭路相逢。

_真是经久不衰的商战啊_，谁又能预料这番缠斗中将催生何等革新之作呢？

### 概述

自从21世纪初以来，英伟达和ATI一直在性能上相互竞争，这通常通过向其旗舰品牌添加渐进式改进来实现。

![靠近GDDR3芯片的Xenos+EDRAM一体封装。](photos/xenos.jpg) {.open-float}

在引入[可编程像素管线](xbox#the-importance-of-programmability)后，英伟达获得了相当大的优势，这一技术后来成为OpenGL和Direct3D规范的一部分。 因此，ATI别无选择，只能效仿。 然而，在2003年，在英伟达预期的“GeForce 5”系列让Direct3D 9用户失望后，ATI恢复了其用户基础，这些用户期望从英伟达的旗舰卡中获得更好的性能和功能[@graphics-shimpi_5800]。 因此，人们的注意力转向了ATI的Radeon 9000系列。

这些事件让ATI得以延续其霸主地位，但英伟达未曾料到，ATI早已在酝酿一项足以压制其十年的颠覆性技术。 该计划最终以**统一着色器架构**的形式落地，而承载它的载体正是微软Xbox 360——其搭载的全新图形芯片，代号**Xenos**。

{.close-float}

#### 新基础的到来

你可能会惊讶地发现，微软对同构计算的推动也将GPU带入了这个混合体中。

你知道，曾经有一段时间，GPU只是[简单的光栅化器](playstation#graphics)，只有“接受或放弃”的功能，这意味着它们提供了一组固定的功能，程序员可以选择激活它们或不激活。 直到后来，借助SGI的革新，[可编程顶点管线](nintendo-64#graphics)的出现才将部分算力负载从CPU剥离。 最后，“简单的光栅化器”定义变得_过时_，因为英伟达推广了一个新东西，称为[可编程像素着色器](xbox#graphics)，它给了程序员在光栅化后控制发生什么的自由。

![GPU总览。其由多个单元组成，其中包括可编程着色器。 在本文的例子中，GPU为顶点操作分配的单元比像素操作多，这意味着几何变换的速度会更快，但可能会牺牲一些颜色效果。](_diagrams/gpu/traditional_pipeline.webp)

这表明，随着GPU的性能和功能不断提升，它们将逐渐开放，允许开发者实现他们所需的确切功能。 然而，这也将增加硅芯片的整体复杂性。

多年来，为了满足不断增长的需求，顶点和像素处理管线一直在扩大，但这也带来了新的可伸缩性问题。 毕竟，空间、成本和散热都有其物理限制。 那么，我们应该优先考虑哪些任务呢？ 是顶点操作还是像素效果？ 如果顶点处理能力不足，将会限制像素处理的速度。 同样，如果像素单元的表现不佳，也无法吸引用户，因为它们产生的画面效果会显得单调乏味。

![GPU的组成单元总览，其中引入了一种新的统一管线设计。 现在，顶点和像素处理这两个阶段都拥有相同数量的资源，因此开发者无需因为某些着色器单元性能较弱而减少操作。](_diagrams/gpu/unified_pipeline.webp)

基于此，ATI的架构师们重新思考，提出了两个关键问题：“有没有办法简化这个模型，而不是简单地增加更多的晶体管？”和“为什么像素和顶点管线要分开？” 最终，他们将这两个阶段**合并**为一个统一的电路模块。 这就是我们所说的**“统一着色器模型”**。在这种模型下，GPU仍然支持可编程的顶点和像素管线，但两者的计算电路是共享的。

这个新模型有两个主要优势：一是**更平衡的扩展性**，即像素和顶点管线现在能以相同的比例提升；二是程序员可以开发**不受特定管线类型限制**的着色器程序。 不过，实现这一点需要对API进行重大更改，以标准化其行为和可用性，这些更改要等到2006年的DirectX 10或2010年的OpenGL 3.3才会实现。

可以说，统一着色器模型已经成为图形行业的又一项标准。

### Xenos的架构

在构建Xenos时，ATI借鉴了他们现有消费产品中的技术。 但具体是基于哪款现有显卡开发的Xenos，这一点很难确定。 维基百科将其与Radeon x1800中的“R520”核心联系起来[@graphics-wiki_xenos]，但我对此持怀疑态度，因为R520在新的统一架构方面存在一些根本性的差异。 由于缺乏可靠的资料来源，我转向了Xenia模拟器的Discord社区，在那里我幸运地收到了来自社区的很多回复，特别是TriΔng3l，他在进行模拟Xenos方面的工作。

本质上，Xenos是基于R400（也称为“Crayola”）架构的，这是一个全新设计的架构，但除了Xenos之外，它从未以消费级显卡的形式出现过。 相反，ATI向PC用户提供了基于R500的显卡，这些显卡实际上是R300架构的延续。 有趣的是，一些R520显卡也融入了Crayola的技术，但它们被市场营销为“ATI Avivo”，主要用于视频解码加速。

最终，ATI通过其新的R600架构（R400的演进版本），也被称为“TeraScale”，在2007年随Radeon HD 2000系列显卡将统一着色器模型普及给了广大用户。 其余就是些老黄历了。

有趣的是，R400架构在智能手机领域也得到了延续，那就是ATI Imageon Z430[@graphics-nopixel]，后来更名为Qualcomm Adreno 200，并经历了多次迭代。 这再次证明了创新技术总能找到进入移动市场的途径。

### 硬件组织

Xenos的另一个独特之处在于其**三重内存架构**（对于强调UMA来说…）。 Xenos使用两个不同的芯片来渲染图形，一个是**前面提到的512 MB的GDDR3 DRAM**（这与CPU共享），另一个是同一封装内较小但速度更快的内存芯片（只有Xenos可以访问）。 后者提供了**10 MB的嵌入式动态RAM（EDRAM）**[@graphics-baumann]。 有趣的是，EDRAM并不是一个新成分，它曾在[GS](playstation-2#graphics)、[GE](playstation-portable#graphics)以及最重要的，[Flipper](gamecube#graphics)（也是ATI的发明）中出现过。

这512 MB存储了Xenos渲染一帧所需的大部分（如果不是全部）材料，包括纹理、着色器以及游戏所需的各种类型的缓冲区。 另一方面，10 MB的EDRAM用于需要快速访问的小元素，如Z缓冲区、模板缓冲区、后备缓冲区（中间帧缓冲区）以及任何其他需要的自定义缓冲区。 这减少了共享GDDR3 RAM的拥堵，并加快了使用这些缓冲区的操作速度。

![数据如何在可用内存中进行编排的例子.](_diagrams/gpu/content.webp)

如果这还不够，还有一个第三种来源可以喂养GPU，那就是**直接连接到CPU的线路**！ 与以往所见的不同，CPU可以直接流式传输命令和几何数据，而无需通过传统的在外部内存中存储[命令缓冲区](playstation#tab-3-1-commands)的步骤，从而再次节省了主RAM的流量。 这就是微软所宣传的**Xbox程序合成**（Xbox Procedural Synthesis，XPS），并且是通过两个改变实现的[@cpu-andrews]：

- 首先，CPU的前端总线被调整，以便GPU可以直接从CPU的L2缓存（CPU可能会在那里[程序化生成](playstation-2#infinite-worlds)几何数据）以**128字节**（缓存行的大小）的块为单位获取数据。
- 其次，在Xenon中添加了一个单独的缓存位置，以便GPU可以尽快通知CPU其当前状态。 微软称之为**尾指针写回**，并在CPU更新L2缓存的同时，保持两个组件同步，GPU从中提取数据。 根据微软的说法，这个流程提供了18 GB/s的理论带宽[@cpu-andrews]。

总的来说，这种协同作用使得Xbox 360能够在不要求过高价格硬件的情况下实现如此高性能。

### 构造画面（frame）

那么，Xenon究竟是如何渲染一帧图像的呢？ 其实，它的过程与市场上的其他GPU类似，涉及多个步骤。 你可以通过这个Xenos的图形管线图来了解整个过程 @fig-xenos 。

![Xenos内的图形管线总览](_diagrams/gpu/pipeline.webp) {#fig-xenos}

从图中可以看出，Xenos的图形管线阶段与[其他不使用统一着色模型的图形芯](playstation-3#graphics)片基本相同。 这是因为主要的改变发生在**电路层面**，而不是API层面。 这样，开发者就无需学习可能颠覆他们传统方法的新技术。不过，他们很快就会发现，这种新的底层设计不仅能提升性能，还能提供额外的功能（在传统功能之上）。

另一方面，这款GPU与微软开发的专有API——**Direct3D 9**紧密结合。 由于这款API与市面上的图形卡具有广泛的兼容性，它在PC市场上越来越受欢迎，这也让游戏开发者感到更加轻松。 尽管Xenos会展示一些在市面上看不到的独特行为，但Direct3D是微软提供的唯一一个能与Xenos通信的高级API。 因此，在Xbox 360中，我们发现了一个为Xenos额外功能量身定制的Direct3D 9半定制版本。 有趣的是，Direct3D和Xenos在设计中相互影响，Xenos也影响了Direct3D的未来版本（从版本10开始）。

现在，让我们深入探讨，看看这个图形管线是如何工作的，就像我们在其他文章中所做的那样。

#### 指令 {.tabs.active}

![命令阶段概述.](_diagrams/gpu/pipeline_commands.webp) {.tab-float}

欢迎光临本系列的_第十二个多边形工厂_。 和往常一样，我们从**指令阶段**开始。 指令指导GPU在屏幕上绘制图像的内容、位置和方式。 不过，这次指令的存储方式有所不同，它们可以**存储在主内存的[缓冲区](gamecube#tab-3-1-database)中**，或者**直接由CPU传输**。 然后，**命令处理器**[@graphics-ati_review]会获取这些命令，解析后转发给执行相应操作的单元（因为命令可能包含各种指令，比如“绘制一个三角形”或“设置寄存器X”）。

值得一提的是，在这一代技术中，传统的[显示列表（Display Lists）](nintendo-64#tab-1-1-reality-signal-processor)已逐渐被**命令缓冲区**（Command Buffer）所取代。 尽管这两个术语听起来相近，但命令缓冲区引入了一些显示列表最初设计时未考虑的新操作，如顶点、像素和GPU控制等。 随着API的不断演进，命令缓冲区也随之适应现代需求，而显示列表自2008年起已被弃用（OpenGL在3.2版本中移除了它们）[@graphics-opengl_history]。

此外，Direct3D 9的命令缓冲区（在Xbox 360的官方SDK中提供）支持嵌入一种名为**索引缓冲区**（Index Buffers）的有趣数据格式。 这允许开发者重用顶点数据，避免内存中的几何数据重复[@graphics-indexbuffer]。

最后，这款GPU还能根据开发者设定的条件选择性执行命令。 在Direct3D中，这被称为**预测**（Predication）。比如说它可以避免GPU处理可能被遮挡的几何体。

#### 顶点着色器 {.tab}

![顶点 (vertex) 阶段概述. 你很快会发现，这个阶段和像素阶段也没有 _那样地_ 不同.](_diagrams/gpu/pipeline_vertex.webp) {.tab-float}

自[Flipper](gamecube#graphics)时代（甚至是[RCP](nintendo-64#graphics)时代，因为它有共同的核心开发团队成员）以来，ATI一直致力于提供几何处理单元来加速顶点操作。 随着Xenos的出现，现在可以通过Direct3D的**高级着色器语言**（High-Level Shader Language，HLSL）进行完全编程。HLSL类似于C语言，但用于实现顶点着色器，无需使用汇编语言，尽管汇编语言仍然可以使用。

Xenos和[RSX](playstation-3#tab-6-2-vertex-shader)都遵循顶点着色器模型3.0（`vs_3_0`）规范，该规范定义了一系列共同的功能和限制。 这包括支持**512个或更多**的指令槽位、**分支操作码**以及对**纹理读取**的支持等。 不过，两者的主要区别在于，PlayStation 3的开发者需要使用Nvidia的CG编译器（这是与Microsoft的HLSL合作的结果），而Xenos的开发者则依赖于Microsoft的工具套件，因此使用的是Direct3D的HLSL编译器。

此外，我们不应忽略的是，执行这些操作的硬件基于一个新的公式。 这种新的统一设计意味着顶点数据通过一个共享但更高效的管线进行处理，具体流程如下：

1. 首先，**顶点分组器**根据接收到的指令，读取主内存中顶点数据的内存地址。接着，**曲面细分器**（Tessellator）将这些非三角形几何体（如四边形和参数曲线）转换为三角形，以便GPU的其他部分可以处理。 此外，曲面细分器还能将三角形细分为更小的图元，从而在不增加带宽的情况下实现更精细的细节。 顶点分组器每个时钟周期可以读取**16字节**的数据，并缓存最近处理的**14个顶点**。
2. 随后，**序列器**加载顶点着色器，并使用**8KB的缓存**来拉取顶点数据。
3. 一旦所有顶点数据准备好进行处理，**三个着色器管 线**（每个包含16个ALU）将执行着色器程序。 每个着色器管线每次处理64字节的数据块。 向量到向量的运算需要四个周期，而向量到标量的运算只需一个周期。
4. **着色器导出器**将缓冲结果，并将它们发送回管道的起点，在那里**图元汇编器**会捡起这些数据用于光栅化。 或者，着色器导出器也可以将结果转发到**后端中心**，然后导出到主内存。
    - 这种能力意味着**着色器可以直接将原始数据写入主内存**，当我们讨论到“反盗版”部分时，这一点将非常重要……

#### 光栅化 {.tab}

![光栅阶段概述.](_diagrams/gpu/pipeline_raster.webp) {.tab-float}

一旦图元完成转换或细分，光栅化过程便开始，将图元转换为像素。

首先，**图元汇编器**从曲面细分器或着色器导出器接收顶点数据，并开始构建三角形。 这一过程通常在一个周期内完成，除非需要对顶点进行裁剪和剔除处理，以排除在视界外的不可见三角形。

接下来，**扫描转换器**接收三角形，并将它们组合成8x8像素的块，这些块被称为**图块**（没错，与2D游戏机中使用的[术语](nes#tab-1-1-tiles)相同）。 转换器每个周期生成一个图块，并将其发送到专门单元进行**early Z值和模板测试**。 到目前为止还不错吧？ 有趣的是，这个专门单元采用了一种名为**分层Z**（Hierarchical Z，Hi-Z）的新型高效拒绝技术。

Hi-Z不是单独测试每个像素，而是将**2x2像素**作为一个组，通过计算这四个像素中的最大和最小Z值进行评估。 如果某个四分之一的最大Z值小于内存中存储的对应值，那么整个部分被认为是被遮挡的，因此这个四分之一区域将被放弃[@graphics-baumann]。

Hi-Z块使用专门的内存来执行这些操作，这种内存每个周期可以存储多达16个不同的Z值，用于对**64个像素进行深度测试**。 然而，这种内存的限制意味着，只有当帧缓冲器的分辨率不超过1280 x 720像素，并且启用了最多两个样本的多重采样抗锯齿（2x MSAA）时，Xenos才能执行Hi-Z操作。

最后，扫描转换器将2x2像素块（总计16x16像素）的组以64像素的批次发送到下一个处理阶段，在那里像素着色器会添加那些_引人注目_的视觉效果。

#### 像素着色器 {.tab}

![像素着色器阶段总览](_diagrams/gpu/pipeline_pixel.webp) {.tab-float}

为了运行像素着色器，Xenos重新利用了顶点处理流程中的相同组件，但进行了一些小的调整。 同样，HLSL的像素着色器模型3.0（`ps_3_0`）规范定义了开发人员在这一阶段可以实现的效果，这与[Sony的技术](playstation-3#tab-6-4-pixel-shader)在功能上没有显著差异。 不过，由于底层架构的简化（或者说，统一），资源得到了整合，这使得整个处理流程中各阶段的性能更加均衡。

像素处理阶段的工作流程如下：

1. 首先，**序列器**加载像素着色器程序，并将像素数据传递给插值器。
2. **渲染管线插值器**在四个顶点之间进行颜色插值，生成用于像素着色器的中间值。 每个周期可生成16种颜色。 <!-- TODO: Outputs or inputs 16 colours? -->
3. 接着，**32KB的纹理缓存**从主内存中获取和解压纹理数据，然后**纹理管线**以每个周期16个纹理元素的速度将数据传递给着色器管道。 纹理管线可以立即应用双线性过滤，还可以选择应用三线性过滤和各向异性过滤，但这需要额外的周期。
4. 之前提到的**三个着色器管线**现在用于执行像素着色器，每个管道处理由插值器提供的16个2x2像素块组成的顶点。 <!-- TODO: where did i get this: 16x16 pixel blocks (from the rasteriser) and up to 16 texels (from the texture pipes). -->这些ALU能够处理32位浮点数（符合IEEE 754标准），而不会受到性能影响。
5. **着色器导出器**和**后端中心**将处理结果发送到内存。 后端中心每个周期可以输出两个2x2像素的块，总共8个像素。 此外，还可以导出包括Z缓冲区的新Z值和主内存中的任意数据。
    - 着色器导出器的结果不一定是最终的帧缓冲区数据。在拥有丰富场景的游戏中，通常需要渲染多个缓冲区（即“渲染目标”），这些缓冲区用于合成最终的帧。 这种方法被称为**多阶段渲染**。Xenos图形处理单元支持同时输出**多达四个这样的渲染缓冲区**，即多重渲染目标（MRT）[@graphics-baumann]。

#### 像素操作 {.tab}

![可用的像素操作概述.](_diagrams/gpu/pipeline_post.webp) {.tab-float}

这就是渲染的全部内容，但我们还未探讨的是，那10MB的EDRAM如何提升性能。 这块芯片非常特殊，它内置逻辑电路，能够自动执行**多重采样抗锯齿**（MSAA）以及**深度和模板检测**。 其内部数据传输速率（内部逻辑电路与内部存储器之间）高达惊人的**256 GB/秒**，这使得它非常适合用来存储中间缓冲区，而不是将它们存储在主内存中。

唯一的不足之处在于，10MB的内存空间**不足以**存储大型缓冲区，尤其是当涉及到渲染高清帧（例如1280x720分辨率，并启用2x MSAA）时，更不用说1920x1080分辨率的高清帧了。 但不用担心，因为ATI公司支持一种称为**分块渲染技术**（这种技术在[Dreamcast](dreamcast#graphics)上也有应用）。 通过这种技术，我们可以渲染屏幕的一部分，将结果暂时存储在EDRAM中（以提高性能），最后再将这些分块在主内存中重新组合，形成完整的最终帧。 分块渲染技术的重要性非同小可，以至于微软公司更进一步，开发出了名为**条件渲染分块**[@graphics-tiling]的功能，这是Direct3D中的一个功能，它可以自动为分块渲染优化渲染管线， 无需开发人员手动调整每个渲染阶段来处理分块。

得益于这一新的数据传输速率，游戏设计师们现在可以追求在传统渲染系统下难以实现的高质量效果。 这包括使用更高级的抗锯齿方法（如**4x MSAA**）以及**高动态范围渲染**（HDR）。 你知道吗，HDR渲染需要使用64位像素，其中每个颜色通道都以16位浮点数（`float`）表示。 这种方法在数据传输方面历来开销很大，但它能提供足够的精度来呈现逼真的光影和色彩效果，这是Xbox 360游戏机现在能够实现的一大亮点。

### 行业影响  {.tabs-close}

经过15年的发展，行业现状清楚地表明，统一着色器模型已经成为GPU基本组成部分之一。 有趣的是，当Direct3D 10和OpenGL 3.3分别在2006年和2010年首次亮相时，它们不仅统一了这一模型，而且还引入了新的功能和应用程序，这些功能和应用程序现在可以实现了。 例如，在Direct3D 10中增加了一个新的渲染管线阶段——**几何着色器**，以扩展曲面细分器的使用。

此外，Xenos还引入了新的编码方法，用于存储HDR像素，使用的位数不超过32位（因此，其节省了带宽和存储空间）。 他们提出的一个建议是使用10位浮点数来编码三种主要颜色，剩下的两位用于alpha通道（透明度）[@graphics-nopixel]。 一年后（2006年），Direct3D 10和一个新的OpenGL扩展进一步采用了这个想法，并实现了（现在已标准化的）紧凑浮点数表示，该表示方法使用11位来编码红色和绿色，使用10位来编码蓝色[@graphics-packed]。

![Froggy （2006）是英伟达的最新演示，展示了统一着色器（与GeForce 8系列显卡结合）的强大功能。 为了演示目的，这个演示还允许用户拍打和拉扯那只可怜的丑陋青蛙。](screenshots/windows/froggy.jpg) {.open-float}

同样，自从游戏机发布以来的几年里，Xenos的着色器导出功能被许多新的应用程序编程接口（API）所采纳，包括苹果和Khronos的**OpenCL**，英伟达的**CUDA**，Direct3D 10的**DirectCompute**和OpenGL 4.3的**计算着色器**。 所有这些提供了一个平台，可以访问GPU的强大功能，而不必一定渲染任何东西，只需使用快速的着色器管线进行计算。 总的来说，这是[通用GPU](xbox#the-importance-of-programmability)编程的又一次重大进步。

{.close-float}

如果你想知道这些技术进步是否后来被整合到了Xbox 360中， 恐怕到了这款游戏机发布的时候，统一着色器还是一个相当新颖的概念。 因此，后来的技术发展（比如 Direct3D 10）并没有被回溯整合到Xbox 360上。 但这也为下一代游戏机留下了宝贵的遗产。

而个人电脑市场则经历了一场不同寻常的革命，这场革命的源头并非ATI。 最终，**英伟达**成为了首个推出采用统一着色器模型显卡的公司，我指的是2006年问世的**GeForce 8**系列（及其**Tesla**架构）[@graphics-anand]。 有趣的是，同年PlayStation 3也发布了，虽然它使用的是英伟达的技术，但却是较旧的技术架构。

### 视频输出

与2006年发布的PlayStation 3不同，Xbox 360在2005年的发布正值视频信号从模拟（如RGB 和复合视频）向数字（如 HDMI）转变的时期。因此，Xbox 360的早期版本并没有附带后来迅速替代了模拟视频混合局面的[HDMI接口](playstation-3#a-unified-video-output)。

![两个不同版本的Xbox 360叠放在一起，上面的是Zephyr版本，下面的是Xenon版本。 请注意，Zephyr型号增加了HDMI接口，而Xenon版本仅配备了复合视频接口。](photos/xenon_zephyr_back.jpg) {.open-float}

最初，第一个版本（称为**Xenon**，与CPU同名）仅配备了一个名为‘A/V’的复合视频接口。 这个接口承载了所有[初代Xbox](xbox#the-xboxs-frame)上的信号，并增加了支持VGA的接口[@graphics-xbox360av]（初代Xbox有这些线路，但出于某种原因，从未启用[@graphics-xboxav]）。

后来，在2006年，后续的主板版本**Zephyr**最终添加了HDMI接口，以跟上索尼的信号质量。 在内部，原始的视频编码器（称为**ANA**芯片）已被‘HDMI ANA’（或**HANA**）模块取代[@graphics-ana]。

{.close-float}

尽管这在今天可能显得陈旧，但微软仍然规定开发者必须考虑他们的游戏在阴极射线管（CRT）屏幕上运行，这种屏幕倾向于产生过扫描。 因此，游戏不能在[过扫描区域](nes#constructing-the-frame)内放置任何重要指示标志。

#### 昙花一现的功能

为了符合视频电子标准协会（VESA）的要求，微软在2008年11月发布了一个系统更新，以支持16:10的宽高比，但这项支持仅限于通过VGA信号输出。 游戏仍然只需要支持16:9和4:3的宽高比，因此使用16:10时会出现黑色边框（也就是 黑边）。 有趣的是，操作系统中内置了相关功能，允许游戏检测何时启用了16:10模式，但这些功能从未向公众开放。

此外，微软在2011年5月发布了一个系统更新，以添加对3D电视的支持，与[PlayStation 3的做法](playstation-3#real-3d-visionprojection)类似。

#### 对分辨率的新态度

尽管视频编码器支持多种信号格式，包括PAL、NTSC、720p和1080p，但微软建议发行商**优先考虑720p分辨率**，原因有二：

- 首先，2005年的普遍预测是，大多数消费者电视将很快支持高分辨率和宽屏显示。
- 其次，由于掌握Xenos的能力需要时间，预计首发游戏不会使用所有GPU资源。 因此，游戏轻松地加入了高清支持作为弥补。

那么，为什么不选择1080p作为重点呢？ 这是因为1080p对Xenos的负担显著加重，从而限制了抗锯齿等效果的实施。 因此，微软建议开发者在720p分辨率下渲染游戏，如有需要，再通过内部视频缩放器将其提升至1080p。 为了协助这一点，微软在2006年10月发布了另一个软件更新，以启用1080p（最初，只有1080i可用）。

## 音频

随着中央处理器（CPU）发展为多核心的多面手，专用音频硬件的必要性逐渐减弱。 最终，微软决定Xbox 360的音频处理将由CPU负责，因此，**音频处理管线完全通过软件来完成**。 操作系统提供了游戏通过官方软件开发工具包（SDK）访问的例程。 这带来了新的优势，因为CPU的通用处理能力不仅限于一组固定的音频功能。

一年后，PlayStation 3也将[采用相同的做法](playstation-3#audio)，从而在视频游戏行业中确立了这一趋势。

### Xbox 360的音频硬件解码器

相反，在Xbox 360的情况下，我们看到了一个显著的例外：微软在主板上集成了一个**硬件音频解码器**[@cpu-andrews]。 这个解码器位于南桥芯片内部（在‘I/O’部分有更详细的解释），并且它专门设计来支持一种称为Xbox Media Audio (XMA)的编解码器。 XMA是微软专有的**Windows Media Audio** (WMA)格式的一个变体，你可能已经熟悉它了。 那么，为什么这个编解码器如此重要，以至于微软在已经面临预算削减的游戏机上额外投入了硬件资源呢？

#### 多媒体编解码器的兴起   {.tabs.active}

![1999年发布的Windows Media Player 6 成为了微软对抗其竞争对手，如QuickTime、Winamp等的重要工具。 ](screenshots/windows/media6.jpg) {.tab-float.no-upscaling}

在21世纪初（甚至是上世纪90年代末），随着互联网的普及和价格亲民的多媒体产品（如加速卡、支持SIMD的CPU和快速网络带宽）的出现，许多曾经主要专注于生产软件的公司开始涉足多媒体服务领域。

用户现在希望电脑能做更多的事情，比如观看全动态电影，在处理电子表格时听音频CD，以及翻录（甚至混合）音频CD，仅举几例。 当然，我们现在认为所有这些都是理所当然的，但这些“能力”在历史上的某个时刻必须被实现。 最初，它们是通过第三方软件提供的（例如 Nero和Winamp），后来随操作系统捆绑（例如Windows XP及其集成的CD刻录功能； 以及捆绑了iTunes的Mac OS X 10.1）。

现在，深入探讨音乐领域及其不断发展的分享系统，我们会发现MP3已成为音乐传输的主流编解码器[@audio-mp3]。这引发了市场对能够解码MP3（更准确地说，是MPEG-1）的媒体播放器的巨大需求。 那么，微软是如何应对这一趋势的呢？ 他们选择开发一种_新的_编解码器来替代MP3，这种新格式被称为**Windows Media Audio**，简称“WMA”[@audio-wma]。

#### WMA的再次推广 {.tab}

![Windows Media Player 11于2006年发布。 它拥有更精美的用户界面和更多的专有编解码器！](screenshots/windows/media11.png) {.tab-float}

然而，对于微软来说，不幸的是，WMA的普及程度并没有达到MP3的水平，这可能是微软的许可政策所致。 更糟糕的是，微软通过发布不兼容旧版本的更新和提供不同层级的版本，使得WMA用户群体变得分散。 尽管如此，微软仍然通过其他途径努力推广WMA，例如，通过DirectX的音频播放库“DirectShow”[@audio-directshow]。

现在，不难发现这两者之间的联系。 初代Xbox被设计为一个与DirectX兼容的游戏机，尽管对此可能有不同看法，但这个口号同样适用于Xbox 360。 因此，WMA在这款游戏机上的延续也就不足为奇了。

然而，微软并没有直接采用现有的WMA格式。 相反，他们对其进行了优化，使其对已经采用索尼[ATRAC3](playstation-portable#audio)的游戏工作室更具吸引力。 具体来说，微软选择了高端的WMA层级——“WMA Pro”，并增加了更多适合Xbox 360带宽容量的压缩级别。 最后，他们将这种格式重命名为**Xbox Media Audio**，简称“XMA”。

为了进一步完善，微软增加了专门的电路，用于在解压缩任务期间减轻CPU的负担，从而让CPU能够专注于游戏的其他方面。

### 一窥XMA解码器  {.tabs-close}

就功能而言，XMA解码器能够解码多达**5.1声道的音频**，支持**48 kHz**的采样率和**16位**的分辨率。 这些规格都在意料之中，没有太多惊喜。

![音频管道概述.](_diagrams/audio.webp)

XMA解码器的工作流程如下：

1. 首先，它从主内存中读取XMA编码的数据。
2. 然后，对这些数据进行解码。
3. 接着，输出PCM数据，使其准备好在主内存中的任意位置进行流式传输。
4. 最后，CPU可以对这些数据进行效果处理，或者将其发送到音频DAC以供聆听。

所有这些操作都通过微软的库来实现抽象化，这些库负责管理数据的流式传输、缓存优化以及内存中的移动。 开发者可以使用多个API，每个API提供不同程度的抽象层。 然而，即便是最低层的API也无法直接访问XMA解码器，因为它仍然是一个专有且未文档化的电路块。

## I/O

继承初代Xbox的[设计](xbox#io)，所有I/O操作都由一个名为**南桥**的复杂且不透明的芯片管理（尽管在我看到的各种文档中，它也被引用为“I/O芯片”或“XBS”）。 南桥几乎连接了所有的内部和外部接口。 值得注意的是，这个芯片仅与GPU相连（而非CPU），因此Xenon处理器需要通过Xenos芯片来访问南桥，并进而从任何接口请求数据。

![南桥芯片负责管理和控制小型I/O芯片及各种接口。](southbridge.png){.tabs-nested .active title="原版"}

![带有重要部件标签的同一张图](southbridge_marked.png){.tabs-nested-last title="标注版本"}

南桥与Xenos之间的通信采用**PCI Express协议**，该协议包含两条单向串行总线，分别负责不同方向的传输。 在这款游戏机中，每条总线的数据传输速率高达**500 MB/s**[@graphics-baumann]。

### 智能L2缓存策略

为了应对高需求，**南桥具备直接写入主内存的能力**。 这就需要一种机制来确保CPU缓存与南桥对主内存的修改保持数据一致性。 因此，南桥被设计为一个**自动触发器**，当且仅当南桥写入的内存地址已被CPU缓存时，它才会清空CPU的L1和L2缓存。 尽管CPU需要重新缓存这些内存地址，但程序员无需担心在南桥修改主内存时手动同步CPU缓存。

### 南桥的核心组件

如你所见，第七世代游戏机中提供了众多服务，这导致了许多被称为“黑盒”的组件被集成进来。 这些黑盒的主要作用是将安全和I/O任务从用户可接触的部件（如CPU和GPU）中分离出来。

![南桥连接的示意图。](_diagrams/southbridge.webp)

Xbox 360也采用了这种设计。 在南桥芯片内部，有一个名为**系统管理控制器**（System Management Controller，SMC）的组件。类似于[Wii](wii#the-hidden-co-processor)，即使处于待机状态，SMC也会消耗电力。 SMC负责处理许多I/O操作，包括电源管理、实时时钟、温度控制、LED控制和红外传感器[@io-smc]。 CPU通过[FIFO命令缓冲区](nintendo-ds#interconnection)与SMC通信，但这项任务仅限于内核操作（更多详情将在“操作系统”部分介绍）。 因此，普通用户和游戏都无法直接干预SMC的操作。

在内部结构上，SMC其实就是一个配备了自己的ROM和RAM的经典**英特尔8051**微控制器[@anti_piracy-smc_hack]。 一旦接通电源，它就会启动内置程序，并从单独的NAND芯片中读取配置文件。

SMC还有许多其他引人入胜的特质，我们将在适当的时候进行探讨（_请放心，我会在“反盗版”章节中详细介绍……_）。

### 外部接口

游戏机的外部接口虽然不算繁多，但种类还算齐全。

![这是游戏机的前视图，部分接口被设计巧妙的弹簧门所遮挡。](photos/front.jpg)

这款游戏机提供了多种接口，具体如下：

- **三个USB 2.0 A型接口**：背面有一个，用于连接外部设备，如微软单独销售的官方Wi-Fi模块。 前面有两个，用于连接有线控制器。
  - 自2010年Xbox 360薄型机推出以来，游戏机开始内置Wi-Fi卡（同样在内部连接到USB），并在背面增加了两个USB接口。
- 一个特殊接口，结合了**USB和专有接口**，用于**RF模块**，也被称为前面板。当游戏机开启时，这个面板会亮起。 它还负责无线控制器之间的通信（通过一种**专有无线协议**）[@io-rf]。
- **两个记忆单元端口**：这些是特制的USB端口，适用于Xbox专有的[记忆单元](xbox#the-controller)，容量高达512 MB[@io-storage]。
- 一个**RJ45端口**，用于以太网连接。
- **红外接收器**，用于捕捉由Xbox主题遥控器（一个可选配件）发送的红外光。
- **一个SATA II接口**：与电源线结合，形成一个专有接口，并暴露在机箱顶部（如果游戏机垂直放置），用于连接可选的外部硬盘驱动器。

#### 有线与无线的游戏体验

索尼选择直接使用蓝牙技术实现无线控制，而Xbox 360则根据购买的不同版本配备了不同类型的控制器。需要注意的是，这并不影响主板版本，只是影响了随盒附带的配件数量。

![新款无线控制器/游戏手柄[@photography-amos]， 背面需安装两节AA电池。](amos/controller.png){.open-float .no-borders width="70%"}

无线控制器通常随高端豪华版赠送，而基础版或无硬盘的街机版则配备了一个有线控制器，使用标准的**USB-A型线缆**连接。 无线控制器需两节AA电池供电，但微软也提供了可充电的电池组供购买。

游戏机支持同时连接四个控制器，无论是无线还是有线，但游戏机仅提供了三个用户可用的USB端口。

{.close-float}

相较于旧款的[“Duke"手柄](xbox#the-controller)，新款控制器不再配备两个记忆卡插槽，但依旧保留了2.5毫米TRS类型的耳机插孔。 无线型号的控制器前方设计有一个特殊接口，用于连接“播放与充电”线缆。这是一款可选配件，能够将无线控制器与游戏机连接，并在充电的同时进行游戏。 该线缆采用专有总线设计，包含符合USB标准的引脚以及一些未公开记录的额外引脚[@io-gamepad]。

### 内部接口

南桥芯片负责处理主板内部各芯片之间的以下接口：

- **SATA II接口**：用于连接内置DVD驱动器。
- **专有8位总线**：用于与16 MB NAND Flash芯片进行通信。
- 另一条专有总线：用于与音频DAC进行通信。

### _特别的_互动配件

通常我不会过多关注配件，因为它们不是文章的重点。但有一个例外，微软为它投入了大量的营销资源。 他们甚至坚信“游戏手柄已经过时”，这款新产品将很快颠覆现有的用户交互方式。

尽管预期中的变革并未发生，但**Kinect**依然是一个值得研究的设备。 2010年11月，伴随着巨大的轰动，Kinect问世了。它是一种传感器条（与[Wii的传感器条](wii#next-gen-controllers)截然不同，后者既是Kinect的竞争对手也是其灵感来源），能够捕捉用户的位置、动作和声音，旨在实现无需用户手中持有任何物体即可控制游戏的效果。

![Kinect传感器条，发布于2010年11月[@photography-amos]](amos/kinect.png) {.no-borders}

这个设备的构造相当复杂，其传感器集成了多种先进技术：

- **RGB摄像头**：用于捕捉房间和玩家的图像[@io-kinect_hardware]。
- **红外发射器**和**红外传感器**：分别用于发射红外光并捕捉其反射， 从而生成房间的深度缓冲数据，识别物体的深度。
- **麦克风**：用于捕捉玩家的声音。
- 这些传感器由一个_复杂的芯片组_处理， 包括**64 MB的DDR2 SDRAM**（作为工作内存）、**1 MB的闪存**（存储主程序）、**Marvell AP102 SoC**（可能包含主CPU）和**PS1080-A2 DSP**（处理来自摄像头的图像）等。 这些芯片安装在三块不同的堆叠在一起的电路板上[@io-kinect_teardown]。

Kinect通过微软的不透明API进行操作，这些API与安装在Kinect和Xbox 360操作系统上的绝密软件进行通信。 Kinect通过**USB 2.0 A型接口**连接到游戏机。 同年发布的Xbox 360薄型重新设计版也被称为“Kinect兼容”，因为它还能为传感器条供电（在游戏机背面提供了一个额外的专有端口），而旧型号则需要一个单独的电源砖来为Kinect供电。

## 操作系统

Xbox 360与PlayStation 3一样，面临着相似的需求和潮流。 因此，它提供了许多服务，包括在线游戏（通过Xbox Live）、数字市场、媒体播放器、文件系统资源管理器（虽然功能非常基础）以及其他实用工具。

### 概述

Xbox 360的操作系统是一系列紧密集成的裸机实用程序和用户空间应用程序，被压缩在**16 MB的NAND存储空间**内。 与PlayStation 3类似，微软设计的操作系统旨在提供多媒体播放、网络（如多人游戏）功能，以及游戏运行和系统安全防护。

这意味着该系统包含一些核心组件，负责处理游戏机的低级功能，如硬件访问、安全防护和资源管理。 除此之外，还包括各种应用程序（例如启动动画、名为‘Dashboard’的交互式用户界面以及游戏本身）和用户数据（如游戏存档、用户配置文件和网络设置）。

#### 动荡的进步

在Xbox 360的生命周期中，我注意到了比竞争对手更为混乱的演变，这涉及到了用户界面的不断重新品牌化和彻底重新设计。 我推测微软试图从一群目标受众转向另一群。 因此，为了更好地理解这一部分，我将它的演变组织成以下几个时期：

- **多媒体中心时代**（2005-2008）：作为第七世代首款亮相的家庭游戏机，高清图形、Xbox Live（在线平台）和高清电影是主要的卖点。 如果你对它们感到厌倦，你可以购买配件[@operating_system-acc_promo（例如遥控器、耳机、HD DVD阅读器）来“增强”你的体验。
- **竞争时代**（2008-2011）：随着PlayStation 3和Wii占据商店空间，微软发现自己需要积极争夺消费者的注意力。 首先，一个新的系统更新称为“新Xbox体验”彻底改革了旧界面，以增加用户个性化（例如3D头像）并增强这个游戏机的社交方面。 同时，一个新的“杀手级应用”以物理配件的形式出现：Kinect。 没有人知道它的结果，但它证明是一个非常吸引人的话题。
- **云时代**（2011-2013）：随着所有之前的热情逐渐消退，微软简化了用户界面，与其其他平台（Windows 8和Windows Phone 7）保持一致，并提供了用户将本地数据移动到云端（即微软的服务器）的机会。  在这个过程中，第三方广告在用户界面中变得更加突出（可能是为了增加收入来源）。 尽管如此，用户现在期待Xbox 360的继任者。
- **屈服**（2014年及以后）：随着新的继任者（Xbox One）到达商店，微软对其（现在）旧的游戏机投入了最小的努力。 用户将只收到以错误修复形式的系统更新。

#### 可召回的安全体系设计

回顾我对[PlayStation 3操作系统的分析](playstation-3#operating-system)，该系统被划分为三个主要部分：

- **管理程序**（Hypervisor），它完全控制硬件。
- **内核**，它负责将用户程序（主要是游戏）与管理程序进行交互，从而提供额外的安全保护。
- **用户空间**，涵盖所有在内核之上运行的应用程序，包括游戏和其他软件（如用户界面（shell）和媒体播放器）。

这种设计理念与[PPU的处理器权限级别](playstation-3#cells-privileged-security)（影响Cell和Xenon处理器）紧密相关，能够防止一般应用程序（如游戏）访问敏感资源，例如解密密钥。

IBM采用了三种权限级别（而非传统的两种），以支持同时运行多个操作系统。 按照这一设计，每个操作系统只能在最低的两个权限级别运行，而最高权限级别则专门保留给负责监控所有操作系统的管理程序。 在实际应用中，PlayStation 3和Xbox 360通常仅需要一个操作系统（尽管曾短暂支持[OtherOS功能](playstation-3#a-multi-os-proposal)，但很快被取消）。 因此，索尼和微软分别设计了各自的管理程序，以实施各自的安全策略，并执行内存管理任务。 由于Cell和Xenon在架构上的差异，这两种管理程序的实现方式存在显著差异，从而各自拥有独特的优势和潜在弱点。

![该图表展示Xbox操作系统的组件如何适应Xenon的权限级别。 ](_diagrams/os_levels.webp)

Xbox 360和PlayStation 3在安全模型上的主要区别在于，Xbox 360在**相同的权限级别**（第二级）下同时运行内核和用户空间程序[@cpu-steil]。 因此，所有关键任务都由管理程序承担，它还从硬件方面获得了额外的加速支持（我将在“反盗版”部分详细说明）。

### 架构

接下来，我们详细分析操作系统的主要组成部分。请注意，这部分内容不包括引导加载程序，关于引导加载程序的内容，我将在单独的部分进行讨论。 现在，让我们关注游戏机启动后驻留在内存中的那些组件。

#### 管理程序 {.tabs.active}

管理程序是一个极其小巧的程序，仅占用**128 KB**的内存空间[@operating_system-renard]。 由于其被赋予了最高的权限级别，它承担着以下关键任务：

- 防止程序越界访问内存区域。
- 通过与页表结合使用，它控制了CPU能够执行内存的哪些部分。 这种机制被称为**写异或执行**（Write Xor Execute，简称‘W^X’）。
- 对可执行代码进行加密。
- 只加载由微软签名的可执行文件。
- 保护内存数据不被篡改。 这是通过对主内存中的数据进行加密，并在CPU从L2缓存中取出后立即解密来实现的。
  - 这个功能虽然复杂，但非常有趣，我将在后面的反盗版部分进行更详细的介绍。

管理程序通过系统调用来进行操作[@operating_system-hypervisor]。外部程序通过这些系统调用来请求管理程序提供的服务。 然而，管理程序是否会响应这些请求，取决于程序的认证级别。

#### 内核 {.tab}

管理程序主要负责底层硬件服务，因此引入了**内核**作为额外的抽象层。 内核同样驻留在内存中，但权限级别低于管理程序。 内核的主要职责是提供用户空间程序可以利用的功能，例如：

- **设备驱动程序**：内核负责处理输入/输出（I/O）操作，这样程序就不需要针对特定硬件进行编码（避免产生依赖于平台的代码），从而确保旧游戏也能在后期版本的Xbox 360上运行。
- **文件系统管理**：文件系统决定了数据在物理存储介质上的组织方式。Xbox 360支持多种存储介质，内核为每种介质提供了相应的文件系统支持。 这样，程序就可以通过文件和目录来操作持久存储，而不需要直接处理原始的存储扇区。
- **引导**核心应用程序：当内核启动后，它会负责启动用户界面和其他关键的可执行文件，从而允许用户与游戏机进行交互。
- **线程调度**：还记得前面关于编程风格的段落吗？ 线程调度器就在这里。 调度器采用**抢占式多任务处理机制**，以确保线程之间能够高效交替执行，避免系统出现阻塞。
  - 为了确保所有运行的服务都能获得良好的性能，调度器对线程的执行进行了一些限制。 例如，它将第四个硬件线程专门用于处理音频数据和软件下载，而第二个硬件线程则优先处理文件系统的并发操作。

内核为了正常运行，会从主内存中**预留32 MB的空间**，用于分配其所需的资源。

#### 用户空间 {.tab}

用户空间程序指的是那些在内核之上运行的可执行文件。 这些程序以**Xbox可执行文件**（Xbox EXecutable，XEX）的形式存在[@operating_system-fs]，其结构与传统Windows系统的EXE文件类似，但专为Xbox 360进行了定制。 最主要的区别在于，XEX文件的可执行代码采用PowerPC ISA二进制格式（而非x86架构），并且需要在加密后才能运行。这些代码使用微软的私钥进行签名，并在文件头和元数据中存储哈希值，以防止被篡改。

从启动动画到游戏本身，所有这些程序都是以独立的XEX文件形式存在的。 有些XEX文件由内核自动加载（如启动动画和交互式shell），而其他文件则由用户通过shell手动加载（如游戏和媒体播放器等）。 当用户或内核请求运行某个XEX文件时，内核会先将该文件复制到主内存中，然后管理程序会对其进行签名验证和重新加密，将相关内存区域标记为可执行状态，并最终指示CPU执行该文件[@cpu-steil]。

尽管Xbox 360在游戏之间并不支持复杂的多任务处理（我认为这对游戏机来说并不是主要功能），但内核仍然需要32 MB的主内存作为其工作空间。 这使得用户能够在游戏中打开**Xbox指南**（通过按下控制器上的“Xbox”按钮弹出的菜单）或在游戏进行中播放音乐。 为了在全屏应用程序之间进行切换，Xbox指南提供了一个选项，允许用户返回到仪表盘并启动其他程序。

最后，所有用户数据都被集中管理在一个虚拟的**个人资料**中。 为了管理这些个人资料相关的服务，如成就记录、头像选择和保存游戏数据，内核会运行一个名为“XAM”的程序[@operating_system-ss]。 当用户首次启动游戏机时，系统会创建一个新的个人资料，且支持存储多个个人资料。

### 向后兼容性 {.tabs-close}

一个有趣的现象是，Xbox 360能够运行许多前一代Xbox（我们称之为“经典Xbox”）的游戏。 这是通过纯粹的**软件仿真**实现的，尽管它并不具备与[CECHA版PS3](playstation-3#backwards-compatibility)相同的兼容性水平，但我认为这些方法更巧妙、更经济、更一致。

该仿真器被称为“FU”[@operating_system-brundage]（作为`xefu.xex`文件存在），并且只能安装在硬盘上，与其他操作系统的可选资产并存。 每次用户在Xbox 360上启动经典Xbox游戏时，FU都会加载。 然而，为了确保用户获得良好的体验，FU只有在游戏列在其本地**白名单**中时才会进行仿真，微软在这个白名单中跟踪哪些游戏被认为是“可玩”的。 随着更多系统更新的发布，更多的游戏被添加到白名单中。

FU的作者之一Michael Brundage将开发过程描述为“可能是我的职业生涯中最艰难的技术挑战”，并提到“大多数标准库在效率上都不尽如人意，尤其是在数学方面” [@operating_system-brundage]。

### 存储介质

在了解了操作系统的基本结构之后，接下来我们将探讨信息是如何在Xbox 360上存储和分布的。 您会注意到，游戏机提供了多种存储介质，为了确保系统的安全性，微软开发了多种文件系统和协议来管理这些介质。

#### 启动ROM {.tabs.active}

这里存储着这个游戏机上最关键且脆弱的程序。 与PlayStation 3类似（再次说明，两者都采用了IBM的技术），Xenon隐藏了**32 KB的ROM**，其中存储了引导加载程序的第一阶段，以及用于解密和验证后续引导阶段的微软RSA公钥和SHA-1哈希值[@operating_system-boot_process]。

由于该区域的安全系统**尚未设置**，且CPU只能理解未加密的机器代码，因此这个区域恰好是未加密的。但这并不是微软担心的问题，因为引导ROM被封装在CPU芯片内部，而且公钥不能被用来破解系统。 然而，作为一个“ROM”，这也意味着这段代码在离开工厂后无法被修补。

无论如何，引导ROM只在游戏机开机后被执行一次。

#### 内置NAND {.tab}

![NAND芯片](photos/nand.jpg) {.tab-float}

在每台Xbox 360的主板上，您都会发现一个**NAND闪存芯片**。 微软使用这个芯片来存储以下内容[@operating_system-nand_fs]：

- 引导ROM之后的剩余引导加载程序。
- 管理程序和内核。
- 系统更新（以管理程序和内核的增量补丁形式）。
- 用户空间程序（即启动画面、仪表盘、XAM/个人资料管理器、媒体播放器等）。
- 游戏机唯一信息，如序列号、地区以及用于各种操作的独特加密密钥。 这个区域也被称为“密钥库”。
- 系统管理控制器（位于南桥内的微型计算机）读取的配置数据，包括用于热控制的校准。 这也被称为“配置块”。

所有这些数据都以多种方式加密。 其中大部分使用微软的私钥结合其他密钥进行加密，这在理论上使得篡改它们变得几乎不可能！

与PS3不同，微软成功地将所有这些数据塞进一个**16 MB**的芯片中，尽管2008年和2009年的一些版本配备了256 MB和512 MB的NAND芯片[@operating_system-jasper]。 然而，这并不是一个破坏性的改变，因为额外的空间被划分为一个单独的分区，并被视为一个记忆卡。

#### 记忆卡和硬盘 {.tab}

![记忆卡。最便宜的存储介质 但它们仅适用于2010年之前的主机版本。](amos/mem_units.png){.tabs-nested .active .tab-float title="记忆卡"}

![外置硬盘 作为单独的配件销售，并随“高级”版本一起附带。 硬盘外壳内部有一个传统的2.5英寸硬盘，连接到数据线和电源适配器。](amos/hdd.png){.tab-nested title="外置硬盘"}

![内置硬盘，是薄型机（2010）的另一种配置。 硬盘外壳被安装在一个隐藏的插槽中，不需要任何类型的适配器（它的唯一目的是防止晃动）。](amos/hdd_slim.png){.tabs-nested-last title="内置硬盘" width="60%"}

当你将游戏机立起放置时，可以看到前面有**两个“记忆卡”插槽**。 在游戏机的顶部，你会发现一个修改过的SATA接口，用于连接**硬盘驱动器**（只适合那些由微软封装和销售的硬盘）。 这两种存储介质都是**选装的**，并用作**大容量存储设备**。

在安装了这些存储介质后，Xbox 360会对其进行初始化，并创建多个分区。 但有趣的是，它并不会创建一个主分区表。 实际上，每个分区的位置（偏移量）都是预先设定在内核中的，所有分区——除了存储用户数据的分区——的大小都是固定的。 此外，每个分区都使用专有且未记录的文件系统，包括用于通用数据的“FAT Xbox”（**FATX**）文件系统，以及用于缓存数据的“安全事务文件系统”（Secure Transacted File System，**STFS**）[@operating_system-fatx]。

只要还有存储空间，无论是记忆卡还是硬盘，都可以用来存储用户配置文件、游戏存档、下载的游戏（最初称为“街机游戏”）以及可下载内容（DLC）。 不过，只有硬盘能够存储Xbox经典游戏模拟器，这个模拟器会在插入经典Xbox游戏光盘后自动下载到硬盘上。

微软出售的记忆卡最大为**512MB**，硬盘最大为**500GB**[@operating_system-storage]。 你可能会想，“那么，如果我更换外壳内的硬盘为更大的硬盘会怎样？”但这已经被预料到了，因为微软出售的所有硬盘驱动器都嵌入了一个**安全扇区**分区，以防止用户使用第三方硬盘[@operating_system-security_sector]。 这个块编码了硬盘的独特属性（序列号、型号号、大小等），内核会将其与硬盘的元数据进行比较，此外还有微软标志的位图（以减轻使用商标法进行分发的风险）和一个RSA签名（以防止第三方制作自己的安全扇区）[@operating_system-hdd_upgrade]。 尽管如此，一些用户最终通过手动覆盖硬盘驱动器的元数据找到了解决方法 [@operating_system-hddHackr]。

#### 外部USB {.tab}

![典型的U盘[@photography-amos]](photos/usb.png){.tab-float .no-borders width="60%"}

2010年4月，微软承认_了廉价U盘（它们已经征服了每个家庭）的入侵_，并发布了一个软件更新，允许在Xbox 360上使用U盘，作为扩展存储空间的一种方法。

U盘可以存储硬盘上大多数的内容（包括游戏），除了Xbox经典模拟器。 可以说，USB 2.0的理论带宽（480 Mbit/sec或60 MB/sec）与内部的SATA I协议（1.5 Gbit/sec或187.5 MB/sec）不相匹配，但有一个额外的存储选项总是受欢迎的。

在幕后，U盘被格式化为广受欢迎的**FAT32**文件系统。 此外，内核还会创建一个隐藏文件夹，用于存储包含FATX结构化数据的blob [@operating_system-usb]，这些数据就是Xbox 360相关的数据存储的地方。 这种设计使得游戏机能够在“不安全”的存储介质中满足其安全要求，尽管如此，从U盘上只能访问**最多16GB**的数据[@operating_system-usb_limit]。

### 启动过程 {.tabs-close}

好了，现在你已经了解了这个系统的工作原理、结构以及存储位置。 但是，还有一个关键问题需要解答，那就是如何从“无”（即关闭状态）转变为“运行加密内核的管理程序，加载由微软签名的可执行文件”？ 这就是引导加载器的作用，而这个过程包含了_许多，许多_阶段。

#### 多核混沌 (Multicore chaos)

在开始之前，我们需要解决一个基本问题。 对于同构多核CPU来说，所有核心都有权“掌控”整个系统，但这只会导致混乱，因此，只由一个核心负责指导其他核心。 这个领导者通常被称为“主核心”，而其他核心则被称为“从核心”或简称为“核心”。

在Xbox领域之外，这种核心层次结构有时是直接嵌入到芯片硬件中的，而其他架构则需要人工介入来设定。 例如：

- 在ARMv7架构上，所有核心会同时启动并寻找同一个重置向量（`0x00000000`）。 因此，程序在多个核心上运行时，必须让每个核心查询自己的`mpidr`寄存器，以确定自己是在主核心还是从核心上运行。 这样之后，核心就可以采取适当的行动（比如发布指令或等待命令）[@operating_system-mpidr]。
- 对于x86架构，第一个启动的核心是主核心。 因此，第一个核心从`0xFFF00000`地址开始执行，而其他核心则处于休眠状态。 接着，主核心会向邻近的核心发送一个中断，其中包含一个任意地址，指示它们从哪里开始执行。

在PowerPC的情况下，情况就比较复杂了，因为Xenon是一个定制的设计，并不属于IBM的PowerPC 2.02规范。 但是，通过研究这款游戏机的低级自制源代码[@operating_system-mainc]，我推测它的启动处理过程与x86架构类似。

#### 启动流程

说到这里，现在我将描述用户按下电源按钮后Xbox 360的操作。

首先，主核心的重置向量似乎是`0x80000200.00000000`[@operating_system-resetpc]，这指向CPU内的一个_秘密位置_：前面提到的32KB的启动ROM，这是启动过程的第一阶段所在的位置。

为了完整起见，将简要提及一种特殊设备，称为“电子熔丝”（eFuse）。 这是另一种类似于ROM或RAM的存储介质，但具有独特的物理特性。 我将在“反盗版”部分详细介绍它，以避免让你感到不知所措，所以现在只需记住这些基本事实。

不再赘述，以下是启动链的工作原理。 这一切都从启动ROM开始，然后按照以下步骤进行\[@operating_system-boot_process\] \[@operating_system-kernel_boot\]：

1. **1BL**（即“第一引导程序”）：主核心被指示从NAND闪存中获取下一阶段（称为“CB”）并加载到内部SRAM中。 CB被发现使用RC4算法加密。 因此，CPU使用存储在1BL中的一个密钥和存储在CB头部的另一个密钥来派生出一个解密密钥。 一旦解密，CPU通过散列解密区域并将其生成的散列与CB中存储的另一个散列进行比较来检查其有效性。 后者还使用存储在内部ROM中的微软的公共RSA密钥来验证散列。 最后，如果整个过程顺利完成，没有问题，CPU将继续在CB处执行，否则，CPU会触发一个POST错误，Xbox 360开始闪烁红灯。
    - 这个过程涉及多种密码的组合，如HMAC、SHA-1和ROT。
2. **2BL**或**CB**：现在从内部SRAM执行的CPU查询电子熔丝，以检查正在运行的CB版本是否与eFuses上写入的版本匹配。 然后，它初始化大部分硬件。 最后，CPU继续从NAND获取另一个称为“CD”的块到主内存，并重复1BL所做的类似的解密和验证任务，这次使用从“CPU密钥”（存储在电子熔丝中）派生的另一个密钥。 如果一切顺利，下一阶段将继续。
    - 在后来的软件更新中，这个过程被分为两个引导程序（名为CB_A和CB_B），以减轻被利用来执行自制软件的故障（更多细节在‘反盗版’部分）。
3. **4BL**或**CD**：这是另一个解密阶段，更接近实际的运行负载。 在这个阶段，CPU会获取另一个名为**CE**的数据块，它将经历一系列熟悉的验证过程（包括RSA检查），并在主内存中被解压缩。 一旦解压完成，CPU将直面**内核**和**管理程序**。 但过程还没结束，CPU必须接着获取系统更新并应用到这两个程序上，这个过程被称为**CF**。 然而，在继续之前，CD会命令比较已安装的更新数量与电子熔丝块中预设的计数器， 这是为了防止系统被[降级](playstation-portable#tab-6-2-downgrading)。
    - 所使用的解压缩算法名为‘LZX Delta’，由微软开发。
4. **CF**：在这一阶段，系统会获取存储在NAND上的更新块，并使用LZX算法对它们进行解密和解压缩。 一旦这些更新准备就绪，它们就会被应用到位于主内存中的内核和管理程序。 完成所有更新后，CF阶段会返回到CD阶段。
5. **CD（返回后）**：此时，一切准备就绪，CPU会被引导至主内存中的**管理程序**。
6. **管理程序**：这个程序将接管硬件的控制权，然后将执行权交给**内核**。内核负责加载启动动画和**仪表板**。
7. 现在由用户控制。

### 可更新性

我想这对您来说并不新奇，但确实，这款游戏机拥有一套**可以更新的操作系统**。

然而，可能让您感到意外的是，无论游戏机的版本如何，它们都预装了2005年发布的相同初始内核（版本`2.0.1888`）[@anti_piracy-smc_hack。 实际上，软件更新程序会在NAND上安装以增量补丁形式的“更新包”，正如您在前一节所看到的，这些补丁在启动过程中被应用。

![2005年的Xbox旧界面正在安装更新（与旧的“Blade”界面告别！）。](screenshots/blades/update.jpg)

更新可以通过多种途径获取，包括Xbox Live在线下载、通过零售游戏、刻录传统CD（_这是我们在2010年代之前分享文件的常用方式_），或者使用U盘。 一个标准的更新会安装前面提到的管理程序和内核的补丁，并且会覆盖用户区域的文件，比如仪表板。 最后，为了防止系统回滚到旧版本，更新程序会通过编程电子熔丝来确保Xbox只能启动更新后的系统版本。

通常情况下，更新不需要额外的存储空间。 但是，在2008年微软发布“NXE”更新时，由于NAND存储空间不足，更新程序还在硬盘上安装了静态资源（主要是新3D头像的主题和资源）。 这促使微软在后续版本的主板上增加了NAND的容量，捆绑了高达512MB的NAND，后来更是包含了高达4GB的内置记忆卡。 这些增强功能只有在没有硬盘的型号上才能找到。

### 交互界面

现在，我想我们该从繁重的理论中暂时抽身，转而探讨一下这款游戏机所经历的不同图形界面。 尽管本文主要聚焦于计算机架构，但用户界面与我们之前讨论的那些复杂硬件同样关键。 另外，用户界面设计一直是我研究硬件时非常关注的一个方面！

在接下来的部分，你可能会觉得我对每个界面都有些许批评，但我觉得重要的是要准确指出每个设计的优点和不足，这样我们才能更好地理解它们演变过程中的逻辑和思路。

#### “Blade”仪表盘（2005）

::: {.subfigures .tabs-nested}

![主屏幕，控制按钮显示在中心，而水平边缘指示存在其他刀片页可供导航。](screenshots/blades/home.jpg){.active title="主页"}

![已安装游戏列表，之前从Xbox Live Arcade（一个数字市场）下载。 请注意，这是一个全屏视图，因为在前一种类型的屏幕上没有足够的空间。](screenshots/blades/games.jpg){title="游戏"}

![设置界面。](screenshots/blades/settings.jpg){title="设置"}

![存储菜单，允许用户删除或复制仅限用户的内容。 请注意，它移除了其他刀片页指示器，以回收利用更多的屏幕空间。](screenshots/blades/storage.jpg){title="存储"}

![一个简单的头像选择屏幕。](screenshots/blades/avatar.jpg){title="头像"}

![长时间按下控制器上的菜单按钮（也就是手柄上的Xbox标志），会打开一个名为“Xbox指南”的弹出菜单，其中提供了多种快捷方式。](screenshots/blades/guide.jpg){title="指南"}

“Blades”仪表盘。 画面来源于[@operating_system-blades_1]和[@operating_system-blades_2]。

:::

用户界面的第一个版本，现在对一些人来说充满了怀旧情怀，就是所谓的**Blades**仪表板。 在这个设计中，不同的服务组（如游戏、多媒体、设置等）被安排在不同的重叠层上，这些层被称为“刀片页(blades)”。 所有刀片页都处于相同的层级，用户一次只能打开一个刀片页/类别。 要浏览内容，用户需要在不同刀片页之间切换，并与放置在那里的控件互动。

在我看来，这种设计风格让我想起了那些设计吸引人的可折叠小册子（实际上，随游戏机附带的说明书就采用了类似设计）。 此外，其设计语言（包括排版、色彩调和模糊效果）与**Windows XP**及其**媒体中心**（Media Center）包有相似之处，甚至**Windows Longhorn**的早期版本也展现了这些共同特征。

![Windows Longhorn，Build 4015（2003）[@operating_system-longhorn]。 在最终发展成为Windows Vista之前，微软曾在用户界面设计和颜色方面进行过多项实验。 特别是这个版本，它在一些小细节上与Blades设计有相似之处。](screenshots/windows/longhorn4015.jpg) {.toleft}

![Windows XP媒体中心版（2005年）中包含的媒体中心。 这个Windows XP的特殊版本附带了一套专门针对电视而非个人电脑的应用程序。](screenshots/windows/mediacenter2005.jpg) {.toright}

实话实说，为了同时适应4:3和16:9的屏幕比例，整体设计做出了很大的妥协，无法充分利用16:9的优势。 元素布局也缺乏一致性，像Xbox指南这样的界面，所有控件都被压缩在很小的空间内。 在我看来，最大的限制是导航菜单（显示可用菜单的列表）始终占据屏幕两侧的空间， 这减少了打开菜单的有用面积。 因此，为了从主屏幕层级中脱离并恢复全屏显示，不得不采用特殊的导航设计，这进一步加剧了界面的一致性问题。

尽管如此，这个图形用户界面为这款游戏机赋予了独特的身份，显然它主要针对的是年轻玩家群体，这在几年内取得了_不错_的成效。

#### 新Xbox体验（2008）

::: {.subfigures .tabs-nested .individual-first}

![新的主菜单。 请注意，用户必须滚动才能查看所有可用元素。](screenshots/nxe/home.jpg){.active title="主页"}

![随着Xbox Live的功能扩展，现在可以安装多种类型的应用程序（不再仅限于“街机”游戏）。](screenshots/nxe/games.jpg){title="应用"}

![设置菜单保持了原有的布局，但采用了新的颜色方案。](screenshots/nxe/settings.jpg){title="设置"}

![存储菜单及其颜色方案已更新。 在这个例子中，用户设置了一个背景。](screenshots/nxe/storage.jpg){title="存储"}

![2D头像仍然可以使用，但现在也鼓励用户创建自己的3D形象。 这将用于游戏（类似于[任天堂的Mii](wii#personalised-titles)）。](screenshots/nxe/avatar.jpg){title="头像"}

![作为对旧设计的致敬，新的指南菜单与旧的Blades设计相似，这有助于提供更多且更有组织的快速入口。](screenshots/nxe/guide.jpg){title="指南"}

“NXE”仪表盘。 画面来自[@operating_system-nxe_dash]和[@operating_system-nxe_dash_2]。

:::

随着微软不断增加新的服务和功能，Blades的导航方式逐渐显现出其局限性（因为它限制了顶层导航界面的数量），并且在后续的软件更新中，空间不足的问题也日益突出。 为了应对这些挑战，2008年，微软推出了一个全新的仪表板界面——**新Xbox体验**（NXE）。这个界面采用了“无限滚动”的设计模式，使得用户可以在首页上看到更多的服务选项。 此外，它还引入了一些新的元素，比如最近在**Windows Vista**和一系列新的**Windows Live**应用程序中流行的光泽效果和3D动画效果。

![Windows Vista（2007）。 展示了如何使用标志性的“Flip 3D”功能在多个窗口之间进行切换。](screenshots/windows/vista_flip3d.jpg){.toleft width="90%"}

![2008年的Windows Live Mail[@operating_system-livemail]，采用了类似Windows Vista的主题风格，包括光泽效果。](screenshots/windows/livemail.jpg){.toright width="90%"}

通过新的设计，无论屏幕所在的操作层级如何，都可以充分利用全屏空间。 有趣的是，这种导航布局与索尼的[XMB](playstation-portable#visual-shell)设计非常相似，都是通过垂直箭头切换不同的类别，而水平箭头则用于在同一类别内导航不同的元素。

#### “Kinect”更新（2010）

::: {.subfigures .tabs-nested .individual-first}

![专为Kinect控制设计的新主页屏幕。 注意右下角的容器显示了Kinect当前正在捕捉的内容。](screenshots/kinect/home.jpg){.active title="主页"}

![随着Xbox Live功能的不断扩展，现在可以安装各种类型的应用程序，而不仅仅是游戏。](screenshots/kinect/apps.jpg){title="应用"}

![设置菜单进行了一些小改动。](screenshots/kinect/settings.jpg){title="设置"}

![存储菜单同样进行了更新。](screenshots/kinect/storage.jpg){title="存储"}

![3D头像功能也得到了增强。](screenshots/kinect/avatar.jpg){title="头像"}

![指南菜单的风格变得更加简约。](screenshots/kinect/guide.jpg){title="指南"}

带有自定义壁纸的“Kinect”仪表板。 画面来自[@operating_system-kinect_dash]

:::

随着**Kinect**的推出，微软需要对仪表板进行适配，以减少对传统控制器的依赖。 在这次更新中，设计团队将光泽效果替换为更为低调的绿色和灰色调。 此外，原先类似3D _Aero_的视觉效果也被更常见的放大动画所取代。 这一变化与**Windows 7**的发布及其对视觉效果简约化的处理风格相一致。

![Windows 7（2009）。 展示了新的“Aero Peek”功能，用于预览最小化的窗口。](screenshots/windows/seven.jpg) {.toleft}

![2011年的Windows Live Mail[@operating_system-livemaildesktop]，是名为“Windows Essentials”的桌面套件的一部分。](screenshots/windows/livemail_desktop.jpg) {.toright}

除此之外，值得一提的是，这个设计仅在一年后就被一个更为彻底的全新设计所取代。

#### “Metro”风格的全面革新（2011）

::: {.subfigures .tabs-nested .individual-first}

![新的主屏幕上，新闻、广告和应用占据了相等的空间。 一些信息类型（比如广告）所占的空间比用户期望的还要多。](screenshots/metro/home.jpg){.active title="主页"}

![新的应用选择器设计得就像零售店的货架一样。](screenshots/metro/apps.jpg){title="应用"}

![设置菜单基本保持不变。](screenshots/metro/settings.jpg){title="设置"}

![存储菜单也同样没有太大改动。](screenshots/metro/storage.jpg){title="存储"}

![看来这种极简主义的设计风格将会持续一段时间。](screenshots/metro/guide.jpg){title="指南"}

“Metro”仪表板。 画面来自[@operating_system-metro_dash]

:::

2010年，**Windows Phone 7**推出，一种名为**Metro**的新型界面首次亮相，这种界面的设计风格以纯色和白色剪影为主。 由于Metro设计的灵活性，微软计划将其应用到所有平台上，这一目标在接下来的年份随着**Windows 8**的发布和Xbox 360的**更新**而实现。 尽管不同设备对Metro的接纳程度存在显著差异，但Xbox 360却几乎完全采用了Metro风格（与Windows 8不同，后者的大部分应用程序仍然采用‘传统’设计）。

![Windows Phone 7（2010年）的宣传屏幕展示了新的主页屏幕、联系人应用（采用了新的“全景”布局）以及锁屏界面。](screenshots/windows/phone7_promotional.png){width="88%"}

其中最显著的变化是主页屏幕的设计，它从二维导航风格转变为一种名为“全景”的新型多行分布方式。 这种新的导航模式借鉴了旧Blades仪表板的类似设计，但避免了旧设计的错误。 现在，图标比文字标签更加突出，统一的形状使得整体布局显得更为简洁。 不过，至少这种布局在所有主页屏幕视图上保持了一致性（尽管我必须承认，我有点怀念以前那些充满变化和惊喜的设计时代）。

## 游戏

沿袭前文风格，本节将探讨游戏开发的各个方面，以及微软为完善这些环节所构建的配套基础设施。

### 开发生态

在开发环节，我们看到了一个持续了半个世纪的行业传统：游戏机制造商向游戏工作室提供尖端的开发工具包和库，而工作室则需要为此支付高昂的费用。 随着越来越多的小型公司投身游戏产业，一种新的**独立游戏开发者（Indy）**群体应运而生。他们虽然与大型游戏工作室拥有同样的热情和才华，但由于预算限制，他们必须在资源有限的情况下进行创作。

因此，微软针对不同类型的开发者推出了两种开发工具包[@cpu-andrews]：

- 传统游戏工作室在支付全额许可费后，可以获得官方的**Xbox开发工具包**（Xbox Development Kit，XDK）。 这个套装包含了完整的软件开发工具包（SDK）、多种开发硬件，以及根据他们与微软的关系，可能还包括原型设备。
- 而对于独立游戏开发者，微软提供了另一种选择：**Microsoft XNA**套装。它同样包含了多种开发硬件，但使用的是不同的软件开发工具包（XNA）。

为了进一步支持开发者，微软还推出了**游戏开发者网络**（Game Developer Network，GDN）和**XNA创作者俱乐部**，这两个在线平台为开发者提供了丰富的文档和工具资源。

#### 可用的工具和套件

使用价格较高的XDK的开发者会注意到，它在很大程度上继承了前代的[特性](xbox#tab-4-2-microsoft-xdk)。 提供的API主要基于DirectX的例程，这有助于那些已经在Windows平台上熟悉DirectX的PC开发者更快上手。 XDK实现了DirectX 9.0c版本（标识为“9_3”），并加入了Xbox特有的扩展功能。

这个开发套件包含了多种库和工具，例如：

- 它包含了现有的**Visual C和C++ 2005**前端编译器（微软的C和C++版本），以及一个新的后端，用于生成PowerPC机器代码。 此外，还包括PowerPC、xvs_3_0和xps_3_0汇编器（后两者是Xenos的微码着色语言[@graphics-ben]）。 前端编译器后来升级到了2010版。
- 微软的**Visual Studio 2005**作为集成开发环境（IDE）。 后来版本的XDK附带了2008版，最后是2010版。 还包括用于Xbox 360开发工具包的调试器。
- Xbox 360开发套件的**调试工具**。
- 知名的**Direct3D**图形API， 尽管它与Windows版本有所不同。 例如，着色器编译器现在在编译时生成微代码，而Windows版本则是在运行时完成这一过程（这是因为Windows游戏需要支持多种图形卡）。 API还进行了扩展，以支持程序化合成、条件渲染等多种情况。 这些变动已被Xenia模拟器的开发团队详细记录[@graphics-nopixel]。
- **Windows 2000时代的Win32 API**中的一些熟悉功能，现在被重新用于支持Xbox 360的内核操作，例如多线程操作的`CreateThread()`标准程序。
- 一些旧有的、即将被更新的API，比如**DirectSound**，在XDK的后续版本中很快被**XAudio2**所取代。 XAudio2的开发旨在充分利用Xbox 360的独特音频处理能力，并与Windows的DirectX API保持语法一致性。
- 此外，还有非DirectX的API，如用于控制Kinect的**自然用户界面**，它提供了与Kinect设备的交互方式；以及**Xbox 360统一存储**API，它旨在提供一个抽象层，以简化对多种存储介质的访问和管理。

现在轮到使用XNA的低预算工作室了。 XNA被设计用于简化**跨平台开发**，其适用于Windows XP和Xbox 360 [@games-carter]。 XNA作为**DirectX的封装器**，因此低级功能被抽象为在Windows和Xbox 360上都能运行的例程。 尽管仍然需要额外的代码来适应这两个不平等平台之间的小差异 [@games-considerations]，但该平台使许多开发者受益，他们希望在不付出太多努力或成本的情况下将他们的游戏移植到Xbox 360。 对于熟悉Windows开发生态系统的人来说，XNA是旧的“Managed DirectX”平台的继任者，它包含了**.NET Compact Framework**的一个子集 [@games-compact]。

在随后的几年里，将看到XNA框架的新版本支持新设备（如Windows Phone 7），但它逐渐与现在已过时的Xbox 360硬件疏远，直到微软在2013年完全放弃了XNA [@games-xna_out]。

作为最后的说明，对于家庭开发者来说，**libXenon**是一个免费的第三方库，它提供了对硬件的低级访问，且不受版权限制 [@games-libxenon]，尽管它的可执行文件只能在禁用了签名验证的被破解的Xbox 360上运行。

### 存储介质

现在让我们来看看内容分发是如何工作的。

#### 零售游戏 {.tabs.active}

![零售游戏的例子](photos/game.jpg) {.tab-float}

这可能听起来难以置信，但对于微软来说，用于初代Xbox的同一种**双层DVD光盘**在他们的新游戏机上也能正常工作。 我推测这是一种成本效益策略，因为DVD光盘的生产成本变得更低，而且其读取器可以外包给最便宜、最方便的制造商。 在整个游戏机的生命周期中，微软依赖日立、LG、东芝、三星、飞利浦、明基和Lite-ON等公司，包括两个团队，来生产他们的DVD驱动器。

作为提醒，双层DVD（也称为**DVD-9**）的理论容量为**8.5 GB**。 与PlayStation 3的新[_蓝光光盘_](playstation-3#tab-8-1-blu-ray-discs)相比，这是一个大优势，因为Xbox 360得益于其**12倍速光驱**，能享受更快的读取速度，这也是将硬盘从要求中排除的另一个原因。

另一方面，游戏的可用容量受到了很大的限制，那8.5 GB的容量由于一个名为**Xbox游戏光盘2**或“XGD2”的安全文件系统而进一步受限。 这是微软用来防止未经授权复制的[原始格式](xbox#medium)的继任者。 游戏实际可用的容量减少到了**6.8 GB**（总容量的80%）[@games-leadbetter]。 2011年，在许多第三方工具成功破解保护后，**Xbox游戏光盘3**或“XGD3”被提供给开发者。 在其中，微软设法更新了安全技巧，并减少了用于反盗版机制的空间，为游戏留下了总共**7.9 GB**的容量。

#### 在线商店 {.tab}

![商店列表的例子](screenshots/metro/store.jpg) {.tab-float}

微软开始尝试的一个新兴领域，直到它成为零售商店的全面竞争对手，就是**在线市场**。

最初它名为**Xbox Live Marketplace**，这个门户在2006年作为初代仪表板中的一个新刀片页/类别“市场”推出[@games-moore_demo]。 用户然后会发现一部分零售游戏可供购买，以及免费的演示版可供尝试。 在随后的几个月里，一次更新增加了一个名为“Arcade”的新组，其中包括在线商店独有的游戏，这些通常是小游戏。 随着时间的推移，更多的更新将会到来，以扩大Xbox Live Marketplace的领域，现在它还销售电视节目、电影和原创Xbox游戏[@games-update_walk]。

此外，在另一次更新中，微软推广了一个专门为独立开发者设立的部分，这被称为“Xbox Live社区游戏”[@games-creators]，并将使用XNA平台的开发者与已经拥有零售空间的大型工作室区分开来。

在Xbox 360的的最后几年，以及其他媒体平台（智能手机、智能电视、Xbox One和在线流媒体）的巩固期间，微软重新品牌化了市场的一部分，以提供可以从其他设备（不一定是Xbox 360）使用的内容。

#### 蓝光竞争者 {.tab}

![HD DVD播放器，发布于2006年11月](amos/hd_dvd.png) {.tab-float.no-borders}

与游戏本身关系不大，但电影行业对这个游戏机也有着不同寻常的影响（或者反过来说？ _我们很快就会看到_）。 当微软强制游戏使用DVD格式时，该公司也在推动一种新的格式，以争夺电影货架上的空间与蓝光光盘竞争。 我说的是**HD-DVD**，它恰好足够方便地使用了微软拥有的API来实现互动功能（如菜单等）。

因此，微软的目标导致了被称为Xbox 360 HD DVD播放器的一个独立配件的诞生，这是一个外置读取器，放置在游戏机旁边，并且需要自己的电源供应（所以可以预期所有随之而来的麻烦）。 无论如何，这个读取器通过USB连接，并附带一个“HD DVD安装光盘”，在游戏机上安装了一个额外的媒体播放器。 然而，它的行为取决于仪表板版本：在Blades仪表板上，HD-DVD播放器与用户界面集成在一起[@games-hddvd_install_old]。 在较新的仪表板上，它作为一个单独的应用程序出现[@games-hddvd_install_new]。

在内部，HD DVD以比传统DVD更高的密度存储凹坑和平地，如果是一层的话可以存储多达**15 GB**的数据，如果是双层的话则可以存储**30 GB**的数据。 虽然蓝光和HD-DVD都依赖于[蓝光二极管](playstation-3#tab-8-1-blu-ray-discs)，但后者的坑分布更为稀疏；其激光的焦点比蓝光的要大[@games-hwu]。 因此，HD-DVD无法达到竞争对手的25 GB/50 GB的里程碑。

在货架上卖了两年之后，HD-DVD及其播放器在2008年被逐步淘汰[@games-chen]。 如果你问我，那我会说HD-DVD和蓝光之间的这种二元对立只是版权费、制造成本和分销商之间的分歧之战。 这些对终端用户来说都不重要，然而他们不得不为这种实验性技术支付高昂的价格，而这种技术很快就会被分销商认为“不值得”

### 网络服务 {.tabs-close}

在这个低成本游戏机的核心，是其大力推广的在线功能，这些功能以一种名为**Xbox Live**的付费订阅服务的形式实现（这个名字还包括市场、软件更新和其他基于互联网的服务）。

由于Xbox Live在初代Xbox上的使用取得了成功，其继任者也不会陌生于跟随脚步，甚至提供更多的商品来吸引用户加入在线游戏。 我推测这个游戏机的低成本点和持续的市场营销努力——包括微软发货的所有配件（网络摄像头、耳机等）——意味着微软的主要利润来源依赖于付费订阅和市场购买。 随着3D头像的出现，公司也找到了利用头像定制化盈利的方法[@games-leggett]。

![有趣的是，游戏机为用户的Xbox Live个人资料计算了一个分数，这个分数基于解锁的成就的数量和类型。 想要达到顶级排名吗？ 那就多玩一些。 游戏玩完了？ 那就买更多！](screenshots/metro/achievements.jpg)

从开发者的角度来看，Xbox Live服务器提供了进行多人游戏、语音聊天、个人资料管理等功能所需的基础设施。 Xbox 360游戏使用**REST API**（在SDK上有文档记录）与每个端点进行通信。 为了与这些服务器进行身份验证，开发者接收了一个定制的“Xbox安全令牌服务”，将其嵌入到他们的REST请求中。

## 反盗版和自制游戏

随着文章接近尾声，我还没有详细说明这个系统是如何被_荒谬地_保护的。 这台游戏机有着令人难以置信的漫长和多元的历史[@anti_piracy-scene_history]，涉及有趣的发现、意想不到的漏洞利用方法以及激烈的报复形式。 最重要的是，这段传奇导致了大量第三方文档的诞生，详细介绍了游戏机硬件的构造和软件的奇特之处。 因此，可以说，如果没有许多黑客团体投入无数小时进行研究并将他们的发现记录下来，这篇文章的一半内容都不可能存在——这项任务并不一定是为了促进盗版。

### 主要目标

首先，我要介绍两个主要的目标。 首先，我要介绍两个主要的目标。一旦Xbox 360到达商店，微软发现自己要防守两个大战线：

- **管理程序**，它控制着CPU并强制执行签名可执行文件，如果想要实现自制软件（Homebrew）或者启动另一个操作系统（例如 Linux）的话，这两个方面都必须被攻克。
  - 由此延伸，这也影响用户数据（即存储在硬盘和/或内存单元上的个人资料），但它们实现了额外的安全层。 这些在这里没有提到，以便我们可以专注于主要目标。
- **DVD光驱**，它执行复制保护系统并防止刻录的光盘被作为游戏执行。 DVD价格低廉，那个时代的大多数PC都配备了DVD RW驱动器，因此破解看起来非常有吸引力。 然而，这只会导致盗版，而不会促进自制软件（因为代码仍然是签名的）。 也就是说，除非有人发现了一个依赖于DVD光驱的漏洞，一旦“触发”，就能执行自制软件……我们拭目以待！
  - 有趣的是，管理程序和操作系统的其余部分对复制保护的状态没有意识[@cpu-steil]，这部分任务被委派给了光盘驱动器，它在接受插入的光盘作为有效的Xbox 360游戏方面拥有决定权。

### 管理程序战线

我们现在将了解管理程序是如何被保护的，以及它如何保护系统的其余部分。

#### 一个隐藏的加密系统

还记得Xenon中的L2子系统有多复杂吗？ 嗯，还有一件事需要解释，那就是在其中包含了一个**隐藏的加密块**。 我之所以称它为“隐藏”，是因为微软和IBM都没有对其进行过任何文档记录。 我是通过一个由Free60小组（由Michael Steil和Felix Domke领导，前者还做过‘The ultimate Game Boy talk’！）名为“Xbox 360安全系统及其弱点”的极具洞察力的演讲 [@cpu-steil]以及Mathieu Renard的“安全攻击与防御策略”[@operating_system-renard]了解到它的，我在这里描述的大部分信息都依赖于这两次演讲。

![Xenon内部安全组件概览。 它们被策略性地放置，使得PPE不需要知道它们的存在，也不需要进行任何手动操作。](_diagrams/cpu/crypto.webp)

接下来，加密子系统被划分为执行独特功能的独立区域：

##### 随机数单元 {.tabs.active}

**随机数生成器单元**（或简称“rand”）产生不暴露可预测模式的随机数集，至少它试图这样做。 这对于向加密例程提供额外的参数非常有用，使得它们难以被追踪，从而防止逆向工程或复制。

你可能会问“为什么不能通过软件来完成这件事？”好吧，在传统计算世界中，没有所谓的“纯随机性”。 计算机只能使用可能被追踪的参数生成伪随机数。 因此，拥有一个专用的单元来执行这项任务可以进一步混淆其逆向工程，并保护CPU免受可能的窥探（因为这块单元隐藏在CPU内部，而不是散布在主板上）。

我猜最理想的解决方案可能是将CPU连接到量子计算机，但我们的科技还没有到达那一步！ （_尽管有些接近了_）

##### 存储扩展 {.tab}

此外，这个子系统还提供了两个额外的内存块。

首先，有**32KB的ROM**，它与Cell中的[安全ROM](playstation-3#tab-7-1-cell-bootrom)相同。 它用于存储CPU可以读取的未加密数据，而不用担心被第三方暴露或追踪。 正如你之前所看到的，这是第一阶段引导所在的位置。

其次，提供了**64KB的SRAM**作为快速通用内存，CPU可以使用它来执行合理的操作（很可能是与加密相关的），而不用担心被_监视_。

##### 电子熔丝 {.tab}

说到存储，Xenon内部还有一种特殊的介质叫做“电子熔丝”（eFuse）。 电子熔丝是微小的开关，CPU可以将其读取为`0`或`1`，就像任何晶体管一样。 eFuses的独特之处在于，一旦它们被切换到`1`，它们的状态就是**不可更改的**（因为写入`1`会**烧断**电子熔丝，就像传统的保险丝一样）。 这使微软能够编码永久计数器或存储加密密钥，一旦游戏机离开工厂，这些计数器或密钥就无法更改。 好吧，只有`0`值可能会被更改，但每个游戏机的序列是不同的。 此外，一旦密钥被第三方更改，游戏机就无法再解密其数据了！

总共有**768个单独的电子熔丝**被安装，每个都被CPU视为一个“位”，其中`0`表示“激活”，`1`表示“烧断”。 这个块被分组为12个“熔丝组”，每个组包含64个电子熔丝。

当读取或写入电子熔丝时，它们是以**8个电子熔丝**为一组进行的（类似于8位/十六进制值），而不是单独进行的。 尽管如此，有时信息只以二进制值（`0`和`1`）的形式编码，而不是十六进制格式（从`0x0`到`0xF`）。 在这些情况下，整个8位字会一次性烧断，并被视为一个单一的二进制值。

##### 加解密单元 {.tab}

在L2缓存旁边，微软和IBM增加了一些**硬连线逻辑**，以便在完全不依赖CPU的情况下执行**AES-128**加密和散列函数。 利用之前提到的64 KB SRAM，L2块在数据进入或离开Xenon时自动进行解密或加密。

L2块还可以在内存页被写入主RAM的过程中对其进行散列，将散列值存储在SRAM上，然后在从RAM中检索页面时将其与新计算的散列值进行比较。 如果检查失败，系统将锁定[@cpu-steil]。

所有这些操作都是为了防止对内存总线进行任何有意义的数据分析（通过加密）并确保RAM没有被篡改（通过散列）。

为了防止重放攻击（这种攻击依赖于复制旧但有效的数据块来伪造真实性），随机数单元每次游戏机启动时都会生成一个不可预测的值。 然后，L2块将其与加密逻辑混合[@anti_piracy-gligli]。

#### 安全系统实现 {.tabs-close}

让我们看看微软是如何构思这些组件的用途的。

##### 信任链 {.tabs.active}

您之前阅读的复杂启动过程是为了实现一个精密的**信任链**而设计的。 这确保了一旦管理程序准备好执行用户空间代码，后者总是被加密并由微软以外的人签名。

为了有效地混淆启动过程，该系统采用了多种类型的密码。 例如，第二个引导加载程序（2BL/CB）使用**RC4**（一种快速算法）进行解密，其解密密钥在运行时使用**HMAC-SHA**构建。 然后，使用**SHA1**和**ROT**对解密后的代码进行哈希处理。 最后，为了检查2BL是否被篡改，计算出的哈希值会与使用微软私钥（使用**RSA**）预先签名的存储哈希值进行比较。

为了提高保护级别，每台游戏机都嵌入了一个独特的**CPU密钥**，在游戏机离开工厂前刚刚印在电子熔丝上。 在运行时，CPU密钥与其他参数混合，以生成引导加载程序密钥的一部分。 总的来说，这意味着破解一个CPU密钥不会影响其他游戏机。

一旦管理程序加载到主内存中，信任链就位，没有管理程序的许可，就不会执行任何代码，尤其是后者具有**W^X**能力。

##### 不可逆且唯一的数字  {.tab}

为了进一步保护信任链并防止外部篡改，启动阶段还会查询**768个电子熔丝集群**以获取以下信息[@anti_piracy-fusesets]：

- 前面提到的**CPU密钥**，用于加密存储在游戏机中的其他密钥。
- 一个标志，表明游戏机是**零售模型还是开发套件**，这会影响主板上的许多调试引脚的可用性（即  JTAG口).
- **两个更新计数器**（一个用于2BL/CB的更新，另一个用于管理程序和内核的更新）。 每当微软发布一个“系统更新”并且用户安装它时，更新程序会熔断一个电子熔丝。 在启动过程中，CPU将电子熔丝的值与应用的补丁进行比较，如果值不匹配，您会得到著名的“死亡红灯”。 这阻止了用户降级到系统的漏洞可用版本。
  - 为更新计数器预留了5个熔丝组。 计数器以二进制形式编码，因此每次更新后都会熔断八个熔丝，这意味着Xbox 360在其生命周期内可以承受多达**80次更新**。 相反，微软在`2.0.4548.0`更新发布后才开始熔断电子熔丝。
  - 此外，还有**16个电子熔丝**可用于CB的更新。

##### 安全通信 {.tab}

Xenon拥有一个64位的地址总线，然而，只有512MB的RAM（以及一部分I/O）需要被寻址，这意味着使用64位寻址可能会显得有些[浪费](gamecube#a-step-forward-or-a-step-backwards)。 因此，一半的地址空间被用于一个更实用的目的：**加密标志**。

本质上，程序只使用**32位的虚拟地址**。 然后，内存管理单元（MMU）使用一个页表将虚拟地址转换为64位地址，其中低32位编码虚拟地址，上半部分存储标志，这些标志表示所选内存地址是否（或需要）被加密和/或散列。

这些标志由L2缓存块自动读取，然后根据需要执行加密/散列操作。

由于只有**64KB的SRAM**用于存储页表和哈希值，所以所有主RAM都可以被加密，但**只有管理程序被散列**。 这意味着CPU与RAM之间的通信始终受到保护，但L2缓存块只能验证虚拟机监控器的完整性。 这似乎是一个不错的折中方案，对吧？……我们来看看结果如何！

#### 管理程序的职责  {.tabs-close}

一旦管理程序以1级权限完全运行，它将深入Xenon的内部SRAM以提供以下功能：

- 充当**内存管理单元**（MMU），通过处理其私有的虚拟内存页表，其中它跟踪每个程序的内存边界以及它们是否可执行。 这可以保护硬件不受产生缓冲区溢出的[充满漏洞的软件](xbox#tab-5-3-permanent-unlock)的影响。
- 与L2块合作，确保所有可执行代码在存储到RAM时都是加密的。

为了执行任何用户空间应用程序，内核将（未加密的）代码复制到内存中，然后管理程序检查它是否使用微软的私钥RSA签名[@cpu-steil]。 如果签名有效，管理程序继续在内存中复制可执行代码，在此过程中L2块会自动对其进行加密。 最后，管理程序将相应的内存页标记为“可执行”，其余的就成为历史。

### 保护DVD光驱

由于选择了高度流行且价格合理的游戏分发介质，关于盗版的担忧在微软总部引起了共鸣。 反盗版系统成为了微软及其供应商的联合项目，其效果因DVD光驱的制造商而异。

#### 第一方安全措施 {.tabs.active}

在微软的控制下，DVD光驱使用唯一的**DVD密钥**与系统进行认证，该密钥必须与虚拟化管理器处理的内部密钥相匹配。 DVD密钥来源于CPU密钥[@anti_piracy-hacking_2]。 如果检查失败，光驱仍然可以工作，但将无法启动Xbox 360的游戏。

此外，为了防止被传统DVD光驱读取并排除精确复制，游戏使用了新的**Xbox游戏光盘2** (XGD2) 数据格式进行制作，该格式刻录了一些反盗版技巧[@anti_piracy-dvd]：

- 一个**误导性的目录表**，欺骗传统DVD光驱加载一个静态视频，这个视频会要求用户将光盘插入Xbox 360游戏机。 <!-- - Game data is embedded in the **meta-data area** of the DVD. TODO: Recover/Confirm the source for this. -->
- 在文件系统内，存储了一个数据库，其中包含多个称为**挑战**或“安全扇区”的检查，驱动程序执行这些检查以确认当前光盘是有效的。 当提到DVD光驱时，这些挑战就只是列举在制作过程中故意制作的故障扇区，驱动器需要找到这些扇区。 由于传统刻录机没有考虑到这些扇区，因此复制品永远不会通过验证过程。
- 光盘的外部区域暴露了一个[冲切区](xbox#dvd-copy-protection)，尽管它似乎并不包含用于复制保护的有意义数据。

最后，还要加上这样一个事实，即管理程序只启动用微软私钥签名的可执行文件。

#### 第二方安全措施 {.tab}

实际上，负责实施微软复制保护协议的实体不是微软，而是DVD光驱的制造商。 在大多数情况下，制造商只是改变了他们现成硬件的固件，以遵守微软的要求。 无论如何，管理程序在检测哪个光盘是正品，哪个不是时，会盲目地信任光驱。

由于复制保护子系统随后被委托给第三方，因此它出现了多个问题。 例如，光驱仍然使用标准的ATA命令进行通信[@anti_piracy-hacking_2]，因此它们必须找到方法来混淆敏感数据交换。 此外，光驱必须准备好覆盖其固件，以防微软修订新的复制保护机制。 所有这些，同时防止未经授权的各方访问此功能。

虽然探讨每个制造商的每个安全措施超出了本文的范围，但重要的是要指出，在最终出现的猫捉老鼠游戏中，微软对这些保护措施以及随后的补丁控制力有限[@cpu-steil]，这一明显的漏洞使得公司早期遭遇了盗版分发的浪潮。

### 后备技术 {.tabs-close}

现在很明显，反盗版措施只能保护一段时间。 Xbox 360被设计成一个大部分可覆盖的操作系统。 只要使用了正确的加密密钥（微软是唯一的拥有者），除了启动ROM之外的任何东西都可以更新。

因此，在整个游戏机的生命周期中，公司发布了软件更新，修补了CB（第二阶段引导加载程序）、内核、管理程序和DVD光驱的固件。 你很快就会看到这些区域的每一个背后的逻辑。

此外，微软通过只允许运行最新系统的游戏机访问Xbox Live，来推广（或者实际上是强制）这些更新。 这阻止了用户保留旧版本，结合了防止降级的电子熔丝，减少了有漏洞的游戏机的可用性，哪怕是为了研究目的。

最后，在修改过的游戏机访问Xbox Live服务的情况下，微软在幕后实施了多种保护措施，以将破解的游戏机和/或作弊者排除在其网络之外，包括使用“电话回家”程序来帮助微软检测“特殊”游戏机；随后通过游戏机黑名单实施“永久封禁”。

### 击败

如果你多年来一直关注Xbox 360的场景，你现在可能知道这款游戏机享受了其时代最具创造性的漏洞利用之一。 最初开始的简单任意执行技术（尽管它们并不特别_简单_），很快就有了为了这些目的而销售的商业硬件。

我将尝试现在给出一个适当的事件摘要，但如果你在最后感到还想要更多，知名黑客“15432”撰写了一个非常信息丰富的三部分文章，深入探讨了直到2020年的每一个突破\[@anti_piracy-hacking_1\] \[@anti_piracy-hacking_2\] [@anti_piracy-hacking_3]。

#### DVD光驱传奇

历史似乎告诉我们，每当一款游戏机包含了像CD或DVD这样的广泛采用的介质时，那个区域被破解只是时间问题。 尤其是由于盗版比自制软件更容易传播。

在2006年5月（PlayStation 3上市之前），用户“commodore4eva”发布了**Xtreme Firmware**，这是一款用于早期捆绑了东芝-三星驱动器的Xbox 360的替代DVD光驱固件[@anti_piracy-xtreme]。 新固件指示驱动器寻找硬编码的安全区块，而盗版副本则会重新定位这些区块。

固件是通过使用ATA命令来烧录的，但它需要一个带有备用SATA插槽的计算机和特殊的烧录软件。 因此，用户需要打开游戏机并将SATA数据线连接到他们的计算机上，在游戏机为光驱供电时运行烧录器，然后重新组装一切。 烧录操作源于光驱固件中发现的隐藏的“维护模式”，这个模式随后被逆向工程并重新启用。 如果过程成功完成，Xbox 360现在就可以像读取任何正版游戏一样读取盗版游戏。

![在YouTube上找到的DVD光驱烧录教程示例 @anti_piracy-flashing_tut。 在这里，Xbox 360的光驱通过SATA连接到电脑，同时游戏机仍然提供电源（因为电源连接器是专有的）。](photos/flashing.jpg)

这就是DVD光驱被破解的大致过程。 随着时间的推移，技术不断进化，但基本思想保持不变（烧录自定义固件）。 后续的光驱增加了安全性以封堵后门，微软通过将DVD光驱固件捆绑在其软件更新中来帮助撤销用户所做的任何未经授权的工作。 在后来的年份里，光驱的级别提升到了用户必须钻透驱动器的系统芯片才能启用刷新的程度[@anti_piracy-hacking_2]。

微软总部设计了一种名为**XGD3**的新光盘格式，以改善挑战集合。 此外，XGD3通过扩展写入限制超过标准区域（在这个过程中阻碍了复制）来增加了数据容量[@anti_piracy-xgd3]。

#### 管理程序传奇

管理程序的基本原理一开始可能看起来无懈可击，然而，它下面隐藏着一个技术上的妥协：外部组件（南桥、GPU等）也需要访问主内存。 然而，它们不理解管理程序的加密机制（因为这是CPU和主内存之间的事情）。 那么，I/O如何使用内存呢？ 简单，通过**直接访问**（[DMA](playstation#taking-over-the-cpu)）和**非加密数据**。 这本身并不是一个安全漏洞，因为管理程序仍然对其可执行的CPU页面执行安全措施。

![XeLL-Reloaded，一个Linux和自制软件的启动器。 将这个程序加载到Xbox 360将成为任何修改者的首要目标。](screenshots/homebrew/xell.jpg)

尽管如此，早期的入侵就是专注于这一点。 换句话说，我们能否将未签名的代码注入主内存，然后诱使管理程序执行它？ 嗯，在2007年2月，一位匿名黑客发布了一个依赖于2005年游戏《**金刚**》的**权限提升**漏洞利用[@anti_piracy-hv_vul]。 在报告中，概述了一个聪明的事件链，以在管理程序级别（意味着完全硬件访问）获得任意代码执行。 这个过程并不容易解释，但我会尽力。让我们看看…… 让我们来看看……

##### 比较缺陷 {.tabs.active}

为了组织所有可用的例程，管理程序在主内存中存储了一个**系统调用表**[@cpu-steil]，以及一个遍历该表的句柄。

当一个程序调用系统调用时，句柄首先确保请求的系统调用号码是有效的。 这是通过检查其值是否小于`0x61`（意味着最多有96个系统调用可用）来完成的。 最后，句柄将系统调用号码转换为内存中的**虚拟地址**（在那里找到例程），然后CPU继续在那里执行。

另一个需要记住的概念是，管理程序以**加密**形式存储在RAM中，因此，所有系统调用例程也都是加密的。 因此，指向例程的虚拟地址具有设置的加密标志。 因此，L2块在将数据交给CPU之前，无缝地解密从RAM中获取的数据。

考虑到这一点，黑客们查看了系统调用句柄的汇编代码，并发现了一个重大缺陷。 本质上，系统调用号码是通过寄存器传递的。 Xenon中的寄存器是64位长的，但有效性检查是使用`cmplwi`指令实现的（用于无符号的32位值）。 这意味着如果一个程序（之前由管理程序授权）请求一个系统调用，其值大于`0xFFFFFFFF`，比如`0x20000000.0000002A`，管理程序将只验证`0x0000002A`，这将通过检查。

那么，我要表达的是什么意思呢？ 嗯，如果你记得，64位虚拟地址上的高32位用作标志，指示L2块加密/解密或散列内存值，如果标志都是零，L2将解释数据为**未加密**并直接传递。 也就是说，如果_通过某种外部手段_在RAM中插入了一块未加密的代码，可能会有一种方法通过有缺陷的系统调用句柄来执行它……

##### 新的系统调用 {.tab}

之前的发现看起来很有希望，但仍然有许多未解决的问题。 例如，我们仍然需要一种方法来构建一个不会被L2的解密块破坏的任意系统调用。

长话短说，发现了一个关键点：当系统调用句柄将系统调用号码转换为虚拟地址时，如果结果虚拟地址的最高位不是`0`，那么转换器就**不会添加加密标志**。 因此，L2块不会破坏获取的系统调用函数，无论它是否加密。

这是缺失的拼图，它将允许黑客执行一个精心构建且未加密的系统调用号码，从而导致任意代码执行。 但这还没有结束，因为我们还需要：

- 一个入口点，允许将任意系统调用例程注入主内存。
- 另一个入口点，用于请求构建的系统调用号码，以便执行任意例程。

这就是我们现在将要讨论的内容。

##### 《金刚》漏洞 {.tab}

接下来是著名的《金刚》游戏。 像任何其他典型游戏一样，它的光盘存储了顶点和像素着色器文件，这些文件在游戏过程中某个时刻被加载。 然而，出于某种未知的原因，这些文件以**完全明文（未加密）和未受保护的形式存在**。

如果你将这个事实与DVD光驱可以被修改以加载复制品的事实结合起来，你现在可以使其加载带有修改后着色器的《金刚》游戏。 这有什么价值呢？ 嗯，你还记得我在“图形”部分提到的“内存导出”功能吗？ 着色器可以通过DMA直接写入主内存！ _哦吼！_

我猜你已经知道我要说什么了，如果你制作了一个带有自定义着色器的《金刚》特殊副本，并将其插入一个烧录过光驱的Xbox 360中，你可以开始用任意值填充主内存。 因此，你可以将自定义系统调用注入主内存。

这解决了填充主内存的第一个任务，但我们仍然需要一种方法来调用自定义系统调用……

##### 提权 {.tab}

回忆一下，Xbox 360的内核提供了一个调度器来处理多线程。 这个机制负责将虚拟线程分派到CPU核心，并将空闲线程保存到内存中以备后用。 嗯，出于另一个未解释的原因，调度器将线程状态以**未加密**的数据形式存储在RAM中！

结合所有已解释的内容，现在可以制作一个着色器，该着色器会篡改内存中的空闲线程，一旦该线程被恢复，它将继续以自定义参数执行。 这个过程会持续进行，直到所有的参数最终都处于黑客的控制之下[@anti_piracy-smc_hack]，这样执行就可以被重定向到系统调用处理程序，并结合使用计算出的参数，最终跳转到精心制作（且未加密）的系统调用。

基本上，这就是管理程序如何被任意代码劫持的方式。 与此过程捆绑在一起的常见有效载荷包括一个**Linux启动器**，因为使用具有完全硬件权限的Linux允许用户从他们的游戏机中提取敏感信息，如CPU密钥（这在未来可能会有用，你很快就会看到）。

### 保护金刚  {.tabs-close}

金刚漏洞利用对于自制软件场景来说是一大步。 我不确定你有没有注意到，但在这个过程中根本不需要任何加密密钥（_所以，原本强大的安全系统又如何呢……_）。

尽管如此，**微软已经注意到了这个漏洞**，并在2007年1月（报告发布前一个月）进行了修复。 尽管如此，黑客们继续寻找类似漏洞，以用于更新后的游戏机。 此外，黑客现在可以获得一个过时的游戏机，并利用金刚漏洞来扩展他们的研究。

因此，在金刚事件发生的同年（2007年），又有新的发现：

#### 隐藏维护模式 {.tabs.active}

一旦CB，也就是第二阶段引导加载程序被逆向工程，一个新的后门就要被发现了。 CB执行的一个检查是将存储在CB头部的一个字符串与NAND中的校验和进行比较。 嗯，如果那个字符串（称为“配对信息”）全是零，那么这个检查就会被跳过，启动过程会继续，同时**忽略CPU密钥**。 唯一的缺点是没有应用更新包，而内核最终启动的是一个名为`MfgBootLauncher`的替代应用程序（推测在制造过程中使用），而不是仪表板。

最初，这个发现并没有引起人们的注意，因为它似乎并没有导致任何有趣的发展。 然而，这种情况在微软注意到`MfgBootLauncher`的提及并随后发布了一个新的系统更新后发生了变化，这个更新最终吸引了_太多的注意力_，甚至到了这种特殊的“制造模式”成为家庭自制软件的一个机会！

在我们继续这个故事之前，还需要解释一个黑客攻击…

#### 时序攻击 {.tab}

![由于制造原因，主板暴露了许多执行（未记录的）功能的针脚，其中一些功能被逆向工程，以利于黑客操作。](photos/headers.jpg) {.tab-float}

在2007年8月，XboxHacker用户“Arnezami"发布了用于将任何游戏机降级到易受King Kong攻击的固件版本的**时序攻击**方法[@anti_piracy-timing]。

这次攻击（_双关语_）要求用户提取NAND的内容（也就是制作一个转储），并使用一个自动化脚本，将转储中的游戏机唯一信息与系统`2.0.1888`的通用镜像（操作系统的第一个修订版）合并。

为了绕过第二阶段引导加载程序检查（它会将电子熔丝中的更新计数器与已安装的更新进行比较），定制的固件需要与eFuses计数器的值相匹配。 然而，调整这个计数器并不简单，因为NAND中的计数器是使用CPU密钥（带有HMAC）签名的，如果Xbox 360运行的是打了补丁的固件，那么CPU密钥是无法提取的……

幸运的是，出于制造目的，主板暴露了**串行外围接口**（SPI）引脚，用于写入和读取NAND；以及输出不同值代表启动过程当前状态的POST引脚。 恰好在这个过程中，电子熔丝验证（使用C语言的`memcmp()`实现）时，比较是按字节进行的。 最重要的是，在每次比较过程中，成功的匹配总是需要**0.22毫秒**来完成，而失败的匹配则需要**0.21毫秒**[@operating_system-renard]。

结合所有这些信息，可以自动化一个试错猜测器，直到整个签名被暴力破解。 这就是时序攻击的实质。 一旦提取了秘密代码，它可以应用于修改后的`2.0.1888`镜像，一旦这个镜像被刷入游戏机的NAND，游戏机就会认为它是有效的。 从那时起，用户可以更新到一个易受King Kong攻击的版本。

最终，微软在2008年初通过一个新的软件更新修复了这个漏洞，该更新略微改变了CB中的`memcmp()`函数。

#### 对CB的更多研究 {.tab}

![一旦你成功启动了Linux（在这种情况下是Gentoo，得益于Free60小组的努力），你就可以窥视Xbox内存中的特权区域，比如电子熔丝（那里存有CPU密钥）。 截图由[@anti_piracy-gentoo_pic]提供。](screenshots/homebrew/gentoo.jpg) {.tab-float}

有一天，微软发布了一个新的CB更新（版本1920），旨在解决当时无害的制造模式的发现。

为了混淆视听，微软决定将CPU密钥作为一个参数添加到用于加密/解密4BL（负责加载和更新内核和管理程序的阶段）的过程中，使得逆向工程变得不可能。 然而，得益于时序攻击，CPU密钥最终可以被提取。 因此，黑客能够解密4BL并继续在其中寻找新的漏洞。 幸运的是，他们在“制造模式”中发现了一个重大变化：如果更新数据包的配对信息也被清零，那么更新程序将应用它们。

所有这些都导致了一个非常重要的里程碑：现在可以在不知道CPU密钥的情况下**启动任意版本的系统**。 然而，这一点直到很久以后才被利用，这就把我们带到了下一个故事……

### 还以金刚自由 {.tabs-close}

随着自制软件开发不断进步，《金刚》破解法变得过于繁琐，人们的注意力转向寻找新的技术来自动化利用管理程序，结果至少可以说是惊人的。

#### 一个可疑的更新 {.tabs.active}

在《金刚》漏洞公布两年后，即2009年8月，微软发布了一个意外的软件更新`2.0.8498`，该更新再次覆盖了CB（第二阶段引导加载程序）并增加了相应的电子熔丝计数器[@anti_piracy-dangerous]。 不仅这次更新出人意料地覆盖了系统的关键部分（有可能导致系统不可修复的损坏），也引起了众多黑客的关注，他们想要弄清楚微软试图修复的是什么。

Free60小组在持续努力将Linux移植到Xbox 360的过程中，建议用户保持当前系统不变，不要屈服于这次更新。 在幕后，他们已经知道了这个隐含的漏洞，并正在准备发布一项新技术，供公众利用。

#### JTAG/SMC破解 {.tab}

在2009年11月，Free60小组发布了一份技术报告，后来被称为**SMC/JTAG破解**[@anti_piracy-smc_hack_report]。 这使得Xbox黑客社区意识到了两个重大发现。

第一个揭露了零配对漏洞，允许启动任何系统版本，这就是我在几段前解释的内容。 第二个描述了如何**自动触发管理程序漏洞并在运行易受《金刚》攻击系统版本的游戏机中注入有效载荷**，这意味着不再需要保留修改后的《金刚》副本和烧录过的光驱。

因为我已经解释了第一个漏洞，让我来谈谈第二个，因为它相当不可思议。 还记得系统管理控制器（SMC）吗？ 那个位于南桥内部运行的小型英特尔8051，负责处理I/O任务？ 好吧，在启动过程中，SMC从NAND加载其固件，这就是Free60利用来接管SMC的地方。

由于主板暴露了来自SMC的GPIO引脚和来自CPU和GPU的JTAG引脚，黑客们发现他们可以执行以下技术：

1. 使用NAND读取器制作NAND内容的镜像。
2. 使用零配对后门，修改镜像以仅应用导向含《金刚》漏洞管理程序的更新。 <!-- It's fair to say that it sounds simpler that it is in practice, as altering the pairing information invalidates the hashes which will fail the bootloader's checks, so those need manual corrections. -->
3. 修改NAND镜像中的SMC固件区域，以便在启动时，SMC命令GPU通过DMA传输《金刚》光盘上使用的同一块代码。
4. 使用硬件NAND写入器将修改后的NAND镜像烧录到游戏机。
5. 在SMC的GPIO和GPU的JTAG之间焊接带有开关二极管的两根线。
6. 打开游戏机并等待有效载荷出现。

这样，就获得了一个永久性的自动自制软件启动器！ （只要你没有更新到`2.0.8498`）。

### 自制软件的曙光 {.tabs-close}

尽管上述发现被微软的更新所超越，但自制软件社区依然保持着势头，新的应用程序不断涌现，成为任何改装爱好者的“必备品”：

- **XeLL**（即Xenon Linux Loader），后来演变为**XeLL-Reloaded**，是使用管理程序漏洞的实际有效载荷[@anti_piracy-xell]。 它作为一个第二阶段引导加载器，其功能之丰富类似于侦察版维氏瑞士军刀。 XeLL能够启动Linux或者使用**libxenon**编写的ELF可执行文件，libxenon是一个用于自制软件开发设计的替代SDK。 此外，在加载时，其文本界面会自动显示电子熔丝数据和其他底层信息在屏幕上，以便用户如果需要可以记录下来。 如果这还不够，它自托管的HTTP站点提供了额外的控制功能，可以即时转储电子熔丝和NAND的内容。
- **freeBOOT**是官方操作系统的修改版，它禁用了管理程序的签名验证并移除了微软设定的硬编码限制（例如防止使用第三方硬盘的安全区域检查），以及其他一些功能[@anti_piracy-freeboot]。 freeBOOT通过XeLL加载，然后像任何其他未修改的游戏机一样启动官方系统，不同之处在于现在可以从仪表板启动非签名的可执行文件。 在撰写本文时，应用Freeboot仍然是大多数自制用户的主要目标。
  - 要制作一个“freeBOOTed”镜像（最终烧录到NAND中），需要游戏机的CPU密钥。 这意味着游戏机需要首先加载XeLL（使用之前的漏洞），以便可以提取密钥。 然后，可以生成带有Freeboot补丁的新NAND镜像。
- **FreeStyle Dashboard**和**Aurora**是两个替代原始仪表板的程序，它们提供了执行自制软件、加载游戏转储和调整底层设置（例如风扇速度）的增强控制。 虽然它们的目的是取代官方仪表板，但它们仍然像其他XEX可执行文件一样被加载。
- **XeX Loader**和**XeX Menu**是可以从官方仪表板运行的自制启动器。
- Dashlaunch是一个为官方系统提供一系列补丁的程序[@anti_piracy-dashlaunch]，不同之处在于它们在运行时加载（避免了烧录NAND的需要）。 Dashlaunch的功能之一包括在仪表板启动后自动加载一个可执行文件，这通常用于快速加载对自制软件友好的替代仪表板FreeStyle Dashboard或Aurora。

![FreeStyleDash在我的改装游戏机上运行，提供了许多官方仪表板上找不到的控制和指示器。 对于那些资深的Xbox 360用户来说，你会注意到它的界面与标志性的NXE时代非常相似！
](screenshots/homebrew/fds.jpg)

为了简化使用XeLL和/或Freeboot构建NAND镜像的过程，社区开发了许多Windows程序，如**XeBuild**、**J-Runner**和**AutoGG**，以尽可能自动化这个过程。

### 超越微软的优势

尽管之前的事件看起来可能令人兴奋，但恐怕我要说的是，SMC/JTAG破解的发布仅仅是在微软修补了漏洞之后！ 如果你好奇的话，软件更新拉黑了带《金刚》漏洞的管理程序，这样它们就无法在CB阶段被加载。 此外，新的CB还触发了一个新的电子熔丝计数器，因此反击变得不可能……除非发布了一个新的难以想象的黑客技术……

#### 故障注入器 {.tabs.active}

![首次展示在薄型机（Trinity）上的RGH破解[@anti_piracy-rgh_demo]。](photos/rgh_demo.jpg) {.tab-float}

在最后一次重大突破后长达两年的闲置期后，2011年8月，用户“GliGli”提交了一份技术报告，概述了发现的**复位故障破解**（Reset Glitch Hack，RGH）[@anti_piracy-rgh]。 这种新技术允许任何类型的Xbox 360（无论安装了什么更新）运行任意版本的管理程序，就像SMC/JTAG破解一样，不同之处在于现在需要焊接一个**外部芯片**。

简而言之，RGH利用了CPU电路中的一个基本缺陷：如果CPU在其`RESET`线上接收到一个短脉冲（长度为4到60纳秒），CPU将不会复位，而是继续以损坏的状态执行。 换句话说，如果故障发生时CPU正在执行一个`mr`（移动寄存器）指令，`目标`值将变为`0`，而不是`源`寄存器的内容。 如果CPU在执行某些关键操作（如验证引导加载程序）时发生这种情况，这可以对黑客有利。 此外，用户“cjak”发现，通过锁存主板上的一个特殊线路，称为`CPU_PLL_BYPASS`，可以将CPU的速度降低到**大约25 MHz**，从而为故障创造了空间。

借此，GliGli和一群黑客拿了一个通用但快速的CPLD板（类似于FPGA），将其焊接到主板上的许多有用点上，并编程它执行以下操作：

1. 跟踪Xbox的POST信号，以知道何时何地锁存总线。
2. 在CB即将验证CD的哈希值时减慢CPU速度。
3. 当CB在`memcmp()`函数（与哈希值验证相关）中间时`锁存`RESET线。
4. 恢复CPU的原始速度，希望`memcmp()`奇迹般地成功。
5. 如果过程成功，将执行自定义有效载荷。

这样，一个编程用于使Xbox 360的CPU出现故障的板被称为**故障注入器**。

由于这个过程依赖于正确的时序（来自POST输入和硬编码计时器的组合）和非常精确的信号，成功不再是确定的。 尽管为了自动化这个过程，SMC的固件被修改为在启动阶段失败时不断重启游戏机。

有了这个，自制软件社区获得了一个无法修复的漏洞来加载自制软件。

#### 微软的反击 {.tab}

![虽然新的“Trinity”主板带来了许多期待已久的改进，例如将CPU和GPU统一到一个封装中以减少热量， 但它也复杂化了黑客的努力。](photos/xcgpu.jpg) {.tab-float}

尽管RGH破解在早期阶段就攻击了CPU的基本构造（从而使它不可能通过软件更新来解决），微软从未表现出任何弱点，并发布了CB（第二阶段引导加载程序）的进一步更新和新主板版本，试图扰乱故障注入过程。

例如，2010年发布的新款薄型机（讽刺的是，这是在RGH发布前一年），代号**Trinity**，将`CPU_PLL_BYPASS`点移动到了黑客无法找到（当时）的位置。 与此同时，RGH团队发现他们可以通过I²C调整视频编码芯片的PLL信号，这将影响CPU的速度。 不幸的是，视频编码器只能将其减速到一定程度（大约3倍[@anti_piracy-hacking_3]），因此精度和成功率有所降低。 尽管如此，这仍然是一个巨大的成就。

此外，薄型机将CB阶段分为了CB_A和CB_B，其中CB_B进一步使用RC4算法加密，并依赖于CPU密钥。 为了加剧绝望，零配对后门被完全移除。 最终，所有这些更改将很快扩展到旧型号，因为微软发布了更多的软件更新。 尽管如此，黑客们从未放弃，并发现他们可以在加密形式下修改CB_B。 得益于RC4中的一个数学缺陷，加密信息可以通过应用与未加密的差异补丁进行`XOR`操作来更改[@anti_piracy-hacking_3]，从而允许在不知道CPU密钥的情况下禁用CB_B上的加密例程！

#### 销售RGH {.tab}

![“X360 Squirt 1.2”是针对Trinity主板的设置。 这是市场上众多可用于破解Xbox 360的商业故障注入器之一。](photos/squid.jpg) {.tab-float}

在接下来的三年里，RGH破解的韧性成功地抵抗了微软所有试图减轻其影响的工作。 与此同时，剩下的就是一场经典的猫捉老鼠游戏，微软试图使这项任务变得不可行。 因此，面对不断到来的软件更新浪潮，许多论坛上散布了RGH的新变体。 这些变体共享RGH破解的基本原理，但每个变体都使用不同的程序作为故障注入器，并修改SMC镜像以提高成功率。

最初，作为故障注入器的程序，RGH破解分化为两个不同的变体：依赖于PLL线的**RGH1**，以及依赖于视频编码器的**RGH2**。 后者可以被任何主板版本使用，并不断修复以应对微软试图破坏它的尝试；而RGH1虽然无法离开旧硬件（Trinity）和软件（`2.0.14699`更新），但它享有更高的可靠性。

无论如何，RGH的成功引发了一波商业故障注入器和安装套件的浪潮。 这些套件承诺，在更高的价格点上，将提供更简单的安装过程和更高的成功率。 我认为**Team Xecuter**是充分利用RGH狂热浪潮的最佳例子之一。 该公司销售定制的Xilinx的“CoolRunner”开发板版本，以与其他可编程故障注入器市场竞争。 最值得注意的是，Team Xecuter的板子要么是预编程的，要么支持他们新的RGH变体：

- 由于微软试图通过`2.0.15572`更新修复XOR漏洞，2012年12月，Team Xecuter推出了一块名为DGX（双重故障破解）的新板子，专注于提取CPU密钥[@anti_piracy-dgx]，然后像其他任何RGH方法一样继续操作。 这样，微软的更新通过烧录旧的未加密引导加载程序，然后使用DGX让引导过程发生**两次**故障来绕过修改后的CB_B的比较和验证，从而得到了解决。
  - 后来发现，Team Xecuter的方法更像是暴力攻击。 一个更可靠的过程只需要在CB_A准备从NAND复制数据时进行故障处理[@anti_piracy-balika]。
- 非薄型机的R-JTAG故障注入器[@anti_piracy-rjtag]。 这种方法于2013年5月发布，是一种针对更新版主机的全新方法，试图接近RGH1的旧成功率。 基本上，R-JTAG故障处理CPU以加载易受JTAG/SMC漏洞攻击的旧版管理程序，然后像后者一样进行操作。
- 随着他们新的旗舰产品‘CR4 XL’故障注入器的推出，**RGH2+**被提出作为一种新模式，以改进经典的RGH2。 这次，CPU减速过程被委托给了SMC[@anti_piracy-rgh_wiki]。

由于某种原因，Team Xecuter没有提供任何文档来在其他设备上复制这些新技术。 因此，用户们亲自上手，以提供更便宜和/或更好的替代方案：

- 首先，“DrSchottky”成功创建了一个名为**R-JTOP**的R-JTAG开源实现，供任何故障注入器使用[@anti_piracy-rjtop]。
- 其次，开发者“blaKCat”在他的刷新工具中捆绑了双重故障例程，因此任何板子都可以编程，而无需依赖昂贵的DGX。
- 第三，2014年12月，黑客“15432”发布了“Speedy RGH”（**S-RGH**）[@anti_piracy-srgh]，作为CR4专有RGH模式的替代方案。 S-RGH通过减少故障注入过程中的减速周期，甚至实现了更快的速度。
- 后来，2015年4月，15432再次发布了一种名为RGH 1.2的新方法，结合了RGH2和CPU的PLL线的使用[@anti_piracy-rgh12]，达到了与RGH1相似的成功率。
- 最后，2021年8月，工程师Josh Davidson成功地将RGH 1.2移植到Slim主机上，通过在新主板上找到缺失的PLL线[@anti_piracy-rgh12_slim]，从而产生了名为**RGH 1.2 V2**的新变体。

#### 终局 {.tabs-close}

随着Xbox 360后继产品的临近，微软最后一次发力，推出了一个重新设计的游戏机版本，名为‘E’，在其中，又有一个名为**Winchester**的主板修订版。 在零售机型中，Winchester最终禁用了POST和PLL信号，并过滤了CPU `RESET`线的_外部干扰_[@anti_piracy-hack_win]。 这使得自RGH黑客技术发现三年后，该技术变得过时。

然而，对于兼容的主板（仍然非常普遍）， 除了提到的RGH变体之外，还有一项黄金般的发现等待揭开。 快进到2021年11月，15432再次让社区感到惊讶，发布了**RGH 3.0**，这是一个统治一切的通用RGH变体。 在幕后，这项新技术是RGH 1.2 V2的进化版，不再需要**故障注入器**[@anti_piracy-rgh3]。 这是通过将故障阶段实现到SMC中来完成的，现在只需要在主板上焊接两根线（特别是新定位的`CPU_DBG1_POST1`和`CPU_PLL_BYPASS`）来执行黑客攻击。

## 这就是全部了，伙计们。

![我的两台Xbox 360，一台“胖”版的Zephyr和一台薄型机Trinity并排放置，以供沉思。 ](thatsall.jpg)

恭喜你读完了这篇文章！

我认为这篇文章[再次](super-nintendo)告诉我们，不需要昂贵的科技就能征服新一代。 不要误会，我仍然认为Cell是一项伟大的发明，它为消费市场带来了许多技术进步，但我认为它的能力与PS3中其他芯片相比有着极大的不同。 相比之下，Xbox 360呈现出一种更为和谐的混合，所有组件都能共同工作，发挥彼此的潜力。 无论如何，每一台游戏机都有其独特的一套优点和缺点。 这就是为什么我喜欢写关于它们所有机子的文章。

接下来，为了收集这篇研究的材料，我最终囤积了大量的机型，主要是因为我需要找到安装了特定操作系统版本的游戏机（因为它们无法降级）。 这后来变成了一场成败参半的挑战，更糟糕的是，我的旧机器在开始这个网站之前就坏了。 不管怎样，一天结束时，我发现自己身边有：

- 一台2005年的未使用的**Xenon**，原主人甚至不敢打开盒子。 令我惊讶的是，它运行的是`2.0.1888`（对我来说太像古董了，不敢摆弄），所以我不得不让它保持原样……
- 一台前主人送去维修的**Zephyr**型号，但等到微软寄回来时，主人已经又买了一台。 它安装了NXE系统。
- 一台商店清仓时购买的**Jasper**，同样从未使用过，它也运行着NXE。
- 一台配备了RGH 1.2的**Falcon**。 我买它是为了尝试将它降级到Blades时代的系统，结果发现没有合适的工具是无法做到的。 幸运的是，感谢Octal’s Console Shop提供的软件，现在这样做变得简单了。
- 我从十几岁开始就拥有的旧**Trinity**。 不幸的是，它遭遇了死亡三红的诅咒，我无法修复它。 幸运的是，在RGH 3.0发布后，我买了一台便宜的备用Trinity，应用了RGH，并移植了内部记忆卡，以恢复我的旧档案和保存的游戏。 这篇文章中的所有游戏截图都来自这个型号。

现在文章写完了，我很高兴终于可以放下这次搜寻了。 顺便说一下，这是[第七世代游戏机传奇](consoles#7th-generation)的最后一篇文章！

关于我的下一步计划，我正在考虑回到90年代，向那些让我遗忘的历史游戏机致敬，或者可能在网站上再做些工作……我们拭目以待！

下篇文章见！  
Rodrigo
