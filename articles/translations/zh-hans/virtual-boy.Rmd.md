---
short_title: Virtual Boy架构
long_title: Virtual Boy的架构
name: Virtual Boy
subtitle: 隐藏的潜能，不幸的结局
date: 2021-02-12
release_date: 1995-07-21
cover: "virtualboy"
javascript:
  - "virtualboy_graph"
generation: 5
published: true
top_tabs:
  Models:
    - 
      title: "主机背面"
      file: back
      extension: jpg
      active: true
      caption: "Virtual Boy<br>1995年7月21日于日本，1995年8月14日于美国发布。"
      bib_source: copetti
    - 
      title: "主机正面"
      file: front
      caption: "游戏机的正面图<br>用户应通过目镜观察"
  Motherboard:
    caption: "主板<br>不要与主板连接的“伺服板”（Servo board）混淆。<br>背面装有虚拟声音单元（Virtual Sound Unit）芯片、128 KB DRAM和64 KB PSRAM。"
  Diagram:
    caption: "请注意，这两张截图的背景图片略有水平移动。"
---

## 快速介绍

人们通常用寿命短和色彩空间有限来概括这台游戏机。 虽然在技术上是正确的，但我认为这些属性往往会忽略其他令人惊讶的特性。

在本文中，我将邀请读者进一步了解它的内部特性，其中许多特性直到Virtual Boy停产后才在市场上占据主导地位。

## {.supporting-imagery}

## 显示

整个系统是一项奇特的工程产物。 从外观上看，它就像一个安装在两脚架上的笨重的VR头显。 玩家必须将头靠近目镜，才能看到游戏中的动作。

![这是我能达到的同时拍摄显示屏和机箱照片的极限。 实际上，游戏看起来非常清晰，而且是全尺寸！](case/front.png)

内部则完全不同（而且非常复杂）。 因此，我认为最好先解释一下这台游戏机是如何显示图像的，然后再介绍内部硬件。

### 投影图像

打开Virtual Boy后，你将通过目镜看到两幅**单色红色**图像（每只眼睛一幅）。 到目前为止还不错吧？ 有趣的地方来了：** 这台游戏机没有屏幕**，所以你看到的更多是一种“错觉”——让我们深入了解一下这到底是怎么回事。

解释这部分内容所涉及的主题（光学、视觉现象等）一开始可能会让人感觉困难，但我制作了一些互动动画，让这部分内容更有身临其境的感觉。

#### 扫描仪 {.tabs.active}

![扫描仪的主结构图，展示LED的光线如何到达玩家的眼睛。](scanner.png){.tabs-nested .active .tab-float title="结构图"}

![游戏机鸟瞰图。<br>第一个开关是“对焦滑块”，下面是“IPD刻度盘”。](case/top.jpg){.tabs-nested-last title="开关"}

这台游戏机的大体积可以归功于**扫描仪**，它占去了游戏机的很大一部分。 扫描仪是Virtual Boy显示图像的区域。 它由两个**显示单元**组成，每个单元独立投射一帧图像（总共两帧，每只眼睛一帧）。

显示单元是所有“魔法”发生的地方，由以下部件组成：

- **LED单元**： 包含224个垂直堆叠的红色LED以及控制每个LED的必要电路。
- **透镜**： 折射LED发出的光线。
  - Virtual Boy 的外壳顶部有一个**对焦滑块**，用于将镜头移近或移远LED。 这样，用户就可以根据自己的焦距调整游戏机（防止图像模糊）
- 一面**镜子**： 反射来自透镜的光线，并将其照射到用户的眼睛上。 此外，由于连接了一个**音圈电机**，该组件将不断摆动。 该电机由**伺服控制装置**管理，伺服控制装置是一块独立的电路板，能以50Hz的频率发送电脉冲。
  - 总之，这是游戏机中一个非常复杂和脆弱的区域，因此安装了一个光中断器（photo interrupter，一种光传感器）。 它将从反光镜观察到的振荡情况报告给伺服控制装置，伺服控制装置则反过来监测振荡情况并进行必要的修正。

聚焦滑块旁边有一个**IPD刻度盘**（旋钮状开关），用于调整两个显示单元之间的距离。 这样做是为了使显示器适应用户的瞳距。

#### 机械原理 {.tab}

![摆动镜角度随时间变化的基本表示（以非常缓慢的动作）。<br>左侧和右侧 LED 灯分别在红色和蓝色时段工作（激活）。<br>在灰色时段，没有 LED 工作（空闲）。<br>为简单起见，这里表示的角速度是恒定的（但实际情况并非如此）。](scangraph){.tab-float animation="true"}

现在，我们已经识别了每个组件，让我们来看看Virtual Boy是如何向我们的眼睛显示图像的。

如果你之前没有注意到，这里**没有任何点阵显示器**，那么为什么我们能从目镜中看到二维图像呢？ 与显像管（CRT）显示器的功能类似，显示装置也在改变我们感知图像的方式：

- 事实上，镜面的摆动可以使一列LED在我们的视野中水平移动。 镜子的角度经过精心设计，可将 LED 灯放置在384个不同的“列位”上，这些柱位分布在我们的视野中。
- 人的视觉是对数的，而镜子的振荡频率为**50Hz**（每个周期为20ms）。 由于速度太快，我们最终会感觉到384列LED同时发光（视觉暂留效应），直到镜子停止摆动。
- 所有这一切都与LED控制器完全同步，每当镜子轻微移动时，控制器就会更新每个LED灯。 这样，我们就能从目镜中看到一幅完整的画面。

在实际操作中，所有这些原理都需要满足一些条件：

- 只有当反射镜的角速度保持稳定时，LED灯才会工作（换句话说，当反射镜改变方向时，LED灯不会工作）。 这可以看作是CRT显示器的[**活动状态**](master-system#tab-1-4-result)。
- 关于前一点，镜面的角速度不能保持恒定（因为镜面不能瞬间改变方向，被视为 “稳定 ”的时间段会受到扰乱其速度的力）。 为了解决这个问题，Virtual Boy在内存中存储了一个名为“列位表”（Column Table）的数值列表，用于指示每个列的间隔时间，以平衡“LED列”曝光时间的过长和过短。
- 别忘了，由于我们有两个显示单元（每只眼睛一个），因此整个过程必须进行两次。 不幸的是，两个显示单元不能同时获取能量和数据，因此每个显示单元在不同的显示时段工作（不同步，相差10ms）。 我们并没有注意到这一点（又一个错觉！）。

#### 显示 {.tab}

![第一个LED单元在特定时间段内工作的简化示意图。 请注意LED灯在活动期间如何开始显示帧缓冲区的每一列。](frame){.tab-float animation="true"}

与以前以CRT显示器为模型的视频芯片（即[PPU](nes#graphics)和[VGP](master-system#graphics)）相反，Virtual Boy上的图形不是**即时渲染**的。 游戏机上的图形芯片将处理过的帧发送到内存中的帧缓冲器，然后将帧的每一列发送到LED阵列进行显示。

一旦伺服电路板检测到显示时间到了，图形芯片就会开始将帧缓冲器中的像素列逐一发送到那224个垂直堆叠的LED上，并巧妙地保持同步，这样LED在显示期间就会显示384列。 因此，游戏机的“屏幕分辨率”为384x224像素。

此外，我们还需要存储两个帧缓冲器，因为每个帧缓冲器都将用于不同的显示单元。 图形子系统还采用了双缓冲和其他特技（稍后将在“图形”部分提及）。 因此，现在只需记住数字帧是如何发送到LED的。

#### 活动期 {.tab}

![另一个简化动画，这次展示了镜子的摆动如何使LED灯的光线偏向使用户最终看到正确的的画面。](active){.tab-float animation="true"}

因此，这种设计会有一些活动显示期：

- **活动显示**：在此期间，LED从帧缓冲器中提取图像，没有任何东西可以干扰它。
- **活动显示2**：与之前相同，但现在另一个显示单元正在工作。
- **绘制空闲**：LED灯都不工作，镜面角速度不稳定。

这个周期每秒重复50次（因此刷新率为50Hz）。 这意味着每帧画面，CPU和GPU大约有10ms的时间来更新用户看到的画面。 实际上，任天堂的工程师们实现了更复杂的功能。 我将在“图形”部分再次深入解释这一点。 但现在，我希望您能很好地理解Virtual Boy是如何巧妙地利用廉价硬件生成图像的。

#### 一些评论 {.tabs-close}

以上是对光学如何将一条垂直线变成一幅图像的简要说明。 如果您拥有或以前读过有关Virtual Boy的文章，您可能会想知道3D图像是什么时候出现的。 我只想说明一点，前面的解释都与这种效果无关。 我之所以提到这一点，是因为过去我曾在很多地方看到有人认为振荡镜是产生“深度感知”的原因，但根据我在这项研究中收集到的所有信息，我认为这种说法并不准确。

既然如此，我认为是时候讨论一下3D现象了......

### 创造三维视觉

在Virtual Boy的市场推广过程中，人们对这款游戏机可以投射出“三维世界”这一事实大肆宣传。 我指的不是显示3D多边形的图像（如其他第五代 游戏机），而是实际的深度感知。

简而言之，Virtual Boy依靠**立体图像**来实现这种错觉\[@cpu-tucker\] \[@graphics-patent\]。 因此，这套系统不仅能玩弄我们的视觉，投射出完整的图像，还能让我们认为某些图画离其他图画更近或更远！

::: {.subfigures .tabs-nested .tab-float .open-float .pixel}

![左部显示单元的截屏](tennis/left.png){.active title="左部"}

![右部显示单元的截屏](tennis/right.png){title="右部"}

马里奥网球（Mario's Tennis）（1995）

:::

这种技术非常简单： 在显示的两个画面中（每只眼睛一个画面），有些元素会在水平方向上略微偏移，因此当我们试图用两只眼睛去看这些元素时，大脑会认为它们比其他元素更近。 这取决于元素移动的方向。

向眼睛中心移动的物体（在左视框中向右移动，在右视框中向左移动）会显得更近，而远离眼睛中心的物体则会显得更远。 最后，没有移动的物体会出现在两个画面之间。 这种方法被称为**立体视差**。

{.close-float}

立体视差的缺点之一是**眼睛疲劳**。 游戏提供了“自动暂停”系统，提醒用户每30分钟休息一次，从而缓解了这一问题。 任天堂还在包装和文档中写下了各种警告信息，以防止出现严重情况。 无论如何，3D效果是无法关闭的。

## 中央处理器 (CPU)

好了，我们回到实际的架构上，现在让我们看看游戏是如何构建你所看到和听到的画面和音乐的。

该系统使用定制版的**NEC V810**，其工作频率达到了惊人的**20 MHz**（*如果说[SNES](super-nintendo#cpu)的平均工作频率为1.79 MHz，GameBoy为[4.19 MHz](game-boy#cpu)，那么我已经迫不及待地想知道你能用它做什么了！*）。 任天堂之所以称它为**NVC**，是因为Virtual Boy所配备的处理器是一个V810内核与一些附加组件的组合（详情即将公布）。

V810是NEC为嵌入式市场设计的V800 CPU系列的一部分\[@cpu-necfamily\] \[@cpu-necv805\]。 虽然这种CPU不像竞争对手（如[MIPS](playstation#cpu)、[6502](nes#cpu)、[Z80](master-system#cpu)）那样受欢迎，但它确实带来了许多尖端功能，特别是：

- **32个32位寄存器**： 这是一个完整的32位CPU，寄存器与之完全一致。
- **V800系列ISA**： 混合16位和32位指令的RISC指令集。
- **32位地址总线**： 允许访问高达4 GB的内存，这在当时是一个巨大的空间。
- **五级流水线**：[这里](game-boy-advance#cpu)是之前对指令流水线的解释。 值得一提的是，其他系统首次亮相时只有三级流水线，而这款系统直接采用了五级流水线！
- **1 KB L1指令高速缓存（L1 Cache）** 。
  - 在约10年后的[任天堂DS](nintendo-ds)出现之前，任天堂不会再推出“带缓存的”掌机！

对于1995年的便携式游戏机来说，这已经非常了不起了。 但如果这还不够，任天堂还增加了额外的资源：

- **I/O接口**： 这些接口将与专有配件通信的任务下放给了任天堂。
- **16位外部总线**： V810可以配置16位或32位总线。 任天堂的工程师选择了前者。
  - 在32位内存传输时，这将带来一些限制（等待状态），但你很快就会明白为什么程序不会有*那么高*的要求。
- **计时器**：这只是一个16位计数器。
- **等待控制**：根据访问的外部总线来停滞CPU。 这是因为V810认为所有内容都来自同一内存块，但实际上，访问游戏ROM比访问内部RAM要慢。 因此，这个组件可以修正时序。

所有这些看起来都很好，但成本也很高：**六节AA电池**（译注：5号电池）。 这也许可以解释为什么公司倾向于在便携设备上使用旧技术，至少在90年代是这样。

### 内存访问

32位地址在纸面上看起来非常诱人，但如果系统不会使用任何接近4 GB的内存位置，那么它就是一种巨大的资源浪费。 例如，尽管上层地址线不会改变，但每次读取内存时仍要对其进行解码。

因此，出于充分的理由，任天堂将地址减少到了**27位**。 这意味着最多可以访问**128 MB的内存**。 32位字仍然用作指针，但上面的5位被舍弃。 因此，内存映射的某些部分将被镜像。

尽管如此，内存映射布局允许CPU访问构成该系统的大部分组件。 这包括 [@cpu-guy]：

- **64 KB RAM**（称为“WRAM”），用于一般用途。
- 卡带ROM和RAM（如果包含）。
- 声音芯片
- 图形芯片及其专用内存。
- I/O及其各自的寄存器。

CPU 到此为止，现在该看看你能用它做些什么了！

## 图形

让我们回顾一下正确显示图形的要求：

- Virtual Boy必须显示两帧。
- 每帧的分辨率为384x224像素。
- 调色板由深浅不同的红色和黑色（即LED熄灭时）组成。
- 场景需要应用视差效果。

好消息是，所有这些都由任天堂制造的专用芯片，**视频图像处理器**（Video Image Processor，“VIP”）进行加速。 它继承了旧版[PPU](game-boy#graphics)的一些功能，但我认为它与前代产品完全不同。

### 架构

VIP初看起来可能是另一个图块（Tile）引擎，但它要比这先进得多。 首先，它不仅能处理图形数据，还能控制扫描仪。

此外，传统的图块引擎是按扫描线渲染图形，而VIP则采用**帧缓冲器架构**，将最终帧作为位图存储在内存中，然后发送显示。 这更接近现代[3D着色器](sega-saturn#graphics)的工作方式。 事实上，Virtual Boy更进一步，采用了某种[**翻页（page flipping）**](game-boy-advance#beyond-tiles)方式，即每个显示单元存储两个帧缓冲区，扫描仪在拾取一个缓冲区的同时，VIP正在写入另一个缓冲区。 所有这些都有助于防止画面撕裂。

![VIP的架构](vip.png) {.open-float}

尽管如此，VIP可以分为三个主要部分：

- **像素处理器**（Pixel Processor，“XP”）：生成背景和精灵，与PPU相似。 它将最终处理过的位图发送到内存中的帧缓冲区。
- **显示处理器**（Display Processor，“DP”）：控制扫描仪并发送帧缓冲区以供显示。
- **接口**： 提供对两个内存块的访问：128 KB的VRAM和128 KB的DRAM[@cpu-ic]。 它们还在VRAM和CPU（VIP端称为“主机”）之间进行访问仲裁。

{.close-float}

总体而言，流水线非常简单：

1. CPU通过写入VIP的内部寄存器和向VRAM和DRAM中填充所需的素材来设置VIP。
2. 然后，XP将生成帧缓冲区并存储在VRAM中。
3. DP选择所需的帧缓冲区，并将其发送到扫描仪进行显示。 具体做法是将帧每次复制四列，复制到VRAM中称为**串行访问内存（Serial Access Memory，“SAM”）**的小型缓冲区，并自动广播给扫描仪。

### 硬件组织

![VIP的内存布局](vip_content.png)

在开发人员方面，XP和DP使用两块内存：

- **128 KB DRAM**用于存储将要处理的图形数据。
- **128 KB 的 VRAM**用于存储DP将寻找的帧缓冲区。
  - 由于我们有两个显示单元，因此总共需要四个帧缓冲区。 生成的每个位图宽度为24 KB，因此我们需要分配96 KB内存。 剩余的32 KB被XP用于存储**图块**。

请注意，这个VRAM是“真正的”双端口DRAM[@cpu-toshiba]，而不仅仅是为图形预留的RAM块（任天堂[也称之为“VRAM”](game-boy#organising-the-content)）。 双端口DRAM允许两个设备同时读取，这就解释了为什么XP可以在扫描仪读取VRAM的同时写入它。

此外，任天堂使用的 VRAM 芯片在现成的产品目录中找不到。 有关它的文件不多，但从专利申请中描述的信息来看，SAM可能存储在该芯片内部的一个单独区域中。 该区域可能由SRAM代替，并包含额外的电路，使扫描仪能够一次读取16个位[@cpu-sharp]。

### 构造一帧

让我们深入了解一下像素处理器是如何绘制单帧图像的。 为此，我将借用Virtual Boy瓦里奥大陆（Virtual Boy Wario Land）的资产。 我强烈建议大家阅读[以前的图块引擎](game-boy#graphics)，以便更轻松地理解讲解。

#### 图块 {.tabs.active}

![VRAM中发现的图块](wario/tiles.jpg){.tabs-nested .tab-float .active .pixel title="图块"}

![VRAM中发现的被网格分隔的图块](wario/tiles_grid.jpg){.tabs-nested-last .pixel title="网格"}

我们[之前已经了解过](game-boy#tab-1-1-tiles)传统图块引擎是如何使用8x8位图构建图层的。 就Virtual Boy而言，图块（最初称为“字符”）存储在 VRAM 中一个名为**图案表（Pattern table）**的区域中。 声明的每个图块占用2字节，因此有足够的空间容纳2048个图块。

在颜色方面，开发人员可以构建8个调色板，其中4个用于背景图形，另外4个用于精灵。

有人可能会问，如果LED是单色的，调色板有什么用？ 这样，开发人员就可以使用**不同色调的红色**。 这些色调是通过改变LED的亮度获得的。 亮度设置存储在两个寄存器中，然后在调色板中引用这两个寄存器来编排不同的色调。 这样得到的调色板将包含两种自定义红色，加上根据两种红色的总和自动计算出的另一种红色，以及最后的“透明”色。

#### 背景 {.tab}

::: {.subfigures .tabs-nested .tab-float .pixel max_subfigures=1}

![背景图层0 (BG0)。](wario/background_1.jpg){.active title="背景0"}

![背景图层1 (BG1)。<br>在游戏过程中，该图层大部分时间是隐藏的，而在按下暂停键后则会完全显示出来。](wario/background_2.jpg){title="背景1"}

![背景图层2 (BG2)。](wario/background_3.jpg){title="背景2"}

声明的一些背景层

:::

背景图层非常简单，选取图块组成一张512x512的地图（64x64图块，共4096个图块）。 现在，事情还没有结束，因为我们不是只有一个背景层可用…… 我们有14层！

每个单独的背景图层称为一个**段**（Segment）。 单个段可容纳8 KB内存，其中每个图块引用包含**H/V(水平/垂直)翻转**属性和**调色板索引**。 每个图块引用占用2字节内存。

像素处理器还允许组合不同的段来生成更大的图层，但只有一组组合可用。 最大的组合包括8个段。

#### 精灵 {.tab}

精灵（任天堂称之为“对象”）是具有独立坐标的单个图块，但占用更多内存。

在DRAM中有一个名为**OAM**的地方，分配有8 KB的内存，这里就是定义精灵的地方。 每个精灵定义占用8个字节，因此最多可声明1024个精灵。

每个精灵都有以下可用属性：

- X 和 Y 坐标。
- 一个标志，用于决定是在左侧屏幕、右侧屏幕还是同时在两个屏幕上显示。
- **视差偏移**，允许应用自动视差：每个屏幕显示精灵时都会有轻微的水平偏移。
  - 该值是**有符号**的： 如果该值为正数，则会使精灵看起来更远。 相反，如果偏移量为负值，则会使其看起来更近。
- 使用的图块索引。
- H/V翻转。
- 调色板索引。

你还会注意到，本段介绍没有显示屏幕截图，下一段将解释原因。

#### 窗口 {.tab}

::: {.subfigures .tabs-nested .tab-float .pixel}

![世界1](wario/window_1.jpg){.active title="世界1"}

![世界2<br>这个画面在两个显示器上都被渲染](wario/window_2.jpg){title="世界2"}

![世界3<br>暂停游戏时，这个画面就会展开](wario/window_3.jpg){title="世界3"}

![世界4<br>这就是我在上一段欠您的那个“精灵层”](wario/window_4.jpg){title="世界4"}

窗口示例<br>有些窗口可以在两个显示器上同时显示（使用移位效果），而有些窗口只能在一个显示器上显示。

:::

分层系统初看起来可能很简单，毕竟VIP提供了“背景”层和“精灵”层。 那么，我们还需要什么呢？

事实上，要显示前面提到的任何图层，我们都必须将它们放入一个名为**窗口**（也称为“世界”）的“桶”中。 窗口是将被渲染到屏幕上的实际平面，它由之前构建的图层填充。 共有32个窗口，它们将重叠形成最终的画面，每个窗口声明占用32个字节。

窗口提供不同的**渲染模式**。 您可以抓取一个背景层或精灵层，并按原样显示。 为此，窗口必须设置为**正常模式**或**对象模式**，具体取决于您使用的图层类型。 不过，您也可以利用其他模式，在背景层上应用额外的效果：

- **线条移动模式**： 可以水平移动单行像素。 这类似于[水平中断](game-boy#tab-2-1-wobble-effect)时应用的老式效果。
- **仿射模式**： 顾名思义，你可以应用[仿射变换](super-nintendo#that-feature)！ (缩放、旋转或组合形成透视投影 [@graphics-tucker]）

#### 结果 {.tab}

![嗒哒——！](wario/frame.jpg) {.tab-float.pixel}

设置好一切后，像素处理器将开始渲染32个窗口。 完成后，最后一帧将被放入帧缓冲区。 其他显示单元也会重复这一过程。

由于系统**采用双缓冲设计**，显示处理器将始终获取像素处理器未处理的帧缓冲区，从而大大避免了撕裂。 在下一个活动时间段，像素处理器将覆盖DP之前显示的帧，以此类推。

如果需要渲染的内容不多（即很少使用窗口），在写入帧缓冲区和DP提取帧缓冲区之间会有很长的间隔。 这样，CPU就可以根据需要对帧进行额外更改。 VIP也为此做好了准备：CPU可以设置中断来检查VIP的各种状态，包括这种情况。

另一方面，如果有太多的仿射模式窗口需要渲染（例如），XP可能会**“错过最后期限”**，从而导致掉帧。 幸运的是，也有中断可以检测到这种情况。 无论如何，官方文档都提供了每种图层所需的时间。

### 创意内容 {.tabs-close}

如您所见，这款游戏机中的技术远不止这些。

::: {.subfigures .tabs-nested .tab-float .open-float .pixel}

![正在运行的仿射模式，显示初始背景地图](tennis/affine_map.jpg){.active title="地图"}

![应用透视投影的已渲染地图](tennis/affine_window.jpg){title="窗口"}

![用户看到的一帧](tennis/affine_frame.jpg){title="一帧"}

马里奥网球（Mario's Tennis）（1995）

:::

起初，我以为[Game Boy Advance](game-boy-advance)是近11年后第一款能重构超级任天堂广受好评的[模式7](super-nintendo#that-feature)的便携式游戏机。 结果发现一直以来都是5年后的Virtual Boy。 但即便如此，我们之前已经看到，Virtual Boy中的仿射变换可以应用于32层中的每一层（尽管有一些限制）。

此外，所有这些新功能都能与视差效果一起使用，而VIP也能做到这一点。

我在想，如果这台游戏机的寿命能够再长一点，让开发人员能够更好地使用这种硬件，我们会看到什么样的游戏呢？

{.close-float}

另一个有趣的功能是，通过允许CPU更改帧缓冲区，如果VIP无法满足开发人员的需求，他们就可以构建自己的着色器。 一些游戏就是依靠它来呈现创新图形的。 例如，红色警报（Red Alarm）采用了由CPU渲染的多边形构建的场景。

::: {.subfigures .side-by-side .pixel}

![红色警报（1995）](redalarm.jpg) {.toleft}

![水世界（Waterworld）（1995）](waterworld.jpg) {.toright}

这两款游戏都尽量少使用VIP来绘制图形，而是让CPU来绘制主要图形。

:::

遗憾的是，像[可见表面确定](sega-saturn#an-introduction-to-the-visibility-problem)这样的基本问题并不总是能得到很好的解决，我不确定这是否是由于CPU的限制造成的。 总之，这导致场景变成了杂乱无章的网格，玩家很难分辨哪些物体在其他物体后面。

## 音频

试想一下，将Game Boy的[波形通道](game-boy#tab-3-2-wave)乘以5，再加上一个噪音通道，就能产生如此美妙的音效： 这就是Virtual Boy的声音芯片。 你也可以把它看作是[PC Engine](pc-engine#audio)的同胞兄弟。

![马里奥网球（Mario's Tennis）（1995）](tennis){.open-float video="true"}

主板上还有一个名为**虚拟声音单元**（Virtual Sound Unit，“VSU”）的芯片提供声音功能。 PSG依靠内部RAM存储**5个波表**和一个寄存器文件来配置**6个可用通道**中的每个通道。 寄存器为8位宽，而内部RAM与6位数据总线相连（CPU仍将6位字视为单字节，但会舍弃上面的两位）。

每个波形由32个PCM采样（以6位值编码）组成。 通道具有平移控制设置（左右音量从0到15）和11位频率控制。

{.close-float}

每个通道还有一个基本的包络控制，可使音量随时间增长或衰减。 第五个通道支持更多效果，即逐步移动频率的**扫频功能**和根据内部RAM中存储的一些值改变波形的**调制器**。

第六/最后一个通道只能输出**噪音**。

### 输出

混合输出为**立体声**，分辨率为**10位**，采样率为**41.7 kHz**。 还值得指出的是，游戏机带有立体声扬声器，因此不必戴耳机也能欣赏到这种效果！

## I/O

从理论上讲，这是一款“便携式”游戏机，所以不要指望它有*能改变游戏规则*的配件（双关语）。 不过还是有一些有趣的东西。

### 接口

在内部，除了VIP独自处理的某些区域外，每个组件都与CPU直接相连。

![外壳底部右侧[@photography-amos]。 展示了控制器（串行）端口和外部（通信）端口](case/underside.png) {.open-float}

从外部看，有两个连接器可供配件使用：

- **串行端口**： 连接**控制器**。 数据传输以串行方式进行（每次1位）[@cpu-diagrams]，但接口将其调整为返回一个16位值供CPU读取（每按一位表示按下一个按钮）。 还可以设置中断，在按下任何按键的瞬间通知CPU。
  - 该连接器的一个引脚还将**5V电压**从控制器发送到游戏机。 这实际上是用来**为游戏机供电的**！
- **通信端口**： 虽然*本身*不是配件，但这个端口用于与另一个Virtual Boy通信。 这让我想起了Game Boy使用的[Link电缆](game-boy#external-communications)。 两个Virtual Boy使用串行数据流以主从方式进行通信。
  - 这不禁让人好奇，任天堂设想的是什么样的多人游戏功能。 遗憾的是，最终没有游戏使用这一功能。

{.close-float}

### 控制器

Virtual Boy的手柄与其他游戏机相比非常奇特。 它与超级任天堂的手柄有些相似，但没有“X”和“Y”按钮，手柄更大，右侧还有一个额外的 D-Pad。 除此之外，**你在玩游戏时还得盲操**。

![手柄[@photography-amos] 注意中间的滑块是“电源开关”。](io/controller.png){.tabs-nested .active .open-float .tab-float title="手柄"}

![电池包安装在背面[@photography-amos]](io/batterypack.png){.tab-nested title="电池包"}

![您可以购买一个单独的盒子，专门用于连接SNES电源进行交流到直流的转换[@photography-amos]。](io/acpack.png){.tabs-nested-last title="交流供电包"}

此外，由于手柄也要供电，它的背面还配有一个可拆卸的电池包。 电池包名为**Tap**，可装六节AA电池。 如果用户厌倦了在六节电池中的任何一节用完后再找电池，也可以购买另一个可连接外部电源的Tap。

在使用后一种配件的情况下，用线缆连接所有东西进行游戏可能会感觉像纸牌屋（尤其是在游戏过程中不能看的情况下），但我想如果你不想担心电池问题，这就是代价🙂。

{.close-float}

## 操作系统

V810从地址`0xFFFFFFF0H`开始执行。 这意味着，当Virtual Boy启动时，它将从该地址查找指令。 也就是说，该地址位于卡带ROM上。 这意味着游戏在硬件初始化方面占先手。

此外，主板上没有任何BIOS芯片，因此不会有任何操作系统或抽象层来帮助简化操作。

### 家务活

为此，任天堂指示开发人员执行几项杂务，以确保这台游戏机的正常运行，这些杂务包括：

- WRAM只有在游戏机启动200us（0.0002s）后才能使用，因此文档中列出了游戏必须遵循的等待步骤。
- 游戏必须填列位表。 回顾之前的解释，“活动显示”期间的角速度是可变的。 为了防止帧的某些列比其他列更窄，游戏必须在DRAM中填入一个表来提供修正。 为了方便起见，任天堂在其SDK中提供了一个默认列表，供游戏使用。
  - 该表还可以在游戏过程中随时修改，由于它可以控制LED的发射量，因此也可以作为调整每列亮度的机制。

## 游戏

也许有人会认为，游戏开发会沿用Game Boy的设施（即*坚持汇编语言*），但事实证明，任天堂和NEC在这一领域投入了大量新技术，以加快/现代化这一领域的发展。

### 开发生态

游戏工作室可以选择购买任天堂提供的**开发套件**，其中包括一个设备齐全的调试站、一个工具链和大量文档。

硬件套件名为**VUE开发系统**（“VUE”是这款游戏机的代号），它是一个类似PC的塔式设备，包含Virtual Boy的内部结构，外加4 MB内存（可扩展至8 MB！）。 它与一个耳机（外形与零售版Virtual Boy相同）和一个零售版控制器相连。 为了运行和调试程序，开发套件中包含一块接口板，可以通过SCSI与IBM PC通信。 要使用该设备，需要一台配有英特尔80386处理器、2 MB内存和MS-DOS的 IBM PC/AT（或其兼容机）。

软件包包括链接器、汇编器和调试器。 应要求，任天堂还提供了**C 编译器**。 这意味着不再需要直接用汇编语言编写程序！ 总而言之，这套装置占用了您宝贵而又嘈杂的1.5 MB硬盘空间。

可惜的是，这种开发模式最终随着Game Boy Colour的发布而被淘汰。 我猜这是因为[Game Boy的CPU](game-boy#cpu)无法处理来自编译器的“未优化”代码。

### 存储介质

游戏卡带被称为Game Paks。 它们的名称与Game Boy的媒介相同，但在形状和功能上却完全不同。

![一款零售游戏的例子。](wario.jpg) {.open-float}

由于内存地址空间的原因，ROM的最大容量可达**16 MB**，无需映射器。 这也适用于外部RAM（最多16 MB）。 与Game Boy一样，它们也可以使用捆绑电池的SRAM。 卡带使用**16位数据总线**访问。

仔细想想，16 MB的ROM在90年代中期已经不少了。 毕竟，GB ROM的最大容量是128 KB！ (没有映射器）。 另一方面，别忘了这款游戏机使用的是32位地址，因此每个指针都有4字节长。 这是Game Boy地址长度（2字节）的两倍，因此需要更多空间。

{.close-float}

### 规定

出于安全考虑，任天堂指示开发商在游戏中加入一些图像，以减轻因屏幕时间过长而可能引起的眼睛疲劳和其他情况。

游戏必须包含“请阅读说明书”警告、对齐指南和自动暂停对话框。

![第一屏](rules/instructions.jpg){.tabs-nested .active .open-float .tab-float .pixel title="指示"}

![第二屏（只显示左眼的画面）](rules/align.jpg){.tab-nested title="对齐"}

![第三屏，此屏可交互](rules/pause.jpg){.tabs-nested-last title="自动暂停"}

这些屏幕将在游戏机开机后出现。 第一屏“命令”用户在继续操作前阅读使用说明书。

第二屏是某种“测试卡”，用来正确调整IPD刻度盘和对焦滑块。

第三屏询问用户是否希望每隔 30 分钟提醒他们休息一下。

{.close-float}

第一和第三屏通常是根据游戏主题定制的。

我认为任天堂在[Wii](wii#return-to-home)发布之前再也没有规定过这样的规则。

## 反盗版和自制游戏

事实上，任天堂创造了另一种不同的Game Pak，这让他们得以保留对销售的控制权。 不过，由于这款游戏机从未流行起来，盗版者可能根本不会去管它。

除此之外，这台游戏机没有实施任何防拷或锁区机制。 从美国和日本进口的游戏都可以在对方的机子上使用。 此外，如果有人愿意自己生产Game Paks，自制软件也是可能的。

据我所知，[烧录卡](game-boy-advance#flashcarts)理论上是可行的，但只有两款实现了商业化，即“FlashBoy Plus”和“Hyperflash32”（我不在这打广告！ 但我认为这些烧录卡值得一提）。

## 这就是全部了，伙计们。

![我弟弟在摆弄Virtual Boy。<br>他是用户研究小组仅存的成员😉](brother.jpg)

在这个系列中，我们看到了各种各样的系统，有些系统的CPU性能有限，但协同效应令人印象深刻；有些系统的硬件有问题，但包装精美。 然而，Virtual Boy这个案例是一个有趣的计划： CPU性能并不受限，显示芯片也能胜任工作。 音效并不出众，但仍与市场上的其他便携式游戏机相差无几。

那么，为什么没有多少孩子玩它呢？ 恐怕市场研究超出了本文的范围。 但从技术角度看，我认为是信息没有传递到位： 归根结底，如果你只能看到红点，那么没有人会关心仿射变换或流水线CPU。

我想，这就是我写这篇文章的主要动机，以某种方式证明创新技术可以无处不在，甚至在我们最意想不到的地方。

我还要感谢Planet Virtual Boy社区帮助我完成这项研究。 他们目前正在开展许多赋予Virtual Boy新生命的项目，我建议大家去他们的论坛看看，了解更多信息。

最后，这是“复古传奇”的最后一篇文章，下一篇文章将从PSP开始，回到（相对）现代的渲染器！

下篇文章见！  
Rodrigo
