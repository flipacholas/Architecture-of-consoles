---
short_title: Nintendo 64 架构
long_title: Nintendo 64 架构
name: Nintendo 64
release_date: 1996-06-23
date: 2019-09-12
generation: 5
subtitle: 一个受限的高性能
cover: nintendo64
javascript:
  - 'threejs'
seo_image_pos: "Top"
top_tabs:
  Model:
    caption: "Nintendo 64<br>1996年6月23日在日本 发布，1996年9月29日在美国发布，1997年1月3日在欧洲发布。"
    file: "international"
  Motherboard:
    caption: "展示的是“NUS-CPU-03”版主板。<br>后来减少了AV编码芯片的数量。<br>背面可以找到磁盘驱动器连接器"
  Diagram: { }
#Historical
aliases:
  - /projects/consoles/nintendo-64/
---

## 快速入门

任天堂的目标是给玩家提供可能的 *最好* 图形 为此它将与计算机图形的最大的玩家之一合作开发*终极* 图形芯片。

其结果是为大家设计了一个看起来很好的控制台... 以及一本500页的开发者手册。

别担心，我向你许诺这篇文章不会 *那么*长 好好享受吧!

## {.supporting-imagery}

## 中央处理器 (CPU)

Nintendo 64的主处理器的起源是 **MIPS R4000**, [MIPS](playstation#tab-1-2-mips-and-sony)的新型前卫CPU。 于1991年发布，R4000最明显的新颖之处是包含了 **64位能力**，这导致了总线、寄存器和计算单元的规模增加，以便有效地操纵64位数据。 另一方面，开发者通过新的 **MIPS III** 指令来访问这些能力。 总之，R4000使新的应用程序可以操纵更大的数据块，而不需要消耗额外的周期。

对于下一代主机，任天堂考虑将工业硬件引入家用主机。 与拥有大量内部组件且只需第二来源的MIPS的[Sony](playstation#cpu)不同，任天堂直接与MIPS（及许多图形工作站）的所有者合作，设计了他们的整个生态系统。 那家公司是**Silicon Graphics** (SGI)。

不管怎样，R4000是昂贵的产品(大约400美元 [@cpu-r4000demo])，这使得游戏主机不能使用它。 然而，任天堂不想放弃它最先进的产品， 这样他们就选择了一个来自NEC的叫做 **R4300i**的低端变体。

最终，任天堂和SGI选择的CPU变成了运行在**93.75 MHz** [@cpu-anatomy] 的**NEC VR4300**。 这是MIPS R4300i的二进制兼容版本，具有以下特性[@cpu-nec]：

- **两种工作模式**:
  - **32位模式**: CPU 表现得是一个MIPS II兼容处理器的传统模式。 这种模式没有什么特殊，只是所有新功能都被锁定。
  - **64位模式**: 所有64位扩展都可用的“原生”模式。 它也兼容32位应用程序。
- **32 个通用寄存器**: 它们在“32位模式”中位宽是32, “64位模式”中位宽是64。
- **MIPS III ISA**: 一个作为MIPS II 继承者的RISC 指令集。 它提供了名为 'doublewords'的新的opcode，可以计算64位数据。 最后，指令总是 **32位宽**, 独立于模式。
  - 值得一提的是，自从MIPS II以来， [负载延迟槽](playstation#delay-galore) 已经表现很好，但分支延迟仍然存在。
- 内部 **64 位总线** 连接到一个 **外部32 位数据总线**：尽管内部运行时，双词不会降低性能，CPU 仍然需要额外花费周期来从外部系统中处理64位的数据。
  - 这是R4300i的一处阉割(R4000有完整的64位数据总线)。
- **32位地址总线**: 最多可以寻址4GB的物理内存。
- **5级流水线**: 最多可以分配五个指令用于执行 (详细解释可见于 [前一篇文章](sega-saturn#cpu) ）。
- **24 KB L1 缓存**: 分为 16 KB 指令缓存与 8 KB 数据缓存。

在芯片内也有一个内置的 **浮点处理单元** (FPU) 。 VR4300将其确定为一个协处理器(CP1)。然而， 它安装在ALU旁，并且只能通过CPU的内部ALU流水线进行访问，这意味实际并不是作为协处理器使用的。 另一方面，FPU仍然有一个专用的寄存器并将加速操作64位和32位浮点数的指令执行速度。 最后，这个单元遵循IEEE754标准。

### 简化的内存访问

RAM 的组成方式依循 **统一内存架构** 或 'UMA' ，其中所有可用的 RAM 只集中在一个地方，任何需要RAM 的组件都会访问这个共享位置。 在这种情况下，决定其访问权限的组件是GPU。

之所以选择这种设计，是因为它节省了大量的生产成本。另一方面，如果不加以适当管理，将会导致内存访问冲突。

### 没有 DMA 控制器？

由于统一内存架构，CPU不再能直接访问内存，因此GPU也将提供DMA 功能。

### 内存设计

除了UMA以外，RAM 的结构有点复杂，因此我会试图保持简单。 让我们开始...

系统实际包含**4.5 MB 的内存**，但它使用了**9 位**数据总线连接，这个数据总线中为 GPU 保留了第 9 位（我将在“图形”部分中详细解释）。 因此，除GPU外，每个组件都只能寻址 ** 4 MB**。

![此系统的内存布局。 我假设CPU-RCP总线速度是RCP的时钟速度或CPU的时钟速度，但我还无法确认这一点。](memory.png)

安装在主板上的内存类型是**Rambus DRAM** (RDRAM) [@cpu-memory]，这只是与SDRAM竞争成为下一标准的另一种设计。 RDRAM使用 **串行连接** (一次传输一位) ，而SDRAM 则使用 **并行连接** (一次传输多个位)。

#### 延迟与速度

RDRAM 延迟与安装的内存芯片数量成正比 [@cpu-rdram]。 考虑到这个系统的内存容量，由此产生的延迟是很重要的（据报道大约是**640 纳秒** [@cpu-beyondrsp]）。 内存使用了**250 MHz**的高频率来补偿这个问题（比 CPU 快大约 2.6 倍）。 任天堂宣称RDRAM能够提供高达500MB每秒的连续读写速度。

此外，beyond3d论坛上的一些讨论声称任天堂选择在主板上使用NEC的uPD488170L内存芯片[@cpu-beyondrdram]。 这些芯片实现了一种叫做“Rambus Signaling Logic”的技术，这种技术使传输速率翻倍[@cpu-data]。 这可能解释了为什么一些信息源声明“有效”频率是500 MHz。

#### 改进空间

有趣的是，这台主机上可用的 RAM 大小**可以通过安装**扩展包**来增加**：一个外观奇特的小盒子，增加了另一个**4.5 MB**。 虽然这个配件对于一些游戏是可选的（大多数游戏没有使用它），但某些标题如《Donkey Kong 64》或《The Legend of Zelda: Majora's Mask》设计时要求使用扩展包，没有它会显示错误屏幕。

![扩展包 [@photography-amos]，一个单独出售的可选配件（有时随要求使用它的游戏一起提供）。](expansion_pak.png){.tabs-nested .active title="扩展"}

![跳线包[@photography-amos]。 在没有扩展包的情况下，必须安装它来终结RDRAM总线。](jumper_pak.png){.tabs-nested-last title="占位符"}

奇怪的是，内存总线必须被终结，所以控制台总是配备一个终端器（称为**跳线包**）安装在扩展包的位置。 现在，您可能会问，如果您在没有安装任何*包*的情况下打开主机，会发生什么情况？ **实际上什么都没有**，你得到了一个空白屏幕！

### 内存管理

VR4300 包括另一个被称为 **系统控制协处理器** (CP0) 的协处理器，它包含一个 **内存管理模块** (MMU) 和一个 **转换查找缓存器** (TLB), 前者处理如何组织和缓存内存。 VR4300可以寻址32位内存地址，最高4GB的内存，但我们已经看到， 我们在这个主机中没有 4 GB 的 RAM (即使在考虑了映射到内存的 I/O)。 因此，MMU接管内存寻址，并提供一个有用的内存映射，使得物理内存多次镜像。 因此，内存地址被视为“虚拟地址”(而不是“物理地址”)。 此外，TLB可以让开发者在某些镜像中定义他们自己的内存映射，而不会导致(重大的) 性能下降。

起初，这似乎是多余的，但每个镜像(称为“片段”)都连接到不同的电路（例如： L1 缓存、未缓存数据 、TLB 地址）这样开发人员可以根据需要选择最合适的部分以优化内存使用。

为了安全目的，有些区段区分了“内核”地址和“用户”地址。 N64总是以“内核”模式运行，因此“非TLB内核缓存”(称为“KSEG0”) 是游戏中最常见的部分。

MMU也可以在64位模式中工作，其中内存地址长度为40位。 这意味着虚拟地址空间包含 1 TB 值的地址... 但我认为Nintendo 64 不会利用这个特性！

## 图形

您在屏幕上看到的是由运行在**62 MHz**的**真实协处理器（RCP）**，一个由硅图设计的的巨大芯片生成的。 这个芯片包含*一大堆* 电路，所以如果你觉得难以理解，请不要担心，这个图形子系统有着非常复杂的架构！

这个设计基于GPU并不意味着像 [竞争者](playstation#graphics)一样是一个“简单的”光栅化器的哲学。 相反，它还应该能够<strong x-id=“1”>加速几何计算</strong>（将负载从CPU转移），为此，需要更多的电路。

### 架构

这个芯片分为三个主要模块，其中两个用于图形处理：

#### 真实信号处理器 {.tabs.active}

![真实信号处理器(RSP) 的架构。](RSP.png) {.tab-float}

也被称为 **RSP**, 它只是包含以下部件的另一个CPU ：

- **标量单元**：另一个MIPS R4000的削减衍生物。 这一次，它只实现了 MIPS III ISA的一部分，因而缺少许多普通用途功能（比如说中断和异常）、64位扩展、乘法与除法功能。
- **矢量单位**: 一个执行矢量操作并拥有32个128位寄存器的协处理器。 每个寄存器都被<em x-id=“3”>分为</em>八个部分，以一次操作八个16位矢量（就像传统CPU上的SIMD指令一样）。 正如您所看到的，这个组件为标量单元做一些繁重的任务。
- **系统控制器**: 另一个提供DMA 功能并控制其邻居模块RDP(稍后会介绍它)的协处理器 。

要操作此模块， CPU 在内存中存储一系列名为 **显示列表** 的命令以及将被操纵的数据， 然后RSP 读取列表并对数据应用所需的操作。 可用的特性包括几何变换(例如透视投影)、剪切与光照。

这似乎是直截了当的，但它是如何执行这些操作的？ 好的，这里是有趣的部分：与竞争者(PS1和Saturn)不同， **几何引擎不是硬连线的**。 相反， RSP 包含了一些存储 **微代码** [@audio_video-ultra]（一个不超过 1000 条指令的小型程序）的内存 (4KB 用于指令，4KB 用于数据) 来 **实现图形管线** 换言之，它指导标量单元如何操作我们的图形数据。 微代码在运行时由 CPU 提供。

任天堂提供了可以选择的不同微代码[@audio_video-microcode]，并且与 [SNES的背景模式](super-nintendo#graphics)相似，每个微代码都以不同地方式平衡资源。

#### 真实显示处理器 {.tab}

![真实显示处理器(RDP) 的架构](RDP.png) {.tab-float}

在RSP完成处理我们的多边形数据后，它将开始向下一个模块，**RDP**发送一个**光栅化命令**以绘制帧。 这些命令要么使用一个叫做 **XBUS** 的专用总线发送，要么通过主内存发送。

RDP是另一个处理器（这次具有固定功能），它包括多个引擎来光栅化矢量，将纹理映射到多边形上，混合颜色并组成新帧。

它可以处理 作为原始数据的**三角形** 或 **矩形** ，后者有助于绘制精灵。 RDP的光栅化管线包含以下模块：

- 一个**光栅化器**: 将由顶点组成的原始数据转换成像素。
- 一个**纹理单元**: 使用 4 KB 的专用内存(称为“TMEM”) 处理纹理，允许最多使用8个图块进行纹理处理。 它可以对它们执行以下操作：
  - <strong x-id=“1”>双线性过滤</strong>：将选定的2D纹理映射到3D形状上，并对其进行平滑，以避免产生像素化区域（由过采样引起）。
    - 但是，“完整”过滤器需要四个点才能进行插值。 这台主机只使用三个(**三角形插值**)，这导致了一些异常。 因此，某些材质必须事先“调整”。
  - <strong x-id=“1”>Mip Mapping</strong>：根据纹理的<strong x-id=“1”>详细程度，自动选择纹理的缩放版本</strong>。 这就避免了计算远离相机的大型材质，并防止了锯齿(欠采样的产物)。
    - 如果启用，RDP 将使用 **三线性过滤** 映射纹理图。 这种新算法还会在mipmap之间进行插值，以缓解细节程度的突然变化。
  - **透视校正**: 将纹理映射到三角形的选用算法。 与[其他逆映射算法](playstation#graphics)不同，该算法考虑了每个图元的深度值，从而获得更好的结果.
- 一个**彩色组合器**: 混合和插值多层颜色(例如应用阴影)。
- **混合器**：根据当前帧缓冲区混合像素以应用半透明、抗锯齿、雾、抖动。 它还执行Z缓冲(稍后会详细介绍)。
- 一个**内存接口**: 被前几个模块用来读取和写入当前内存帧缓冲区和/或填充TMEM。

RDP提供四种功能模式，每种模式将这些模块以不同方式组合，以优化特定操作。

由于这个模块不断更新帧缓冲区，它处理的内存非常不一样：还记住不寻常的 9 位 '字节' ？ 第九位用于与帧缓冲相关的计算(Z缓冲和抗锯齿)，并且只能通过内存接口操作。

#### 剩余步骤 {.tabs-close}

生成的帧必须发送到 **视频编码器** 以便在屏幕上显示。**DMA** 和 **视频接口** 组件是完成这个任务所必需的。

理论上最大可输出24位彩色深度（1680万种颜色）和640x480分辨率（或PAL区域中的720x576）。 我把它说成是“理论上的”，因为使用最大功能可能会使资源匮乏。 这样程序员趋向于使用较低的输出分辨率与色深来腾出足够的资源用于其他功能。

### 快速演示

让我们把先前的所有解释都放在正确的位置上来。 我会借助任天堂的 *超级马力欧64* 来展示如何生成一帧：

#### 顶点处理 {.tabs.active}

![我们场景的原始视图。 为了减少多边形数量，一些角色使用精灵 (四边形) 建模。](mario/wireframe.jpg) {.tab-float}

最初，我们的原料(3D模型等)位于卡带ROM中。 但要保持稳定的带宽，我们需要先将它们复制到内存中。 在某些情况下，数据可能会在卡带中被预先压缩，因此CPU在操作它们之前需要解压缩。

完成后，现在是时候使用我们的模型构建一个场景了。 CPU可以自行完成整个流水线, 但可能需要 *非常长的时间*， 所以许多任务交给了RCP。 CPU将转而向RCP发送命令。 这是通过执行以下任务来完成的：

1. 编写显示列表，其中包含将由RSP执行的操作，并存储在内存中。
2. 将RSP指向显示列表所在的位置。
3. 向RSP发送微代码以启动标量单元。

之后，RSP将开始执行第一批任务，结果将以光栅化命令的形式发送给RDP。

#### 像素处理 {.tab}

![渲染帧(_Tada!_)。](mario/result.png) {.tab-float}

到目前为止，我们成功地处理了数据并对其施加了一些影响，但我们仍需要：

- 渲染矢量，应用纹理和其他效果。
- 显示帧缓冲区

正如你可能猜测的那样，这些任务将由RDP执行。 要完成这项工作，必须使用DMA 将纹理从内存复制到 TMEM。

RDP 有一条固定的管线, 但我们可以根据当前的任务选择最佳的操作模式来提高帧率。

RDP 完成处理数据后，它将把最后的位图写入内存中的帧缓冲区。 此后，CPU必须将新帧传输到 **视频接口** (VI) ，最好使用DMA。 VI将依次将其发送到**视频编码器**进行显示。

### 设计 {.tabs-close}

以下是为新3D时代重新设计的以前[超级任天堂](super-nintendo)的2D角色的一些示例，它们是交互式的，因此我鼓励您查看它们！

![塞尔达传说：时之笛(1998年)：<br>704个三角形.](link_ocarina_64){.toleft model3d="true"}

![星之卡比64 (2000).<br>516个三角形.](kirby_cristals_64){.toright model3d="true"}

### 现代可见表面判定

如果您已经阅读过上一个主机的文章， 你遇到了关于[表面可见性的问题](sega-saturn#an-introduction-to-the-visibility-problem)，并且现在可能认为多边形排序是解决这一问题的唯一方法。 嗯，在本系列中，RDP首次采用了一种基于硬件的方法，称为**Z缓冲**。 简而言之，RDP在内存中分配一个名为**“Z缓冲区”**的额外缓冲区。 它具有与帧缓冲区相同的尺寸，但不存储RGB值，而存储相对于相机的最近像素的深度（Z值）。

当RDP光栅化矢量后，将新像素的z值与Z缓冲区中的相应值进行比较。 如果新像素包含较小的z值，则意味着新像素位于前一个像素的前面，因此它将进入帧缓冲区，Z缓冲区也将更新。 否则，像素将被丢弃。

总的来说，这是一个非常受欢迎的补充：程序员无需再担心实现[基于软件的](playstation#tab-4-2-visibility-approach)多边形排序方法，而这会消耗大量CPU资源。 但是，Z缓冲并不能避免您输入不必要的几何体（被丢弃或被过度使用，这两者都会消耗资源）。 为此，游戏引擎可能会选择包含一种<strong x-id=“1”>遮挡剔除</strong>算法，以尽早丢弃不可见的几何体。

### 秘密和限制

硅图（SGI）显然在这一系统中投入了大量技术。 尽管如此，这是一个家用游戏机，因此，它必须降低成本。 一些艰难的决定给程序员带来了困难的挑战：

#### 流水线暂停 {.tabs.active}

由于图形管线中有大量的组件和操作，RCP最终非常容易发生<strong x-id=“1”>暂停</strong>：在不理想的情况下，所需数据在流水线后级延误，因此子组件在相当长的时间内保持空闲。

这将总会导致性能下降，由程序员来避免这种情况。 尽管为了简化操作，一些计算单元（如标量单元）引入了一个名为**绕过**的功能，该功能可以绕过一些可以跳过的执行阶段，以更快的速度执行类似的指令。

例如，如果我们必须计算多个`ADD`指令，则无需将结果写回寄存器，然后在每次完成`ADD`时将其读回。 相反，我们可以对所有加法运算使用相同的寄存器，并在最后一个`ADD`完成后进行写回。

#### 纹理内存 {.tab}

RDP依赖4KB的TMEM（纹理内存）作为加载纹理的单一来源。 不幸的是，实际上4KB对于高分辨率纹理来说是不够的。 此外，如果使用mipmapping，则可用内存量将减少到原来的一半。

因此，一些游戏使用了带有高洛德描影的纯色（如<em x-id=“3”>超级马力欧64</em>），而其他游戏则依赖于预先计算的纹理（例如，必须预先混合多层纹理）。

### 通用视频输出 {.tabs-close}

任天堂继续使用和上一台主机一样的 '通用' [Multi Out](super-nintendo.md#a-convenient-video-out) 端口，但坏消息是它**不再携带RGB 信号！** 在我看来，这是另一种节省成本的措施，因为以前的主机中没有使用RGB。

好消息是，通过焊接一些电缆和安装一个廉价的信号放大器，仍然可以让最初的版本输出RGB。 这是因为视频数模转换器将RGB信号传输到视频编码器。 然而，后来的主板版本将这两种芯片结合在一起，所以剩下的唯一选择是完全绕过视频DAC和编码器，使用自定义电路来产生RGB信号。

## 音频

在详细介绍之前，我们先定义N64音频子系统的两个端点：

- 我们的起点是卡带ROM，它包含只有CPU才能理解的数据。
- 终点是 **数模转换器** 或 'DAC' ，它只理解 *波形数据*。

现在，我们如何连接两端？ 主机通常包括为我们服务的专用音频芯片。 不幸的是，Nintendo 64<strong x-id=“1”>没有这样的专用芯片</strong>，因此该任务分布在以下组件中：

- **主CPU**: 将音频数据从游戏的ROM传输到内存. 然后初始化将被RSP使用的**音频列表** 。
- **RSP**: 通过使用更多的微码，它解释先前存储在内存中的音频列表，并对音频数据执行所需的操作，例如，可以包括：
  - 解压缩 **ADPCM 采样** 并应用效果。
  - 使用存储在内存中的**音频库对**对**MIDI数据**进行播放和混音。

正如预期的那样，得到的是波形数据。 然后将其发送至<strong x-id=“1”>音频接口</strong>或“AI”模块，然后将其传输至数模转换器。 生成的波形包含两个通道（因为我们的系统是立体声的），每个通道具有16位分辨率。

![音频流水线一般是如何编程的。](Audio.png)

### 曲目

是时候检查为N64制作的音轨了。 有太多（好的音轨）需要在这篇文章中提及，所以这里是一些引起我注意的：

![塞尔达传说：魔吉拉的面具 (2000年)。<br>这个游戏的音乐与它令人畏惧的气氛密不可分。。](observatory){.toleft video="true"}

![Bomberman Hero (1998年)：<br>这款游戏有漂亮而独特的室内配乐。](redial){.toright video="true"}

### 秘密和限制

由于这种设计，限制将取决于实现方式：

- 采样率可以达到**44.1 kHz**，但使用最大采样率会占用大量CPU周期。
- 音频声道数量没有严格限制，这完全取决于RSP能够混合多少（如果处理ADPCM，通常为16-24个声道，如果处理PCM，则为大约100个声道）。
- 内存是另一个问题，而竞争对手依赖更大的介质（例如 CD-ROM) 和专用音频内存，Nintendo 64卡带可以容纳的数据要少得多（更不用说音乐数据了），而且必须与其他组件共享内存。

因为这些原因，玩家可能会注意到N64版游戏含有质量较低的音乐或重复乐谱。 尽管一个常见的解决方法是实现一个音乐音序器，该音序器在运行时使用预先填充的一组声音（类似于MIDI音乐）“构造”采样。

## 操作系统

与PS1和Saturn相似，N64游戏是为裸机编写的。 但是，没有可用的BIOS调用来简化某些操作。 作为替代，**游戏嵌入了小型操作系统**，它提供了大量的抽象层来有效处理CPU、GPU和I/O。

这不是我们最初想象的传统 *桌面操作系统*，它只是一个占据最小空间的微内核，提供以下功能：

- 使用消息传递的多线程（不要忘记CPU是单核的）。
- 调度和抢占。
- 简化的寄存器和I/O访问。

总而言之，这些功能对于组织需要同时工作的音频、视频和游戏逻辑任务至关重要。

内核通过使用任天堂的库自动嵌入。 此外，如果程序员决定不包含其中一个库，内核的相应部分将被剥离，以避免卡带空间被浪费。

### 启动过程

与以前的卡带系统不同， Nintendo 64 遵循复杂的引导过程，在实际游戏运行之前准备好所有硬件。 用户一打开主机就执行此操作，这与基于CD的同时代产品捆绑[BIOS](playstation#operating-system)或[IPL](sega-saturn#operating-system)非常相似。

这些例程也称为**初始程序加载**（IPL），工作方式如下\[@operating_system-ipl\] \[@operating_system-ipl_decomp\]：

1. 用户打开主机。
2. **PIF-NUS** (主板上的一个单独芯片) 将主CPU置于无限重置状态，直到PIF-NUS验证游戏卡带中的CIC芯片。
    - PIF-NUS和CIC芯片将在I/O和反盗版部分分别进一步介绍。
2. 如果验证进程成功完成，CPU将在`0xBFC00000`处开始运行。 此地址指向PIF-NUS的一个**内部ROM** ，准确来说是名为<strong x-id=“1”>IPL1</strong>的第一个引导阶段。
3. IPL1初始化部分硬件（CPU寄存器、并行接口和RCP），并将下一阶段（<strong x-id=“1”>IPL2</strong>）从内部ROM复制到RSP的内存，以加快执行速度。 然后，它将执行重定向到那里。
4. IPL2 将游戏 ROM 的前一兆字节复制到 RSP 内存中，验证它（使用 PIF）并执行它。 这一部分包含下一个启动阶段，名为 **IPL3**。
5. IPL3初始化RDRAM和CPU缓存。 然后，它启动操作系统（即虚拟内存和异常向量），设置程序状态（即堆栈指针），最后继续调用游戏的启动例程。

由于IPL3位于游戏卡带中，并非每个游戏都捆绑了相同的代码。 据推测，这些变体与在卡带中捆绑的CIC芯片变体有关。

## I/O

正如您现在所知，I/O没有直接连接到CPU，因此RCP的第三个模块（我现在还没有提到）用作 **I/O接口**，这是处理与CPU、手柄、游戏卡带和音频/视频DAC通信的模块。

### 配件

Nintendo 64 手柄包含用于插入配件的连接器。 商业配件的示例包括：

- **手柄包**: 另一个储存介质(类似于索尼的*内存卡*) 用于存储保存数据并与其他主机共享。
- **震动包**: 包含一个小马达，用于提供触觉反馈，有助于玩家“沉浸”在某些游戏中。

所有连接到手柄的配件都由 **PIF-NUS**管理，这个模块也处理安全问题。 RCP 使用 "非常慢" (编程手册所说) 的 **串行总线** 与PIF通信。

## 游戏

任天堂坚持使用卡带用于储存，而不是改用光盘。 因此，游戏拥有更高的数据传输带宽（根据任天堂的数据，平均为5 MB/秒），同时生产成本也更高。 市场上发现的最大的卡带有64 MB。

在卡带中，制造商可能会包含额外的内存（以*EEPROM*、*闪存*或带有电池的*SRAM*的形式）来保存存档。 虽然这不再是一项强制要求，因为某些配件也可以用来储存存档。

卡带使用名为 **“并行总线”**（PBUS）或“并行接口”（PI）的专用16位总线与RCP通信。

### 软件开发工具包（Sdk）

一般来说，游戏开发主要使用<strong x-id=“1”>C</strong>和<strong x-id=“1”>汇编</strong>，通常需要后者才能获得更好的性能。 虽然我们已经看到这个系统提供了64位操作，但很少使用新的指令，因为实际上，32位指令的执行速度更快（由于R4300i/VR4300带有32位数据总线）。

官方SDK中的库含有若干抽象层，用于指挥RCP。 例如，像**图形二进制接口**或“GBI”这样的C结构被设计用来更轻松地组装必要的显示列表。 同样适用于音频功能（其结构体称为**音频二进制接口**或“ABI”）。

在微代码开发方面，任天堂已经提供了一套微代码方案供选择。 然而，如果开发人员想要定制它，这确实是一项具有挑战性的任务：标量单元的指令集最初没有文档记录，但后来任天堂改变了立场，SGI最终发布了一些微代码编程文档。

![我在 2024 年 8 月访问英国剑桥的计算历史中心时发现的 SGI Indy。 相比之下，这台计算机使用 MIPS R4400 CPU，是 R4000 的改进继承者（总的来说，远远领先于 VR4300）。](sgi_indy.webp)

用于开发的硬件包括 SGI [@games-devkit] 提供的工作站，例如**Indy** 机器，它捆绑了一个额外的子板，称为**U64**，其中包含零售主机的硬件和 I/O。 他们还为Windows计算机提供了工具[@games-u64]。

其他第三方工具包括自定义卡带，带有连接到工作站的长条带电缆。 这种卡带安装在零售Nintendo 64中，但包括将“读取”请求从主机重定向到工作站内存的内部电路。 部署/调试过程是通过将游戏副本传输到内存来执行的，然后当主机打开时，它将从那里开始读取。

### 其它存储介质

此外，PBUS分支到N64主板底部的另一个连接器。 这意味着尚未发行的<strong x-id=“1”>Nintendo 64 Disk Drive</strong>（64DD）将使用它，这是一种包含专有磁盘驱动器[@games dd] 的“额外楼层”。 其磁盘可提供多达64MB的容量。 虽然只在日本发行，但磁盘驱动器为发行游戏打开了另一种（更便宜）媒介的大门。

![Nintendo 64 Disk Drive[@simply-amos]。<br>于1999年12月1日在日本发布。](64dd/module.png){.open-float .tabs-nested .tab-float .active title="模块"}

![安装在主机上的64DD [@simply-amos]。](64dd/attached.png){.tabs-nested-last title="安装好"}

磁性介质比卡带慢，传输速度高达1 MB/秒，但仍比4倍速CD-ROM光驱快。 磁盘是双面的，以“恒定角速度”运行（和后来的<a href=“gamecube#medium”>miniDVD</a>一样）。 最小的可读区域称为“块”，它是同心圆的一半。

这个驱动器中没有**缓存内存**，因此读取的位存储在RDRAM中以供执行。 为了应对增加的内存需求，任天堂还在64DD中包含了RAM扩展包。 这样做也标准化了扩展的RAM空间，因此所有64DD游戏都能利用它。

{.close-float}

此外，磁盘的一部分可重写以便存储存档， 可写区域的数量取决于所使用的磁盘类型(任天堂提供了7种类型)。 在软件方面，游戏数据由任天堂的SDK提供的名为“多文件系统”（MFS）的文件系统构成。 游戏既可以使用文件系统访问磁盘数据，也可以逐块访问磁盘数据。后者依赖于另一个名为“Leo”的库来实现低级功能。

磁盘驱动器还包含一个内部ROM（称为“DDROM”），用于存储N64执行的代码，以引导磁盘并显示启动动画。 这是一个新的 IPL 阶段，添加到传统的引导过程之上。 ROM还存储字体（拉丁字母和日文汉字）和一些声音。 ROM仅在零售版中存在，因为开发版依赖于通过开发工具包加载的外部程序。

## 反盗版/锁区

反盗版系统是[SNES的CIC](super-nintendo.md#anti-piracy--region-lock)的延续。 正如您所知，由于CIC芯片（必须存在于每一个*授权的*卡带中）[@anti_piracy-CIC]，盗版检测和锁区是可能的，Nintendo 64通过要求不同的游戏具有特定的CIC芯片变体来改进该系统。 这可以确保卡带不是伪造的，或含有克隆CIC芯片。 PIF在开始时和游戏期间执行校验和检查，以监督安装在卡带上的当前CIC。

如果出于任何原因，PIF认为目前的卡带无效，那么它就会使主机永久冻结。

锁区是通过在不同区域之间略微改变卡带的形状来进行的，这样用户就不能将游戏插入到不同区域的N64上。

总的来说，尽管游戏价格比基于CD介质的游戏高出三倍，但由于使用了卡带介质，人们不太担忧盗版。

### 未使用的端口

尽管看起来很傻，任天堂还是打开了一扇门：**磁盘驱动器端口**。

![安装在主机上的博士 V64 [@simply-amos]。](v64/attached.png){.open-float .tabs-nested .tab-float .active title="已安装好"}

![V64的背面[@simply-amos]，展示了一些有趣的A/V接口。](v64/back.png){.tabs-nested-last title="背面"}

一些公司对接口进行了反向工程，以开发自己的硬件，由此产生的一些产品有涉嫌盗版的可能。

我想值得一提的是**博士 v64**，该设备与磁盘驱动器形状相同，但包含CD-ROM驱动器。

这个扩展可以将卡带的数据写入到CD, 反过来(从CD中读取ROM文件) 也是可行的。

{.close-float}

### 模拟

当我还是个孩子的时候，我曾经用模拟器在奔腾II机器上玩过一些N64游戏，它并不是那么 *糟糕*，但在后来的几年里，我想知道*究竟*是如何能够愉快地模拟复杂的64位机器的，因为除了其他问题以外，我的电脑几乎没有足够的内存来运行集成视频。

事实是，虽然再现这个主机的架构可能很复杂，但像微代码这样的东西会提示控制台正在尝试做什么，而且由于模拟器*不必*周期精确，因此它们可以应用足够的优化来提供更高的性能，以让模拟可以运行。

另一个原因是64位指令，因为游戏几乎没有使用它们，使用32位宿主机运行时几乎不会碰到任何模拟速度问题。

## 这就是全部了，伙计们。

![我共享了一台在朋友家的N64<br>虽然我只想要一台主机来写文章，但我的朋友总是想要N64 DD，所以我们一起购买了一套完整（但昂贵）的日本N64 DD套件，以避免单独花费过多。 然后我安装了N64RGB，这样我们就可以将其连接上现代电视；结果是一个很好的娱乐方式（和讨论话题！）。](n64.jpeg)

我不得不说，这篇文章可能是我写过的最长的一篇，但希望你认为这篇文章写的很好！

我可能会在接下来的几天里在网站上整理一些东西，而不是开始写下一篇文章。

下篇文章见！  
Rodrigo
