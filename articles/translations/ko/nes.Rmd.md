---
long_title: "닌텐도 엔터테인먼트 시스템 (NES)의 아키텍처"
short_title: "닌텐도 엔터테인먼트 시스템 (NES) 아키텍처"
name: NES
long_name: 닌텐도 엔터테인먼트 시스템 (NES)
subtitle: 6502 이상의 칩
date: 2019-01-25
release_date: 1983-07-15
generation: 3
cover: nes
top_tabs:
  Models:
    - 
      title: "국제"
      file: international
      caption: "NES.<br>미국 1985년 10월 18일, 유럽 1986년 9월 1일 출시."
      active: true
    - 
      title: "일본"
      file: japanese
      caption: "패미컴<br>일본 1983년 7월 15일 출시."
  Motherboard:
    caption: "'NES' 변형을 보여줍니다."
  Diagram: { }
#Historical
aliases:
  - /projects/consoles/nes
---

## 개요

언뜻 보면 NES는 정교한 케이스와 컨트롤러가 있는 또 다른 6502 컴퓨터처럼 보입니다.

*기술적으로는* 사실이지만 CPU가 이 시스템의 *중심*이 아닌 이유를 알려드리겠습니다.

## {.supporting-imagery}

## 모델과 변형

![전형적인 Betamax 녹화기. 이와 유사한 기기는 NES의 국제 디자인에 영향을 미쳤습니다. 특정한 것을 2024년 8월에 방문했을 때 케임브리지(영국)에 있는 컴퓨팅 히스토리 센터(The Centre for Computing History)에서 발견했습니다.](betacord.webp)

닌텐도는 전 세계 여러 지역에 동일한 콘솔의 다양한 변형을 출시했습니다[@general-variants]. 모든 변형이 동일한 아키텍처를 공유하지만, 외관이 매우 다르며 일부는 내장된 액세서리를 포함할 수 있습니다. 그래서 이 기사에서는 두 가지 가장 인기 있는 리비전을 중심으로 설명하겠습니다:

- **패밀리 컴퓨터** (일본에서 _패미컴_으로 알려짐)는 첫 번째 버전이었지만, 일본에서만 출시되었습니다. 이 장난감 같은 디자인은 두 개의 분리할 수 없는 컨트롤러(두 번째 컨트롤러에는 내부 마이크가 포함되어 있음), 라이트 건을 위한 전면 소켓(_Zapper_라 불림), RF 비디오 출력(NTSC-J 신호 사용) 및 오디오 기능을 확장하기 위한 카트리지 슬롯에 추가 핀을 특징으로 한다.
- **닌텐도 엔터테인먼트 시스템** (약칭 _NES_)은 북미, 유럽, 오세아니아에서 생활하는 서양 관객들을 위해 재설계된 판본이었습니다. 일반적인 VHS/베타맥스 플레이어와 일치하는 외관과 메커니즘을 가지고 있습니다. 기술적인 측면에서는 컨트롤러가 이제 분리 가능해졌고(마이크가 없음), 비디오 출력이 추가적인 NTSC/PAL 컴포지트 RCA 커넥터와 함께 개선되었습니다. 그러나 오디오 확장은 불법 복제 방지 하위 시스템으로 대체되었습니다. 마지막으로, 케이스 하단에는 확장 포트가 봉인되어 있으며, 그 포트와 통신하는 추가 카트리지 핀이 함께 있습니다[@general-cartridge].

'NES'라는 이름이 익숙해서 일반적으로 그 용어를 사용할 것이지만, 일본판에만 있는 독특한 기능을 언급할 때는 '패미컴'이라는 이름을 사용할 것입니다.

## CPU

NES의 CPU는 널리 사용됬던 8비트 **모스 테크놀로지 6502**에 기반을 둔 **리코 2A03** [@cpu-cpu]이며 **1.79 MHz** (또는 PAL 시스템에서 1.66 MHz) 로 작동합니다.

### 약간의 설명

70년대 후반과 80년대 초반 CPU 시장은 상당히 다양했었습니다.

::: {.subfigures .side-by-side}

![6502 CPU를 탑재한 Commodore PET.](pet.webp) {.toleft}

![Z80 CPU를 탑재한 Tandy TRS-80.](tandy.webp) {.toright}

컴퓨팅 역사 센터가 제공한 70년대 후반 컴퓨터의 파노라마(영국, 케임브리지).

:::

회사에서 원하는 마이크로컴퓨터를 만들고자 한다면 다음과 같은 옵션을 선택할 수 있었습니다.

- <string x-id="1">인텔 8080</strong>: 최초의 '개인용' 컴퓨터(PC)인 *Altair*에 탑재된 인기 있는 CPU. 8비트 데이터 버스와 16비트 주소 버스가 있습니다.
- **자일로그 Z80**: 8080의 '비공식' 버전으로 더 많은 명령어, 레지스터 및 내부 구성요소의 성능 향상이 있었습니다. 게다가 8080의 프로그램을 실행할 수 있으면서도 더 싼 가격에 팔렸습니다[@cpu-re_1977, p. 86]. 특히 암스트래드사와 Sinclair사가 이 CPU를 사용했습니다.
- **모토로라 6800**: 모토로라가 디자인한 또 다른 8비트 CPU로, 완전히 다른 명령어 세트를 포함하고 있습니다. 많은 DIY 컴퓨터 키트, 신시사이저, 일체형 컴퓨터들이 6800을 사용했었습니다.

이러한 옵션으로는 충분하지 않아서, **모스 테크놀로지**사에서 6800의 재설계 버전인 **6502**을 출시하고 나왔습니다. 다른 칩들과 호환되지 않지만, 이 새로운 칩은 생산비용이 *훨씬* 저렴했고, 가장 유명한 컴퓨터 제조업체(코모도어, Tandy, 애플, 아타리, 에이콘 등)가 6502를 선택하여 컴퓨터에 공급하는 것은 시간문제였습니다.

일본에선 닌텐도 가격이 비싸진 않았지만 개발하기 익숙한 6502를 선택했습니다. 그리고 그들의 CPU 공급업체인 **리코**는 성공적으로 6502 호환 CPU를 생산해냈습니다.

#### 리코의 라이선스 수수께끼

리코가 *어떻게* 6502를 복제할 수 있었는지는 오늘날까지 분명하지 않습니다. 모스 테크놀로지사에서 리코에게 칩 디자인 라이선스를 주었다고 생각할 수도 있지만, 이렇다고 한다면 모순이 생깁니다.

- 리코와 모스 테크놀로지사의 버전은 동일한 레이아웃을 특징으로 하지만 리코의 버전은 절단된 버스가 포함되어 있습니다(특정 기능을 비활성화함) [@cpu-differences]. 이 점은 나중에 더 자세히 설명하겠습니다.
- 모스 테크놀로지가 리코에게 6502의 라이선스를 주었다는 것을 명시하는 문서는 아직까지도 발견되지 않았습니다.
- 닛케이 트랜디에서 2008년에 발표한 기사에 따르면 리코는 공인 칩 제조업체인 록웰로부터 라이선스를 받았다고 합니다[@cpu-trendi]. 그러나 록웰이 제3자에게 IP를 제공하는데 모스사의 승인이 있었는지에 대한 논란의 여지가 있습니다.
- *이케가미 쓰신키 대 닌텐도* 판결에서 닌텐도가 원래 동키콩의 코드를 소유하지 않았다고 일본에서 판결했기 때문에 닌텐도가 IP 권리를 회피한 것은 처음이 아닐 것입니다[@cpu-dk].

#### 없어진 기능들

리코 2A03은 원래 6502에 있던 **이진화 십진법** (Binary-coded decimal, BCD) 모드를 생략했습니다[@cpu-visualbcd]. BCD는 이진수 네 자리를 묶어 십진수 한 자리로 사용하는 기수법입니다. 6502는 8비트를 '워드'로 사용합니다. 즉, 각 워드는 십진수 두 자리를 저장할 수 있습니다.

예를 들면, 십진수 `42`는 다음과 같이 표현됩니다.

- `0010 1010` : 2진수로 표현.
- `0100 0010` : BCD로 표현

이것에 대해서 계속 설명해 드리겠습니다. 짧게 말해서, BCD는 각 십진수 숫자를 개별적으로 처리해야 하는 응용 프로그램에 유용합니다. (예: 디지털 시계). 그러나 각 8비트 워드가 십진수로 `99`까지만 인코딩할 수 있기 때문에 더 많은 저장공간이 필요합니다. (반면 기존 2진수는 `255`까지 인코딩할 수 있습니다).

어쩄든, 리코는 의도적으로 그 칩에서 BCD 모드를 작동시키는 제어라인을 분리하므로써 기능을 없애버렸습니다. 아마도 BCD가 MOS에 의해 특허를 받았기 때문에 로열티를 지불하지 않기 위해 수행되었습니다 (미국에서 집적 회로 설계를 저작권으로 보호할 수 있게 한 법률은 1984년까지 제정되지 않음) [@cpu-protection_act].

### 메모리

리코 2A03과 모스 6502는 모두 **8-비트 데이터 버스**와 **16-비트 주소 버스**를 특징으로 하여 최대 **64 KB의 메모리**에 접근할 수 있습니다. 그래서 닌텐도는 그 메모리 공간을 어떻게 채웠을까요?

한쪽 면에는 **2 KB의 정적 RAM** (SRAM) [@cpu-sample_ram]을 제공하는 칩이 있습니다. 닌텐도는 이 영역을 '작업 RAM' (WRAM)이라고 부르며, 다음을 저장하는 데 사용할 수 있습니다:

- 게임 상태를 처리하거나 정보를 조회하는 변수를 저장합니다.
- CPU가 서브 루틴을 실행할 때 레지스터 값을 임시로 저장하는 '스택'.
- CPU가 두 위치 간에 큰 데이터를 복사할 수 있도록 하는 '버퍼 영역'.

다른 한편으로 시스템의 구성 요소는 **메모리 맵핑**됩니다[@cpu-cpu_map]. 즉, 메모리 주소를 사용하여 액세스되므로 CPU의 주소 공간의 일부를 차지합니다. 따라서 CPU의 메모리 공간은 게임 카트리지, WRAM, PPU, APU 및 두 개의 컨트롤러를 가리키는 주소들로 채워집니다(각 구성 요소에 대한 설명은 이 기사 전반에 걸쳐 다루어질 것입니다).

#### 카트리지/게임 데이터

아시다시피 NES 게임은 카트리지 형태로 배포되며, 카트리지의 버스는 CPU에 직접 연결됩니다.

닌텐도는 게임 카트리지 데이터 중 49120 바이트(~49.97 KB)만 접근할 수 있도록 배선했습니다 [@cpu-cpu_map]. '카트리지 데이터'가 무엇을 의미하는 걸까요? 음, 예를 들어, 그 버스에 연결된 모든 칩들:

- 게임 프로그램이 저장된 **프로그램 롬**. '그래픽' 섹션에서 나중에 보실 수 있듯이 그래픽 데이터는 제외됩니다. 다른 칩들과 달리, 이것은 필수입니다.
- WRAM을 확장하기 위한 **램 칩**.
- 저장을 위한 **배터리가 포함된 램 칩**.

다른 조합이 있는 이유는 CPU가 어떤 구성 요소에서 데이터를 읽는지 신경 쓰지 않고, 단지 메모리 위치를 보기 때문입니다. 따라서 게임 스튜디오가 그들의 게임에 맞는 실현 가능한 레이아웃을 선택하거나 고안하는 것은 그들의 몫입니다.

![슈퍼 마리오 브라더스의 PCB[@photography-nrom].](nrom.png){.tabs-nested .active title="Original"}

![중요 부품이 라벨링된 동일한 PCB. '락아웃' 칩의 의미는 '안티-피라시' 섹션에 설명되어 있습니다.](nrom_marked.png){.tabs-nested-last title="Marked"}

예를 들어, 닌텐도의 '슈퍼 마리오 브라더스'는 _NES-NROM-256_ 레이아웃을 사용하며, 이는 32 KB의 프로그램 ROM과 그래픽을 위한 8 KB의 '캐릭터 ROM'으로 구성되어 있습니다 (그래픽 섹션에서 이에 대해 더 자세히 다룰 예정입니다) [@cpu-nrom]. _NES-NROM-256_은 최대 3 KB의 추가 WRAM을 수용할 준비가 되어 있지만, 게임에서는 이를 사용하지 않습니다.

#### 기존 기능을 넘어서기

16비트 주소 버스의 큰 제한 사항 중 하나는 (3세대 및 4세대 콘솔에 영향을 미치는) 작은 주소 공간입니다. 현재 32비트 컴퓨터는 최대 4GB의 메모리를 주소 지정할 수 있으며 (64비트 컴퓨터는 최대 16엑사바이트까지 가능) 이는 더 이상 문제가 되지 않지만, 당시 NES는 64 KB의 주소 공간만 가지고 있었으며, 그 많은 부분이 메모리 매핑 하드웨어에 의해 소비되었습니다 (이 점은 [경쟁작들이 피한](master-system#accessing-the-rest-of-the-components) 것이었습니다).

그러면 이것이 게임 스튜디오가 49.97 KB의 한도를 초과하지 않는 게임만 개발할 수 있다는 의미인가요? 절대 그렇지 않습니다! 역사가 우리에게 가르쳐준 것이 있다면, 도전적인 문제에 항상 영리한 해결책이 있다는 것입니다. 이 문제는 **매퍼**를 사용하여 해결되었습니다.

![매퍼가 CPU의 주소 지정 기능을 확장하는 방법의 단순화된 표현입니다. 매퍼가 포함되면 CPU는 큰 프로그램 ROM의 추가 뱅크(주소 그룹)에 접근할 수 있습니다. 게임/프로그램이 필요할 때마다 뱅크 간 수동 전환이라는 새 작업을 수행해야 합니다.](mapper/mapper.png){.tabs-nested .active title="매퍼 포함"}

![매퍼가 설치되지 않은 동일한 설정입니다. 더 단순하고 저렴하지만, CPU는 유한한 수의 뱅크에만 접근할 수 있습니다.](mapper/no_mapper.png){.tabs-nested-last title="매퍼 없이"}

매퍼는 메모리 칩과 콘솔의 주소 라인 사이에 위치한 추가 칩으로 카트리지에 포함됩니다. 그 주요 작업은 주소 공간을 확장하여 개발자가 더 많은 칩을 맞출 수 있도록 하는 것입니다. 이것은 **뱅크 전환**을 통해 이루어집니다: 메모리 주소는 뱅크로 그룹화되며, 매퍼는 뱅크 간 전환을 제어할 수 있는 스위치를 제공합니다(메모리 주소를 통해 제어됩니다). 이제 CPU는 여전히 동일한 양의 메모리를 보지만, 매퍼가 있는 게임이 이를 작동하도록 프로그래밍되어 있습니다. 경제성 덕분에 매퍼는 80년대 중반부터 90년대 초반까지 기술의 필수품이었습니다.

![슈퍼 마리오 브라더스 2의 PCB [@photography-tsrom]. 슈퍼 마리오 브라더스 3도 이 레이아웃을 사용하지만, 256KB 프로그램 ROM을 함께 번들합니다.](tsrom.png){.tabs-nested .active title="원본"}

![중요한 부품들이 표시된 같은 사진. 처음에는 추가 WRAM이 저장 공간을 위해 있다고 생각했지만, 이 게임에는 저장 기능이 없다는 것을 깨달았습니다 (그리고 배터리도 없습니다). 실제로, 그 RAM 칩은 압축 해제된 레벨을 저장하는 데 사용됩니다.](tsrom_marked.png){.tabs-nested-last title="표시됨"}

닌텐도에서 만든 'MMC3' 매퍼와 함께한 카트리지와 함께 'Super Mario Bros 2'와 'Super Mario Bros 3' 게임이 NES로 돌아왔습니다. 비교를 위해, MMC3는 프로그램 ROM에 최대 512 KB, 캐릭터 메모리에 최대 256 KB, 추가 WRAM에 최대 8 KB를 제공합니다 [@cpu-mmc3]. 이제 '슈퍼 마리오 브라더스 3'가 첫 번째 시리즈와 비교하여 품질이 크게 다른 이유를 이해할 수 있을 것입니다.

총체적으로, 이 콘솔의 내부 기능을 살펴보면 제한된 것처럼 보일 수 있지만, 닌텐도는 기술이 발전함에 따라 적응할 수 있도록 했습니다. 반면, 이 기술은 콘솔의 비용을 절감하는 데 도움이 되었지만, 일부 부담을 게임 카트리지로 전환했습니다. 따라서 게임 품질과 카트리지 비용은 게임 스튜디오가 균형을 맞춰야 하는 두 가지 관심사였습니다.

## 그래픽

그래픽은 **PPU(Picture Processing Unit)** 라고 불리는 전용 칩에 의해 생성됩니다. 이것은 NES에 *정체성*을 부여하는 칩 중 하나입니다. 다시 말해, 누구나 하드웨어 스토어에서 6502 CPU를 구할 수 있으므로, NES가 예를 들어 Apple 2나 Commodore 64와 어떻게 다른가요? NES를 다른 기기와 구별해주는 것은 CPU 주변의 칩입니다: PPU와 APU입니다. 이들은 각각 NES의 고유한 그래픽 및 오디오 기능을 구성합니다.

즉, PPU는 **스프라이트**와 **백그라운드**라고 불리는 2D 그래픽을 렌더링하여 비디오 신호에 출력을 발생시킵니다.

### 콘텐츠 정리

![PPU의 메모리 아키텍처](ppu_content.png)

무언가를 화면에 렌더링하려면, PPU는 *어떤* 그래픽을 그릴지, *어디에* 배치할지, *어떻게* 그릴지 (즉, 어떤 팔레트를 사용할지)를 알아야 합니다.

이 질문에 답하기 위해, PPU는 특정 유형의 데이터를 찾는 다른 메모리 맵으로 사전 프로그래밍되어 있습니다.

- 그래픽 데이터는 게임 카트리지에서 가져오며, 이 카트리지는 **문자 메모리**라는 전용 칩을 포함하고 있으며, 이 칩은 **패턴 테이블**이라는 데이터 구조에 조직된 2D 도면 (**타일**이라고 함)을 저장합니다. 문자 메모리는 게임이 불변의 그래픽 세트를 포함하는지 또는 CPU가 개입해야 하는지에 따라 '읽기 전용 메모리' (ROM) 또는 '램덤 액세스 메모리' (RAM) 형태로 구체화됩니다.
  - PPU는 **최대 8 KB**의 캐릭터 메모리를 두 개의 4 KB 그룹으로 구성하여 주소 지정합니다.
- PPU에게 그래픽을 '어디에', '어떻게' 그릴지를 알려주는 메타 데이터는 다른 영역에 있습니다:
  - 별도의 **2 KB의 SRAM**이 마더보드에 장착되어 있으며, 이번에는 그래픽 관련 데이터에 전용됩니다. 닌텐도는 이 공간을 **비디오 RAM** (VRAM)이라고 부르며, 두 개의 **네임테이블**이라는 데이터 구조를 저장합니다.
  - PPU는 **256 B**의 DRAM을 포함하여 **객체 속성 메모리(OAM)**를 저장합니다.
  - 마지막으로, PPU는 색상 팔레트를 정의하기 위해 **4B**의 메모리를 포함하고 있습니다.

새로운 용어에 대해 걱정하지 마세요, 이 데이터 구조의 의미는 다음 단락에서 단계별로 설명됩니다.

### 프레임 구성

동시대 제쳄들과 마찬가지로, 이 칩은 CRT 디스플레이의 동작에 맞게 설계되었습니다. 프레임 버퍼는 없습니다. PPU가 CRT빔과 보조를 맞춰 렌더링 되어 이미지를 즉시 생성합니다.

PPU는 **256x240 픽셀**의 고정 치수로 프레임을 그립니다 [@graphics-overscan]. 안타깝게도 세계 각국의 아날로그 비디오 표준의 차이로 인해, NTSC나 PAL 등 디스플레이 장치의 지역에 따라 이미지의 외관이 달라집니다. 간단히 말해, NTSC 텔레비전은 오버스캔을 수용하기 위해 상단과 하단 가장자리를 잘라낼 것이므로 (약 224개의 스캔라인만 보임), 개발자가 게임의 요소를 배치할 위치를 결정할 때 이 가장자리는 '위험 지역'으로 간주됩니다. 반면, PAL 텔레비전은 가장자리를 자르지 않지만 더 높은 신호를 채우기 위해 추가 검정 막대를 표시할 것입니다 (PAL은 288개의 스캔라인을 사용).

한편, PPU가 출력하는 프레임은 두 개의 서로 다른 레이어로 구성됩니다. 시연 목적으로 *Super Mario Bros.*를 사용하여 이 기능의 작동 방식을 보여드리겠습니다.

#### 타일 {.tabs.active}

::: {.subfigures .tabs-nested .tab-float .pixel .desktop-margined max_subfigures=1}

![여러 타일이 함께 압축된 두 개의 패턴 테이블.](ppu_mario/chr_map.png){.active title="전체"}

![단일 타일입니다.](ppu_mario/single.png){title="Single"}

타일들은 Character ROM에서 찾을 수 있습니다. (시연을 목적으로 기본 팔레트가 사용됨).

:::

우선, PPU는 스프라이트와 백그라운드를 생성하기 위한 기본 재료로 **타일**을 사용합니다.

NES는 타일을 기본 **8x8 픽셀 맵**으로 정의하며, 이는 **Character 메모리** (게임 카트리지에 위치) 내에 저장되고 **패턴 테이블**이라는 큰 데이터 구조로 조직됩니다 [@graphics-rust]. 각 타일은 16 B를 차지하며 패턴 테이블은 256개의 타일을 포함합니다 [@graphics-pattern]. PPU가 최대 8 KB의 Character 메모리에 접근하므로, 최대 두 개의 패턴 테이블에 접근할 수 있습니다.

타일 내부에서 각 픽셀은 팔레트의 네 가지 색 중 하나를 참조하는 2비트 값으로 인코딩됩니다. 프로그래머들은 최대 8개의 팔레트(배경용 4개, 스프라이트용 4개)를 정의할 수 있습니다. 각 팔레트에서 참조하는 색상은 총 64가지 색으로 구성된 '마스터 팔레트'를 가리킵니다. 이 팔레트는 이 콘솔이 생산할 수 있는 모든 색을 나타냅니다. 팔레트는 네 가지 색으로 구성되며, 그 중 하나는 `투명`으로 예약되어 있습니다.

화면에 그림을 그리기 시작하기 위해, 게임은 캐릭터 메모리에 있는 타일을 참조하는 테이블 세트를 채웁니다. 각 테이블은 프레임의 한 레이어(스프라이트 또는 배경)에 책임이 있습니다. 그런 다음, PPU는 해당 테이블에서 데이터를 읽어 CRT 건에 의해 전달될 스캔 라인을 구성합니다.

이제 각 레이어/테이블이 어떻게 작동하고 기능적으로 어떻게 다른지를 설명하겠습니다.

#### 배경 레이어 {.tab}

::: {.subfigures .tabs-nested .tab-float .pixel max_subfigures=1}

![할당된 백그라운드 맵.](ppu_mario/nametable.png){.active title="전체적으로"}

![선택한 영역이 표시된 할당된 백그라운드 맵.](ppu_mario/nametable_marked.png){title="선택됨"}

좌우로 스크롤이 가능한 수직 미러링을 사용하여 설정된 백그라운드 맵으로 그러나, 단 한쪽만 사용할 수 있습니다.

:::

백그라운드 레이어는 정적 타일을 포함한 512x480 크기의 맵 입니다. 보이는 프레임이 훨씬 작기 때문에, 게임은 표시될 레이어의 부분을 선택합니다. 게임은 플레이 중에 레이어에서 '화면에 보여주는 영역'을 이동할 수도 있습니다. 이것이 **스크롤 이펙트**가 작동하는 방식입니다.

메모리를 절약하기 위해, 4개 타일 그룹이 16x16 픽셀 맵으로 결합되며, 이 맵 내의 모든 타일은 같은 색상 팔레트를 사용해야 합니다.

**네임테이블(Nametables)** (VRAM에 저장됨)은 백그라운드 레이어에서 표시할 타일을 지정합니다. PPU는 레이어의 사분면에 해당되는 1024바이트의 네임테이블 네 개를 찾습니다. 그러나 VRAM에서 사용 가능한 공간은 2KB에 불과하기 때문에 따라서 추가 하드웨어 없이 두 개의 네임테이블만 저장할 수 있습니다. 그래도 남은 두 개는 어딘가에서 다루어져야 합니다. 대부분의 게임들은 남은 두 개가 처음 두 개가 있는 곳을 가리키도록 합니다 (이것을 **미러링**이라고 합니다).

이 아키텍처는 결함이 있는 것처럼 보이지만, 실제로는 단순한 **확장성**을 제공하면서 비용을 절감하도록 설계된 것입니다. 게임이 더 넓은 백그라운드가 필요하다면 추가적인 VRAM을 카트리지에 포함할 수도 있게 만들었습니다.

각 네임테이블의 마지막 바이트는 각 블록에 할당된 색상 팔레트를 지정하는 64바이트 **속성 테이블**을 저장합니다.

#### 스프라이트 레이어 {.tab}

![랜더링된 스프라이트 레이어.](ppu_mario/sprite_layer.png) {.tab-float.pixel}

스프라이트는 화면에서 움직일 수 있는 타일입니다. 또한 서로 곂치거나 백그라운드 뒤에 있을 수도 있습니다. 표시될 그래픽은 우선순위 값에 기반하여 결정됩니다 (전통적인 그래픽 디자인 소프트웨어의 '레이어' 개념과 동일).

**Object Attribute Memory** (OAM) 테이블은 스프라이트로 사용될 타일을 지정합니다. 타일 색인(index) 외에도 각 항목에는 (x,y) 위치와 여러 속성들(색상 팔레트, 우선순위 및 플립 플래그)이 있습니다. 이 테이블은 PPU 칩에 있는 256바이트 DRAM에 저장됩니다.

OAM 테이블은 CPU를 활용해서 채울 수 있지만, 이렇게 하면 실제로 매우 느릴 수 있고 (적절한 시기에 수행되지 않으면 프레임이 손상될 위험이 있음) 그래서 PPU는 (PPU 레지스터를 변경함으로써) WRAM에서 테이블을 가져오도록 프로그래밍된 DMA(**Direct Memory Access**)라는 작은 구성 요소를 포함하고 있습니다. DMA를 사용하면 다음 프레임이 그려질 때 테이블이 업로드 되는 것은 보장됩니다. 하지만, 전송 중에는 CPU가 중지됩니다!

PPU에서 스프라이트는 **스캔라인당 8개**, 프레임당 **64개**로 제한됩니다. 스캔라인 제한은 'OAM 순서 회전'이라는 기법 덕분에 초과될 수 있습니다. 이 기법에서는 게임이 수동으로 OAM의 항목 순서를 변경합니다. 이로 인해 PPU는 각 프레임에서 다른 스프라이트 세트를 렌더링하여, CRT 빔의 속도가 사용자를 허용된 스프라이트 수보다 더 많이 보이게 만듭니다. 그러나 스프라이트는 화면에서 깜박거리는 것처럼 보일 수도 있습니다.

#### 배경 분할 {.tab}

![다른 스크롤링 값이 정의된 두 부분을 강조 표시한 렌더링된 배경 레이어. 마리오가 움직일 때 두 번째 부분만 스크롤됩니다.](ppu_mario/split.png) {.tab-float.pixel}

넘어가기 전에, 아직 말하지 않은 것이 있습니다. Super Mario Bros를 플레이해보면, 마리오가 움직일 때 장면이 원활하게 스크롤되는 것을 알 수 있습니다. 그러나 통계를 표시하는 상단 영역은 고정된 상태로 유지됩니다**! 같은 백그라운드 레이어**의 일부인데도 불구하고! 그렇다면 여기에 어떤 일이 일어나고 있을까요? 이 작업을 수행하기 위해, 게임은 스크롤 값을 중간 프레임에서 변경하여 오버월드와 통계(백그라운드의 고정된 부분에 위치)를 동시에 표시합니다. NES는 이 기능을 기본적으로 제공하지 않지만, 게임은 PPU 상태 레지스터(@graphics-ppustatus)를 통해 PPU의 상태를 관찰하여 타이밍을 추론합니다.

이를 달성하기 위해, 게임은 **Sprite 0 Hit**이라고 하는 기술을 사용합니다. Super Mario Bros는 프레임 내에서 처음으로 그려지는 스프라이트 뒤에 더미 스프라이트를 렌더링하도록 PPU에 지시합니다. PPU가 이를 빔으로 발사한 후, 첫 번째 스프라이트('스프라이트 0')가 그려졌음을 나타내는 플래그를 상태 레지스터에 업데이트합니다. 한편으로, 게임은 끊임없이 프레임 중간에 스프라이트 0 상태가 플래그가 되었는지(일명 '히트')를 확인합니다. 만약 그럴 경우, 게임은 배경 테이블의 스크롤링 속성을 업데이트하여 마리오가 있는 곳으로 이동시킵니다.

전체적으로 'Sprite 0 Hit'는 매우 섬세한 절차입니다. 타이밍이 너무 쉽게 엉망이 될 수 있기 때문입니다 (sprite 0의 플래그는 검사 후 지워지지 않으므로 '중복된' 긍정으로 이어집니다) [@graphics-chibiakumas]. 또한 이 루틴이 무한히 반복되므로 실행하는 데 상당한 비용(CPU 주기 측면에서)이 들 수 있습니다. 다행히도, 나중에 나온 매퍼는 임의의 스캔라인에 도달할 때마다 자동 인터럽트를 사용하여 이 기능을 대체했으며 (훨씬 효율적인 기술), 예를 들어 Super Mario Bros 3의 시각적 기능이 크게 향상되었습니다.

#### 결과 {.tab}

![짜잔!](ppu_mario/result.png) {.tab-float.pixel}

프레임이 완성되면 다음 프레임으로 넘어갈 때입니다!

그러나, CPU는 PPU가 현재 사용 중인 테이블을 수정할 수 없습니다. 그렇지 않으면 화면에 아티팩트가 나타날 수 있습니다. 따라서 모든 스캔 라인이 완료되면, PPU는 CPU에서 **Vertical Blank** (V-Blank) 인터럽트를 트리거합니다. 이것은 게임에 현재 표시된 그림을 지우지 않고 테이블을 업데이트할 수 있음을 알립니다. 이때 CRT 빔이 '화면에 보여주는 영역' 아래(오버스캔 영역)를 가리킵니다. (또는 하단 테두리 영역)

V-Blank 윈도우 외부에서 갱신할 수 있는 PPU 레지스터는 소수에 불과합니다[@graphics-outside_vblank]. 이것이 배경 레이어를 중프레임에서 스크롤할 수 있는 이유를 설명합니다.

### 비밀과 한계점 {.tabs-close}

전체 프레임을 저장할 수 있는 충분한 메모리를 갖춘 프레임-버퍼 시스템이 바람직하지만 RAM이 비용이 비싸고 콘솔의 목표는 저렴해지는 것입니다. 이제 이 디자인이 매우 효율적이고 유연하기까지 한데도 말입니다.

#### 멀티 스크롤링 {.tabs.active}

![슈퍼 마리오 브라더스 2. 수직 스크롤링을 위한 네임테이블 설정 (수평 미러링).](secrets/multiscrolling_mirror.png) {.tab-float.pixel}

![슈퍼 마리오 브라더스 3. 마리오가 달리고 날 수 있기 때문에 PPU는 대각선으로 스크롤을 해야합니다. 오른쪽 가장 자리가 잘못된 색상 팔레트를 보여주고 있습니다! 왼쪽 가장 자리는 마스크가 적용되어 있습니다.](secrets/multiscrolling.png) {.tab-float.pixel}

몇몇 게임들은 주인공이 수직으로 움직여야 하는 경우가 있어, **수평 미러링**으로 네임테이블을 설정합니다. 다른 게임들은 캐릭터가 좌우로 움직여야 하므로 대신 **수직 미러링**을 사용합니다.

어떤 유형의 미러링이든 사용하여 PPU가 사용자가 눈치채지 않는 사이에 배경 타일을 갱신할 수 있습니다: 새로운 타일이 렌더링되는 동안 스크롤할 공간이 충분합니다.

하지만 캐릭터가 대각선으로 움직이려면 어떻게 될까요? PPU는 어떤 방향으로든 스크롤할 수 있지만, 추가 VRAM이 없으면 가장자리는 동일한 색상 팔레트를 공유해야 합니다(타일이 블록으로 그룹화됨을 기억하세요).

이것이 *슈퍼 마리오 브라더스 3*와 같은 일부 게임에서 마리오가 움직일 때 화면 오른쪽 가장자리에 이상한 그래픽이 나타나는 이유입니다(게임은 수직 스크롤링으로 설정됨) [@graphics-seam]. 이들은 하드웨어 비용을 최소화해야 했을 가능성이 있습니다 (이 게임에는 이미 강력한 맵퍼가 설치되어 있음).

흥미로운 *해결책*: PPU는 타일 위에 수직 마스크를 적용할 수 있게 하여 글리치 영역의 일부를 효과적으로 숨길 수 있었습니다.

#### 타일 스와핑 {.tab}

::: {.subfigures .tabs-nested .tab-float max_subfigures=1}

![초기 스캔 라인.](secrets/multiplexing_1.png){.pixel .active title="초기"}

![늦은 스캔 라인.](secrets/multiplexing_2.png){.pixel title="늦은"}

![사용자에게 표시되는 실제 프레임.](secrets/multiplexing_complete.png){.pixel title="표시됨"}

특정 스캔 라인 동안 사용할 수 있는 타일을 사용하여 렌더링된 가상 프레임.

:::

슈퍼 마리오 브라더스 3의 또 다른 특별한 점은 표시할 수 있는 그래픽의 양입니다.

이 게임은 허용된 것보다 더 많은 배경 타일을 표시합니다. 그래서 어떻게 그런 걸까요? 디스플레이가 생성되는 동안 다른 시간에 두 개의 화면 캡처를 보면 최종 프레임이 실제로 *두* 개의 다른 프레임으로 구성된 것을 볼 수 있습니다.

이것은 MMC3 매퍼의 매직 중 하나로, 추가 공간을 액세스할 수 있도록 프로그램 ROM에 사용될 뿐만 아니라 두 개의 다른 캐릭터 칩을 연결하여 캐릭터 ROM 공간을 확장합니다. PPU가 요청하는 화면 부분을 확인함으로써, 매퍼는 어느 칩으로든 리디렉션하여 원래 지원하는 것보다 더 많은 고유한 타일을 화면에 표시할 수 있게 합니다 [@graphics-n3s].

#### 호기심을 자극하는 행동 {.tab}

연구를 진행하면서, PPU의 특이한 동작을 설명하는 많은 흥미로운 기사를 접했습니다. 그래서 몇 가지를 여기에서 언급하려고 합니다:

- RGB 색상을 생성하여 방송을 위해 NTSC/PAL 신호로 인코딩하는 [마스터 시스템 VDP](master-system#graphics)와 달리, **NES의 PPU는 모든 작업을 한 번에 처리**합니다 [@graphics-palettes]. 따라서 PPU 마스터 팔레트의 색상과 현재 기술에서 널리 채택된 표준 RGB 색공간 사이에는 일대일 연결이 없습니다. 이로 인해 해석의 여지가 생기고, 결과적으로 다양한 에뮬레이터가 다른 팔레트를 표시할 수 있습니다.
  - RGB 팔레트 간의 차이는 Tim Worthington의 DIY 키트를 통해 가장 잘 드러납니다. 왜냐하면 이 키트는 NES에 RGB 신호 출력을 추가하고 세 가지 미리 정의된 팔레트 중 하나를 선택할 수 있는 스위치를 구현하기 때문입니다 [@graphics-nesrgb].
- 마스터 팔레트에는 NTSC TV 신호를 망칠 수 있는 **'저주받은' 색상** (`$0D`)이 포함되어 있습니다 [@graphics-cursed_colour]. 일부 TV는 해당 색상을 표시하는 신호를 블랭킹 신호로 혼동하기 때문에 깜박임이 발생할 수 있습니다.
- PPU는 객체 속성 메모리(OAM)를 저장하기 위해 DRAM에 의존합니다. 이제, DRAM은 데이터를 잃지 않기 위해 지속적으로 리프레시가 필요합니다 (SRAM과 달리), 그리고 PPU는 프레임을 렌더링하지 않을 때 DRAM을 리프레시하지 않습니다 [@graphics-oam]. 이는 수직 블랭킹 동안 나타납니다. 이러한 이유로, V-블랭킹이 발생하는 동안의 비-리프레시 기간 동안 테이블의 일부가 손상될 것이기 때문에 V-블랭킹 외부에서 OAM을 업데이트하지 않는 것이 좋습니다.
  - PAL 시스템용 PPU 변형은 V-블랭킹 동안 리프레시가 수행되므로 이에 영향을 받지 않습니다 (PAL 시스템에서 V-블랭킹이 더 오래 지속됨).

## 오디오 {.tabs-close}

**오디오 프로세싱 유닛**(APU)라고 불리는 전용 부품이 이 서비스를 제공한다 [@audio-apu]. 리코는 CPU 칩 내부에 이를 임베드하여 CPU와 APU 모두의 불법 복제를 피하고자 했습니다.

### 기능

이 오디오 회로는 일반적으로 **프로그래머블 사운드 제너레이터**(PSG)라는 이름으로 알려져 있으며, 이는 대략적으로 미리 정의된 파형 집합만 생성할 수 있음을 암시하는데, 이 경우에는 거의 _대부분_ 맞다. APU는 오디오 데이터를 **다섯 개의 채널** 로 시퀀싱하며, 각 채널은 특정 파형 또는 신호에 예약되어 있습니다. 각 채널에는 파형의 피치, 소리, 볼륨 및/또는 길이를 변경하는 다양한 속성이 포함되어 있습니다. 그들은 계속해서 믹스되고 출력 오디오 신호를 통해 전달됩니다.

APU의 기능은 메모리 주소를 통해 드러나며, CPU는 프로그램 ROM에서 발견된 음악 관련 데이터를 읽고 APU를 적절히 프로그래밍합니다.

더 나아가, 패미컴 모델은 특히 혼합된 오디오 신호를 카트리지로 보내는 핀을 제공하며, 이는 **추가 채널** 과 혼합될 수 있습니다(추가 칩 필요) [@general-cartridge].

이제 APU가 제공하는 다섯 개의 채널을 살펴보겠습니다 [@audio-review]:

#### 펄스 {.tabs.active}

::: {.subfigures .tabs-nested .tab-float}

![펄스 1 채널의 오실로스코프 뷰.](pulse_single_1){video="true" title="펄스 1"}

![펄스 2 채널의 오실로스코프 뷰.](pulse_single_2){.active video="true" title="펄스 2"}

![모든 오디오 채널의 오실로스코프 뷰.](pulse_full){video="true" title="완료"}

마더 (1989).

:::

첫 번째 **두 개의 채널**은 **펄스 파동** 을 생성합니다 [@audio-apupulse]. 소리가 들릴 때, 그들은 *비프* 소리와 같은 매우 독특한 소리를 나타내며 주로 **멜로디 또는 음향 효과**를 위해 사용됩니다. 각 시퀀서는 서로 다른 펄스 폭(일명 duty cycle)을 사용하여 세 가지 유형의 펄스 파형을 생성할 수 있습니다. **의무 주기(duty cycle)**입니다. 회로는 또한 **스윕 유닛**(피치를 굽히도록 허용) 및 시간이 지남에 따라 볼륨을 낮추는 **엔벨로프 생성기**에 연결됩니다. **감쇠(decay)**입니다.

대부분의 게임은 멜로디를 위해 하나의 펄스 채널을 사용하고 다른 하나는 반주에 사용합니다. 게임이 음향 효과를 재생해야 할 때, 반주 채널이 효과를 재생하도록 전환되고 그 후 반주로 돌아가는 것을 자주 볼 수 있습니다. 이렇게 함으로써 게임 플레이 중 멜로디가 중단되지 않습니다.

펄스 웨이브가 이 세대 콘솔의 상징 중 하나라고 말하는 것이 공정한 것 같습니다. 비용 효율성 때문에 채택되었을 것이라고 추정되며: (제한된) CPU는 한 번에 많은 데이터를 처리할 수 없으며, 펄스 웨이브는 간단한 멜로디를 재생하기 위해 많은 매개변수를 필요로 하지 않는다는 점에서 이상적입니다 (이는 CPU 사이클을 다른 작업을 위해 확보해 줍니다).

#### 삼각형 {.tab}

::: {.subfigures .tabs-nested .tab-float}

![삼각형 채널의 오실로스코프 보기.](triangle_single){.active video="true" title="삼각형"}

![모든 오디오 채널의 오실로스코프 뷰.](triangle_full){video="true" title="Complete"}

마더 (1989).

:::

경쟁사와 비교했을 때 APU의 특별한 점 중 하나는 **삼각형 웨이브**를 생성할 수 있다는 점입니다. 이는 흔히 멜로디의 **베이스라인**으로 사용됩니다. 게다가 피치를 극적으로 변경함으로써 **타악기**로도 사용할 수 있습니다.

APU에는 이 유형의 웨이브를 위한 채널이 하나 예약되어 있습니다. 비하인드 씬에서 전용 시퀀서는 삼각형 신호를 생성하는 데 32 사이클이 걸리며, 이 제한은 결과적으로 삼각형 웨이브폼이 계단 모양을 취하게 만듭니다.

반면에, 관련 회로는 볼륨 제어를 제공하지 않습니다. 어쨌든, 일부 게임은 믹서의 볼륨 제어를 조작하여 다른 방법을 찾아냈습니다.

#### 노이즈 {.tab}

::: {.subfigures .tabs-nested .tab-float}

![노이즈 채널의 오실로스코프 뷰.](noise_single){.active video="true" title="Noise"}

![모든 오디오 채널의 오실로스코프 뷰.](noise_full){video="true" title="Complete"}

마더 (1989).

:::

'노이즈'의 개념은 어떤 패턴이나 순서를 따르지 않는 일련의 웨이브폼에 기인합니다. 결국, 우리의 귀는 이를 백색 잡음으로 해석합니다. 이를 감안할 때, APU는 다양한 종류의 노이즈를 재생할 수 있는 채널을 하나 할당합니다.

무대 뒤에서, 노이즈 생성기는 OR 게이트에 의해 무작위로 음소거되는 펄스 채널과 유사한 엔벨로프 생성기를 사용합니다 [@audio-apunoise]. 음소거의 조건은 피드백 루프에 연결된 15비트 시프트 레지스터의 값에 따라 달라집니다. 종합적으로, 이것은 회로가 _가장 예측 불가능한_ 패턴으로 신호를 출력하게 만들어 노이즈를 발생시킵니다.

제어 측면에서는, 4비트는 엔벨로프 생성기의 주기를 변경하고 1비트는 시프트 레지스터의 '모드'를 변경합니다. 그렇게 해서 32개의 노이즈 프리셋이 사용 가능합니다. 이 프리셋들 중 절반(16개)은 **깨끗한 정적**을 생성하고 나머지 절반은 **로봇 정적**을 생성합니다.

일반적으로 게임은 타악기나 환경 효과를 위해 노이즈 채널을 사용합니다.

#### 샘플 {.tab}

::: {.subfigures .tabs-nested .tab-float}

![샘플 채널의 오실로스코프 보기.](sample_single){.active video="true" title="샘플"}

![모든 오디오 채널의 오실로스코프 뷰.](sample_full){video="true" title="완료"}

마더 (1989).

:::

샘플은 재생할 수 있는 녹음된 음악 조각입니다. 보시다시피, 샘플은 단일 웨이브폼에 제한되지 않지만 공간을 훨씬 더 많이 차지합니다.

APU에는 샘플 전용 채널이 하나 있습니다. 여기서 샘플들은 **7비트 해상도** (값이 `0`에서 `127`로 인코딩됨) 및 **~15.74 kHz 샘플링 속도**로 제한됩니다 [@audio-2a03ref]. 이 채널을 프로그래밍하려면 게임들이 7비트 값을 스트리밍하거나(이는 많은 사이클과 저장 공간을 차지함) 다음 샘플과 이전 샘플 간의 변동만을 인코딩하는 **델타 변조**를 사용합니다.

APU에서의 델타 변조 구현은 1비트 값만 수신하므로, 이는 게임이 카운터가 작동할 때마다 샘플이 `1`씩 증가하거나 감소하는지 여부만 알 수 있음을 의미합니다. 따라서 충실도를 희생하더라도 델타 변조는 게임이 APU에 연속적인 값을 스트리밍해야 하는 것을 방지할 수 있습니다.

이 채널을 프로그래밍하는 데 더 많은 공간과 CPU 사이클이 필요하므로, 보통 게임들은 반복적으로 재생할 수 있는 작은 조각들(예: 드럼 샘플)을 저장합니다. 어쨌든, NES의 생애 동안 수많은 개발자들이 이 채널을 잘 활용하는 방법을 찾아냈습니다.

### 비밀과 한계점 {.tabs-close}

APU는 비닐, 카세트 또는 CD의 품질과는 비교할 수 없었지만, 프로그래머들은 주로 NES의 모듈형 아키텍처 덕분에 APU의 기능을 확장하는 방법을 찾아냈습니다.

#### 추가 채널 {.tabs.active}

![캐슬바니아 III (미국/유럽, 1989) 오실로스코프 뷰.](castlevania_usa){.tabs-nested .tab-float .active video="true" title="미국판"}

![악마성 전설 (캐슬바니아 III의 일본 버전, 1989) 오실로스코프 뷰.](castlevania_jap){.tabs-nested-last video="true" title="일본판"}

패미컴이 사운드 확장을 위한 독점 카트리지 핀을 제공했다는 것을 기억하십니까? 글쎄요, *캐슬바니아 3* 같은 게임들이 이를 활용하여 **코나미 VRC6**라는 추가 칩을 포함시켜 **두 개의 추가 펄스파형과 톱니파형**을 추가했습니다.

일본 버전과 미국 버전의 차이를 보여주는 두 가지 예제를 살펴보십시오(후자는 사운드 확장 기능을 제공하지 않은 NES 버전에서 실행됩니다).

#### 트레몰로 {.tab}

![파이널 판타지 III (1990) 오실로스코프 뷰.](tremolo_full){.tab-float video="true"}

카트리지 비용을 증가시키는 대신 일부 게임들은 더 많은 채널을 추가하기 위해 창의성을 기술보다 우선시했습니다.

이 예시에서, 파이널 판타지 III는 추가 채널의 느낌을 주기 위해 트레몰로 효과를 사용하는 아이디어를 생각해냈습니다.

### 보다 정교한 관찰 {.tabs-close}

이제 APU가 무엇을 할 수 있는지 알았으니, 그 사운드가 어떻게 동작하는지 관찰할 수 있는 대체 방법을 보여드리겠습니다. 이는 APU에 대해 이미 알고 있는 것을 보완할 뿐만 아니라, 더 이상 귀에 의존하지 않기 때문에 더 객관적인 검사를 제공할 것입니다.

먼저, 소리 이론에 대한 간단한 소개로 시작해보겠습니다.

**푸리에 분석** 원칙 덕분에, 우리가 듣는 모든 소리를 여러 가지 주파수와 진폭의 **사인파의 합**으로 분해할 수 있습니다 [@audio-complexwaveforms]. 가장 낮은 주파수의 사인파를 **기본파**라고 하고, 나머지는 **배음**이라고 합니다. 기본파와 그 배음을 더하면 원래 소리가 다시 나타납니다. 즉, 인식 가능한 음정을 가진 소리들은 대부분 (혹은 전부) 배움이 기본 주파수의 배수입니다. 그래서 이러한 배음들을 **조화음**이라고 부릅니다 [@audio-harmonics].

조화음은 펄스파형, 삼각파형 및 톱니파형과 같은 파형이 포함하는 조화음을 결정하는 공식을 따르므로, 이 섹션에서는 반복적으로 다뤄질 주제입니다. 그렇지 않으면 이 파형들은 '완벽한' 형태에서 벗어날 수 있습니다.

#### 스펙트로그램 소개

이제, 사인파는 어떤 소리를 만들어낼 수 있는 주요 성분이 되었으므로, 우리는 들리는 소리를 사인파로 분석할 수 있게 되었습니다. 이제, 데이터 분석의 어떤 종류에서도, 방대한 양의 정보를 정리하는 데 가장 편리한 것이 그래프를 그리는 것입니다. 음향 분석의 경우, 우리는 **스펙트로그램**을 가지고 있습니다. 이것들은 오디오 샘플의 모든 정보를 단일 플롯으로 인코딩합니다. X축은 시간(초)을 나타내고, Y축은 해당 시간 동안 생성된 사인파의 주파수(Hz)를 나타내며, Z축(각 점의 색 밝기)은 각 주파수의 세기/음량(데시벨)을 나타냅니다.

![펄스 채널의 6초를 시각화한 스펙트로그램 예시.](spectrogram_example){video="true"}

이 예시에서 볼 수 있듯이, 각 수평선(일명 점의 시퀀스)은 사인파에 대응하며(가장 낮은 것은 기본파, 나머지는 조화음), 그 밝기는 진폭을 나타냅니다. 이를 염두에 두고 다음 정보를 추출할 수 있습니다:

- 시간이 지남에 따라 수평선이 크게 변위되는 경향이 있습니다. 이것은 펄스 채널의 피치가 변경된 것입니다.
- 각 음의 시작은 크고(점이 밝음) 빠르게 진정됩니다. 이것은 APU의 엔벨로프 제어가 작동하는 것입니다.
  - 감쇠 기간이 끝날 때 밝은 수직선이 나타납니다. 상당히 짧아서 쉽게 들리지 않지만, 어쨌든 그것은 노이즈(짧은 팝 소리)이고 APU의 결함이라고 생각합니다.
- 0.25초 이상 음을 유지하면 **비브라토**가 발생합니다 (Y축의 연속 변동). 나는 그것이 의도적인지(스윕 기능 사용) 아니면 APU의 부작용인지 확실하지 않다.

이 관찰의 대부분은 단순히 오디오 샘플을 듣는 것만으로 쉽게 알 수 없는 부분입니다. 이것이 이 섹션을 작성한 이유입니다.

#### APU 플로팅

NES의 APU를 연구하기 위해, 이전 예시를 사용하여 APU의 각 채널에 해당하는 다섯 가지 스펙트로그램을 컴파일했습니다. 그들과 함께, 데이터가 보여주는 것을 풀어내기 위한 저의 시도를 찾을 수 있을 것입니다.

시작하기 전에, 부정확함(예: 추가 노이즈) 없이 데이터를 수집하기 위해 몇 가지 타협이 있었다는 것을 고백해야 합니다. 녹음은 'towave'라는 윈도우 프로그램을 사용하여 얻었으며, 이 프로그램은 PSG 기반 오디오 칩의 에뮬레이션에서 발생하는 근본적인 문제를 해결하기 위해 **밴드 제한 합성**을 사용합니다. 즉, 펄스, 삼각 및 톱니파형은 **무한한 조화음**으로 구성됩니다. 그러나, 그것은 44.1 kHz 샘플로 제한된 현대 사운드 카드와 잘 섞이지 않습니다. 따라서, '밴드 제한 합성'이라는 기술이 사용되어 사운드 카드의 한도 내에서 올바른 조화음을 선택합니다. 결과적으로, 이 기술은 성능, 정확성 및 앨리어싱 방지 사이에서 실현 가능한 균형을 제공합니다. 하지만 데이터가 아날로그 대응물과 100% 동일하지 않을 수 있습니다(반면 녹음 장비의 잡음과 같은 다른 문제도 유발될 수 있습니다). 그러나 어느 정도는 허용 가능한 수준이며, 가장 중요한 것은 이 섹션의 목적을 충족시킨다는 것입니다.

그렇다면, 이제 분석을 계속 진행해 보겠습니다.

##### 펄스 {.tabs.active}

![Pulse 1 채널의 스펙트로그램.](spectrograms/eb0_pulse_nes.png) {.tab-float}

이론적으로 펄스 톤은 홀수 고조파만을 포함합니다. 즉, 기초파가 세 번째 고조파, 다섯 번째 고조파 등과 결합됩니다. 더 나아가, 각 고조파는 기초파에서 멀어질수록 그 진폭이 감소합니다. 진폭 공식은 `진폭 = 1 ÷ 고조파 번호` 입니다[@audio-pulse].

따라서, 스펙트로그램의 Y축이 높아질수록 각 고조파의 밝기가 어떻게 흐려지는지 주목하십시오. 그러나 APU의 펄스 파형은 각 고조파 번호에서 증가하는 앞서 언급된 비브라토 효과를 나타내는 것으로 보입니다. 게다가, 어떤 소리도 없어야 할 스펙트로그램 영역에 잔뜩 조용한 오버톤이 포함되어 있습니다(아마도 노이즈와 다른 결함의 결과일 가능성이 있음).

##### 삼각형 {.tab}

![Triangle 채널의 스펙트로그램.](spectrograms/eb0_triangle_nes.png) {.tab-float}

삼각 파형도 홀수 고조파로 구성되지만, 그 진폭의 감소가 더 빠릅니다(여기서 `진폭 = 1 ÷ 고조파 번호²`[@audio-triangle]).

하지만, 여기서 보여지는 것은 PPU가 생성한 계단 모양의 삼각형 파형으로 추가된 고조파와 증가된 진폭을 초래합니다.

##### 노이즈 {.tab}

![Noise 채널의 스펙트로그램.](spectrograms/eb0_noise_nes.png) {.tab-float}

자연스럽게, 노이즈는 고조파 규칙에 따르지 않으며 불규칙적으로 전 주파수 영역을 채울 수 있어 쉽게 인식할 수 있는 피치가 없습니다.

시간표를 따라가면 APU가 제공하는 다양한 노이즈 프리셋을 구별할 수 있으며, 각각 고유한 오버톤 세트를 나타냅니다.

##### 샘플 {.tab}

![Sample 채널의 스펙트로그램.](spectrograms/eb0_dcm_nes.png) {.tab-float}

이전 채널과 달리 샘플 채널은 개발자가 APU에 제공하는 저해상도 녹음만 재생합니다. 드럼 킷이 연주된 예를 고려할 때, 스펙트로그램에서 눈에 띄는 특징을 찾을 수 없습니다(화이트 노이즈와의 유사점 제외).

##### 톱니파 {.tab}

![VRC6의 톱니 채널의 스펙트로그램.](spectrograms/castlevania_saw_nes.png) {.tab-float}

보너스로 VRC6 확장에서 Sawtooth 채널도 살펴보겠습니다. 우선, 완벽한 톱니파는 모든 고조파로 구성되며 각각의 진폭은 점점 감소합니다 (여기서 `진폭 = 1 ÷ 고조파 번호` [@audio-sawtooth]).

디지털 장비에 있어 이것은 상당한 요구사항이며, 게임 카트리지에는 자연스럽게 비현실적입니다(그렇게 완벽할 필요도 없을 수 있습니다!). 그래서 APU의 삼각파와 유사하게, VRC6는 톱니파를 7 사이클로 시퀀싱합니다(따라서 유사한 단계 사다리 효과를 생성합니다).

결과적으로 해당 스펙트로그램은 매우 복잡하며, VRC6의 근사화 기술은 여러 곳에서 추가 고조파로 파형을 채웁니다.

#### 결론 {.tabs-close}

음, NES의 합성 파형은 이론이 지시하는 형태와 전혀 다르다는 것 같습니다. 이것이 APU에 결함이 있다는 뜻인가요? 아니요! APU의 설계 방식 덕분에 이 콘솔은 독특하고 인식 가능한 사운드를 얻게 되었으며 이 속성들은 의도적이든 아니든 간에 스펙트로그램에서 특이한 결과를 나타냅니다.

참고로, 완벽한 기하학은 우리 눈에는 보기 좋을 수 있지만, 흥미롭게도 우리 귀는 완벽한 에지를 가진 파형을 별로 좋아하지 않습니다! (팝 소리가 들리기 시작할 수 있습니다.)

앞으로 스펙트로그램을 사용한 소리 분석은 단순한 분석이든 다른 시스템과의 비교를 위한 것이든 다른 기사에서도 유용하게 사용될 것입니다. 이 그래프들이 _모든 것을 설명하는_ 도구는 아닙니다. 특히 너무 많은 채널/악기로 혼합된 소리 샘플의 경우 분해가 매우 어렵습니다. 그러나 이 그래프들이 어떤 종류의 객관적 연구를 위한 탄탄한 출발점을 제공할 것이라고 생각합니다.

## 게임

NES 게임은 주로 6502 어셈블리 언어로 작성되며 **프로그램 ROM**에 존재합니다. 한편, 게임의 그래픽(타일)은 **캐릭터 메모리**에 저장됩니다.

더 나아가, 게임은 Nintendo의 승인을 받아 소매점에서 판매되거나 대여되었습니다.

### 대안 매체

일본에서만 출시되었지만, 이 프리퍼럴은 매퍼와 마찬가지로 이 콘솔에 더 많은 기능을 부여한 독특하고 단명한 추가 장치를 소개할 수 있는 좋은 기회라고 생각합니다. 이 주변 장치는 **패미컴 디스크 시스템**(FDS)이라고 불리며, 1986년에 출하되었으며(패미컴 출시 ~3년 후) 출시되었습니다. 외장 플로피 리더의 형태를 가졌으며 'RAM 어댑터'라는 특이한 형태의 카트리지와 함께 제공되었습니다.

::: {.subfigures .side-by-side}

![플로피가 삽입되는 드라이브(보호를 위해 플로피가 삽입된 사진을 보여줍니다). 6개의 C 배터리(각 1.5 V) 또는 3.6 W AC 어댑터로 작동합니다.](fds/drive.png) {.toleft.no-borders}

![패미컴의 카트리지 슬롯에 장착되고 케이블을 통해 드라이브에 연결된 RAM 어댑터입니다.](fds/ram.png) {.toright.no-borders}

패미콤 디스크 시스템(FDS)을 구성하는 두 구성 요소입니다.

:::

패미컴 디스크 시스템은 패미컴에 다음과 같은 기능을 추가했습니다:

- **패미컴 디스크**라고 불리는 게임 배포를 위한 새로운 매체 [@games-fds]. 미쓰미의 '퀵 디스크'를 기반으로 하고 있으며, 한 면당 **약 64 KB의 데이터** 를 제공하며 재기록이 가능합니다.
- **추가 오디오 채널** 을 사용하며, [웨이브테이블 신시사이저](game-boy#tab-7-3-wave)를 사용합니다 [@games-fds_audio].

![패미컴에 장착된 FDS 장비입니다.](fds/mounted.png) {.open-float.no-borders}

플로피는 단일 매체이므로 (여러 칩 카트리지와는 반대로), 모든 게임 데이터가 내부에 압축되어야 하지만, 독점 **파일 시스템**을 사용하여 체계적으로 유지됩니다.

그럼에도 불구하고, 패미컴/NES는 역할 분리가 명확한 프로그램 메모리와 문자 메모리를 필요로 하므로, 이를 해결하는 역할은 'RAM 어댑터'가 합니다. 이 구성 요소는 플로피 디스크에서 읽은 게임 데이터를 버퍼링하기 위해 **32KB의 프로그램 RAM**과 **8KB의 문자 RAM**을 포함하고 있으며, 이를 통해 콘솔이 이를 카트리지를 기반으로 하는 게임처럼 읽을 수 있게 합니다.

{.close-float}

드라이브를 작동시키기 위해 RAM 어댑터는 **BIOS**를 저장하기 위한 추가 8KB ROM을 내장하고 있습니다 [@games-fds_bios]. 이 프로그램은 다음 작업을 수행합니다:

- 스플래시 애니메이션을 로드합니다.
- 플로피에서 게임을 부팅합니다. 백그라운드에서 BIOS에는 플로피의 내용을 해당 메모리 칩으로 복사하는 루틴이 포함되어 있어 콘솔이 이를 읽을 수 있습니다.
- 디스크 파일 시스템을 탐색하는 것과 같은 게임용 I/O API를 제공합니다.

![패미컴 디스크 시스템의 두 가지 소매 게임 예시입니다. 디스크의 파란 '맛'도 먼지 차단 기능이 있습니다.](fds/floppies.jpg) {.toleft}

![FDS 스플래시 애니메이션으로, 사용자가 게임을 삽입할 때까지 대기합니다.](fds_bios){.toright video="true"}

그 당시, 닌텐도는 소매점에 일부 '키오스크'를 배치하여 사용자가 디스크를 가져와 새로운 게임으로 덮어쓸 수 있게 했습니다.

불행히도 몇 년 후, 패미컴 디스크 시스템은 단종되었고, 이후의 게임들은 다시 카트리지 매체로 돌아갔습니다. 밝은 면에서는, FDS의 기능과 유사하거나 더 우수한 기능을 가진 새로운 매퍼들을 사용할 수 있었습니다.

## 불법 복제 방지 및 지역 잠금

닌텐도는 **락아웃** 칩이라는 독점적인 **체크 통합 회로** (CIC) [@anti_piracy-cic]를 포함하여 무단 출판을 차단할 수 있었습니다. 이 칩은 콘솔에 위치하며 리셋 신호와 연결되어 (따라서 쉽게 제거할 수 없음) 있습니다.

이 칩은 게임 카트리지에 다른 락아웃 칩이 있는지 확인하는 내부 프로그램인 **10NES**를 실행합니다. 그 검사가 실패하면 콘솔은 무한 리셋 상태로 전환됩니다.

두 락아웃 칩은 콘솔의 가동 시간 동안 지속적으로 통신합니다. 이 시스템은 콘솔의 락아웃 핀 중 하나를 자르면 칩이 유휴 상태로 남게 되어 무력화될 수 있습니다. 대안으로, -5V 신호를 보내면 이를 멈출 수 있습니다.

CIC는 1983년 비디오 게임 대폭락의 공포에서 비롯되었습니다. 당시 닌텐도의 사장이었던 히로시 야마우치는 양질의 게임을 보장하기 위해 모든 게임을 승인할 책임을 가지기로 결정했습니다 [@anti_piracy-vindicator].

일본 모델의 콘솔인 패미컴이 1983년 대폭락 이전에 출시된 것을 알 수 있을 것입니다. 그래서 게임 카트리지나 콘솔에는 CIC 회로가 포함되어 있지 않고, 대신 핀을 사용하여 선택적 사운드 확장을 사용할 수 있도록 합니다 [@anti_piracy-nocic].

## 이제 끝입니다
