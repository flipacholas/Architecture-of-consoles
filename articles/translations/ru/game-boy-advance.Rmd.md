---
short_title: Архитектура Game Boy Advance
long_title: Архитектура Game Boy Advance
name: Game Boy Advance
date: 2019-08-18
release_date: 2001-03-21
generation: 6
subtitle: Один чип, чтобы управлять всеми
cover: gba
top_tabs:
  Model:
    file: international
    caption: "Оригинальный Game Boy Advance.<br>Выпущен 21.03.2001 в Японии, 11.06.2001 в Америке и 22.06.2001 в Европе."
  Motherboard:
    caption: "Показана ревизия '03'. Надпись \"AGB\" - это идентификатор модели Game Boy Advance. Слот для картриджа и усилитель звука находятся на задней панели."
    extension: "jpg"
    bib_source: photography-gekkio
  Diagram:
    caption: "Каждая шина данных обозначена своей шириной.<br>Показанная схема AGB Game Pak не включает маппер (поскольку новый процессор способен адресовать значительно больше памяти), хотя игры с большим ПЗУ могут включать его в комплект."
#Historical
aliases:
  - /projects/consoles/game-boy-advance/
---

## Краткое введение

Внутренний дизайн Game Boy Advance довольно впечатляющий для портативной консоли, которая работает от двух АА батареек.

В этой консоли по-прежнему будет использоваться *фирменный* графический процессор Nintendo. Дополнительно, в ней будет представлен относительно новый процессор от британской компании, который будет набирать популярность в ближайшие годы.

```{r results="asis"}
supporting_imagery()
```

## Процессор

Большинство компонентов объединены в единый модульпод названием CPU AGB. Модуль содержит два совершенно разных процессора:

- **Sharp SM83**, работающий на частоте 8,4 или 4,2 МГц: Это аналог процессора, который использовался в Game Boy! Он предоставляет возможность запуска игр для Game Boy (DMG) и Game Boy Color (CGB). Вот [моя предыдущая статья](game-boy), если вы хотите узнать об этом больше.
- **ARM7TDMI** работает на частоте 16,78 МГц: Это новый процессор, на котором мы сосредоточимся. Именно он запускает игры Game Boy Advance.

Надо отметить, что оба процессора **никогда не работают одновременно** и никаким сопроцессингом не занимаются. **Единственная** причина включать *очень* старый Sharp это **обратная совместимость**.

### Что нового?

До того, как компания ARM Holdings (в настоящее время "Arm") стала невероятно популярной в мире смартфонов, она лицензировала свои процессоры для компьютеров Acorn, Apple Newton, телефонов Nokia и Panasonic 3DO. Выбранный Nintendo процессор, ARM7TDMI, основан на более раннем дизайне ARM710 и включает в себя [@cpu-arm]:

- **ARM v4**: Четвертая версия 32-битного набора инструкций ARM.
- **Трехэтапный конвейер**: выполнение инструкций разбито на три шага или *этапа*. Процессор выбирает, декодирует и выполняет до трех инструкций параллельно. Это позоволяет использовать ресурсы процессора по максимуму (что снижает простой процессора), при этом так же увеличивает количество выполняемых за еденицу времени инструкций.
- **32-bit ALU**: работает с 32-битными числами без потребления дополнительных тактов.

Более того, в ядре имеются расширения, упомянутые в названии (*TDMI*):

- **T** → **Thumb**: Подмножество набора инструкций ARM, инструкции которого кодируются в 16-битные слова [@cpu-thomas].
  - Будучи 16-битными, инструкции Thumb требуют половину от ширины шины и занимают вдвое меньше памяти. Однако, так как интрукции Thumb предлагают только функциональное подмножество инструкций ARM, вам может потребоваться больше инструкций для достижения сходного эффекта.
  - Thumb предлагает только условное выполнение ветвлений, его операции обработки данных используют двухадресный формат, а не трехадресный, и он имеет доступ только к нижней половине регистров файла.
  - В реальности Thumb занимает 70% места ARM кода. На 16-битной памяти Thumb работает *быстрее*, чем ARM.
  - При нужде ARM и Thumb инструкции можно смешивать в одной программе (т. н. *interworking*), так что разработчик может выбирать когда и где использовать каждый режим.
- **D** → **Debug Extensions**: обеспечивает отладку через JTAG.
- **M** → **Улучшенный множитель (Enhanced Multiplier)**: Предыдущим ядрам ARM требовалось несколько тактов для вычисления полного 32-битного умножения, а данное усовершенствование сокращает этот процесс до нескольких тактов.
- **I** → **EmbeddedICE macrocell**: Включает аппаратные точки останова, точки наблюдения и позволяет останавливать систему во время отладки.

### Расположение памяти

В частности, включение Thumb оказало сильное влияние на окончательный дизайн этой консоли. Nintendo смешивала 16-битные и 32-битные шины между различными модулями, чтобы снизить затраты и одновременно предоставить программистам необходимые ресурсы для оптимизации кода.

![Архитектура памяти этой системы.](memory.png)

Используемая память распределяется по следующим местам (в порядке от самого быстрого к самому медленному) [@cpu-vijn]:

- **IWRAM** (Internal WRAM) → 32-бит с 32 КБ: Используется для хранения инструкций ARM.
- **VRAM** (Video RAM) → 16-битный с 96 КБ: Хотя этот блок предназначен для графических данных (об этом в следующем разделе этой статьи), он все равно находится в карте памяти процессора, поэтому программисты могут хранить другие данные, если IWRAM недостаточно.
- **EWRAM** (External WRAM) → 16-бит с 256 КБ: отдельный чип рядом с CPU AGB. Оптимален для хранения Thumb-only инструкций и данных небольшими фрагментами. С другой стороны доступ к этому чипу может быть до шести раз медленнее, чем к IWRAM.
- **Game PAK ROM** → 16-бит переменного размера: отсюда читается ROM картриджа. Хотя он может обеспечивать одну из самых медленных скоростей, он также зеркалируется в карте памяти для управления различными скоростями доступа. Кроме этого, Nintendo добавили **Prefetch Buffer** (буфер предварительной выборки), который взаимодействует с картриджем для уменьшения чрезмерных задержек. Этот компонент независимо кэширует непрерывные адреса, когда CPU не обращается к картриджу, он может вмещать до восьми 16-битных слов.
  - Однако на практике процессор редко позволяет буферу выполнять свою работу. Поскольку по умолчанию он будет продолжать получать инструкции из картриджа для продолжения выполнения \[@cpu-pfau\] (вот почему IWRAM и EWRAM так важны).
- **Game PAK RAM** → 8-бит переменного размера: здесь происходит доступ к оперативной памяти картриджа (SRAM или Flash Memory).
  - Это строго 8-битная шина (процессор видит 'мусор' в незадействованных битах), по этой причине Nintendo заявляют, что с ней можно работать только через их библиотеки.

Хотя эту консоль позиционировали как 32-битную систему, с большей частью памяти можно общаться только через 16-битную шину, а значит игры в основном используют набор инструкций Thumb, чтобы не тратить два цикла на один запрос инструкций. Только в очень исключительных обстоятельствах (например, при необходимости использовать инструкции, отсутствующие в Thumb, храня их в IWRAM) программисты смогут воспользоваться набором инструкций ARM.

### Становление Game Boy Color

Кроме включения компонентов GBC (Sharp SM83, оригинальный BIOS, режимы аудио и видео, совместимый слот для картриджей и так далее), для обеспечения обратной совместимости нужны еще две функции.

Со стороны оборудования консоль полагается на переключатели для определения, какой картридж вставлен: Game Boy или Game Boy Color. **Детектор формы** с лоте для картриджей по сути определяет тип картриджа и позволяет процессору читать его состояние. Предполагается, что некий компонент CPU AGB читает это значение и автоматически выключает ненужное в режиме GBC оборудование.

Со стороны программного обеспечения существует специальный 16-битный регистр `REG_DISPCNT`, который может изменять многие свойства дисплея, но один из его битов устанавливает консоль в 'GBC режим' [@cpu-diaz]. Сначала мне было очень трудно понять, когда именно GBA пытается обновить это регистр. К счастью, нашлись разработчики прояснить ситуацию:

> Думаю, вот что происходит во время загрузки GBC: она проверяет переключатель (считывается по адресу REG_WAITCNT 0x4000204), делает переход (очень быстрый, сложно заметить), потом окончательно переключатеся в режим GBC (BIOS пишет в REG_DISPCNT 0x4000000), останавливая ARM7.
> 
> Остается недостающий кусочек пазла: что если убрать часть корпуса на картридже GBC, чтобы переключатель больше не нажимался, а потом сделать программное переключение в режим GBC? Может помочь режим мультизагрузки. Не уверен, требуется ли нажатие переключателя, чтобы шина картриджа GBC работала корректно, или она работает само собой. Я склонен считать, что переключатель все таки необходим, но это всего лишь догадка.
> 
> -- <cite>Dan Weiss (он же Dwedit, текущий разработчик PocketNES и Goomba Color)</cite>

## Графика

Прежде чем мы начнем, вы узнаете, что система представляет собой смесь между [SNES](super-nintendo.md#graphics) и [Game Boy](game-boy#graphics), графическим ядром по-прежнему является хорошо известный 2D движок под названием **PPU**. Поэтому, я рекомендую прочитать эти статьи, прежде чем продолжить, так как я буду рассматривать множество ранее разъясненных понятий.

В сравнении с прошлыми геймбоями теперь у нас есть цветной LCD дисплей, который может показывать до 32,768 цветов (15-бит). Его разрешение 240x160 пикселей, а частота обновления примерно 60Гц.

### Организация контента

![Архитектура памяти PPU.](ppu.png)

Для распределения графики у нас есть следующие участки памяти:

- 96 КБ 16-битной **VRAM** (Video RAM): 64 КБ для фонов и 32 КБ для спрайтов.
- 1 КБ 32-битной **OAM** (Object Attribute Memory): хранит до 128 спрайтовых записей (не изображения, только индексы и атрибуты). Шина оптимизирована для быстрой отрисовки.
- 1 КБ 16-битной **PAL RAM** (Palette RAM): хранит две палитры, одна для фонов, а другая для спрайтов. В каждой палитре 256 записей 15-битных цветов, цвет `0` значит *прозрачность*.

### Построение кадра

Если вы читали прошлые статьи, GBA будет казаться вам знакомой, хотя дополнительная функциональность может вас удивить, и не надо забывать, что консоль работает от двух пальчиковых батареек.

Я одолжу графику из *Sonic Advance 3* от Sega, чтобы проиллюстрировать, как составляется кадр.

#### Тайлы {.tabs.active}

::: {.subfigures .tabs-nested .tab-float .pixel}

![Этот блок состоит из 4 тайлов bpp.](sonic/tiles1.png){.active title="Block 1"}

![Здесь можно заметить странные вертикальные узоры, это не графика, а т. н. 'Tile Maps' (тайловые карты, смотрите следующий раздел).](sonic/tiles2.png){title="Block 2"}

![Этот блок зарезервирован под спрайты.](sonic/tilesobj.png){title="Block 3"}

Charblocks внутри VRAM.

:::

Тайлы GBA - это строго растровые изображения размером 8x8 пикселей, они могут использовать 16 цветов (4 bpp) или 256 цветов (8 bpp). Плитки размером 4 bpp занимают 32 байта, а 8 bpp - 64 байта.

Тайлы можно хранить где угодно в VRAM, однако, для PPU их нужно группировать в **charblocks**: блоки по **16 КБ**. Каждый блок резервирует определенный тип слоев (фон или спрайты). Это может привести к перекрытиям, что, как следствие, позволяет блоками иметь общие тайлы.

Из-за размера блока символов в одном блоке можно хранить до 256 плиток 8 bpp или 512 плиток 4 bpp. Допускается до шести таких блоков, что в сумме требует 96 КБ памяти: точное количество VRAM этой консоли.

Для фонов можно использовать только четыре, а два можно применить для спрайтов.

#### Фоны {.tab}

::: {.subfigures .tabs-nested .tab-float}

![Фоновый слой 0 (BG0).](sonic/bg0.png){.active title="Слой 0"}

![Фоновый слой 2 (BG2).](sonic/bg2.png){title="Слой 2"}

![Фоновый слой 3 (BG3).<br>Этот конкретный слой сдвигается по горизонтали на определенных сканлайнах для имитации эффектов воды.](sonic/bg3.png){title="Слой 3"}

Используемые в фонах статические слои.

:::

Фоновый слой в этой системе значительно улучшился со времен Game Boy Color. Она наконец-то включает в себя некоторые функции, найденные в [Super Nintendo](super-nintendo) (помните [аффинное преобразование](super-nintendo#unique-features)?)

PPU теперь умеет рисовать до четырех фоновых слоев. Возможности каждого из них зависят от выбранного режима работы [@graphics-tiles]:

- **Режим 0**: четыре статических слоя.
- **Режим 1**: доступно всего три слоя, но один из них **аффинный** (может вращаться и масштабироваться).
- **Режим 2**: два аффинных слоя.

Размеры каждого слоя могут быть до 512x512 пикселей. Если слой аффинный, он может быть размером до 1024x1024 пикселей.

Совокупность данных, которая задает фоновый слой, называют **Tile Map**. Чтобы реализовать ее в понятном для PPU виде, программисты используют **screenblocks**, структуру, задающую части фонового слоя (32x32 тайлов). Screenblock занимает всего 2 КБ, но для построения всего слоя их требуется несколько штук. Программисты вольны размещать их где угодно внутри фонового блока, а значит не все тайлы хранят графику!

#### Спрайты {.tab}

![Отрисованный спрайтовый слой](sonic/sprites.png) {.tab-float.pixel}

Спрайт может быть размером до 64x64 пикселей, но из-за маленького экрана, он будет занимать большую его часть.

Если этого недостаточно, PPU теперь умеет применять к спрайтам **аффинные преобразования**!

Спрайтовые записи занимают 32 бита, их значения можно разделить на две группы:

- **Атрибуты**: x/y - положение, h/v - отражение, размер, форма (квадрат или прямоугольник), тип спрайта (аффинный или простой) и положение первого тайла.
- **Аффинные данные**: используются только если спрайт аффинный, задают масштаб и вращение.

#### Результат {.tab}

![Все слои объединены (_Tada!_).](sonic/result.png) {.tab-float.pixel}

Как обычно, PPU объеденяет все слои автоматически, но это еще не все! Система может наложить на эти слои несколько эффектов:

- **Mosaic**: делает тайлы более *пиксельными*.
- **Alpha blending**: комбинирует цвета двух наложенных слоев, что дает эффекты прозрачности.
- **Windowing**: разделяет экран на два разных *окна*, в каждом может быть своя собственная графика и эффекты, внешнюю зону обоих окон также можно отрисовывать тайлами.

С другой стороны, для обновления кадра есть несколько опций на выбор:

- Распоряжатся **ЦП**: у процессора теперь полный доступ к VRAM в любое вермя. Однако изменение некоторых данных посреди када может привести к нежелательным артефактам, так что ждать VBlank/HBlank промежутков (*традиционный подход*) остаестя самой безопасной тактикой в больинстве случаев.
- Использовать **DMA контроллер**: DMA обеспечивает в ~10 раз более быструю передачу данных, его можно отправить в обработку во время VBlank и HBlank. Консоль предоставляет 4 канала DMA (два зарезервированы под звук, один для критических операций, другой - общего назначения). При этом контроллер остановит процессор на время операции (хотя он едва заметит это!).

### Кроме тайлов {.tabs-close}

Мы можем захотеть составить фон с которым тайловый движок не справится. Современные консоли решили это, внедрив архитектуру с **буфером кадра**, но это невозможно при очень маленькой емкости памяти... Что же, у GBA как раз есть 96 КБ видеопамяти, чего достаточно для **растрового изображения** размером с наш LCD экран.

Хорошей новостью является то, что PPU фактически реализовал эту функциональность, включив три дополнительных режима, которые называются **bitmap modes** [@graphics-bitmap]:

- **Режим 3**: Выделяет один полноцветный (16 bpp, 32 768 цветов) кадр.
- **Режим 4**: Предоставляет два кадра с половиной цветов (8 bpp, 256 цветов) каждый.
- **Режим 5**: Два полностью цветных кадра с половиной размера каждого (160x128 пикселей).

Причина наличия двух растровых изображений заключается в возможности **перелистывания страниц**: Рисование поверх отображаемого растрового изображения может привести к появлению некоторых странных артефактов во время процесса. Если вместо этого манипулировать другим, то ни один из глюков не будет показан пользователю. Как только вторая растровая карта будет готова, PPU можно обновить, чтобы указать на вторую, эффективно поменяв отображаемый кадр местами.

::: {.subfigures .tabs-nested .open-float .tab-float}

![Super Monkey Ball Jr. (2002).<br>Растровый режим позволил процессору рисовать рудиментарную 3D графику.<br>Объекты переднего плана это спрайты (отдельный слой).](bitmap/monkey.png){.active title="3D"}

![Tonc's demo.<br>Растровая картинка с примитивами.<br>Обратите внимание, экран не показывает существенных узоры тайловых движков.](bitmap/demo.png){title="Demo"}

![Эпизод распространялся в виде картриджа _GBA Video_ (видео , конечно, сильно пострадало от сжатия).](bitmap/spongebob.png){title="Video"}

Примеры программ с растровыми режимами.

:::

О целом звучит как суперсовременная фишка, однако, большинство игр продолжили пользоваться тайловым движком. Почему? Потому, что на практике, **растры сьедают очень много ресурсов ЦП**.

Видите ли, когда применяется тайловый движок, процессор делегирует большинство вычислений графическому чипу. А вот система фреймбуфферов от PPU ограничена только отображением сегмента памяти на **единственном фоновом слое**, что значит больше нет индивидуальных аффинных транформаций, наложений или эффектов если процессор сам их не просчитает. Фреймбуффер также занимает 80 КБ памяти, так что только 16 КБ (половина) доступны для хранения спрайтовых тайлов.

`r close_float_group(with_markdown = TRUE)`

Вот почему эти режимы применяются в исключетельных случаях, таких как проигрывание видео (**Game Boy Advance Video** полностью на это полагалось) или отрисовка **3D геометрии** через ЦП.

## Звук

В GBA используется **двухканальный проигрыватель сэмплов**, который работает в связке со звуковай системой Game Boy.

### Функционал

Вот разбор каждого звукового компонента на примере *Sonic Advance 2*:

#### PCM {.tabs.active}

![PCM-only channels.](pcm){.tab-float video="true"}

Новая звуковая система теперь умеет проигрывать PCM сэмплы, она предоставляет два канала под названием **Direct Sound**, куда приходят сэмплы через **очередь FIFO** (реализована в виде 16-битного буфера).

Семплы **8-битрые** и **со знаком** (кодируются в значениях от -128 до 127). Частота выборки по умолчанию 32 кГц, хотя это зависит от игры: так как большая частота значит больше размер и больше циклов процессора, не каждая игра выделяет отдинаковое количество ресурсов аудиочипу.

**DMA** необходим во избежание лишней траты циклов ЦП. **Timers** также доступны для синхронизации с очередью.

#### PSG {.tab}

![PSG-only channels.](psg){.tab-float video="true"}

Хотя подсистема от Game Boy не делится ресурсами ЦП, доступ к своему PSG она дает. В целях обратной совместимости это тот-же дизайн, что и в оригинальном Game Boy. Ранее я уже писал [эту статью](game-boy#audio), в которой подробно рассказывается о каждом канале в отдельности.

Большинство игры GBA используют его для аккопониманта или эффектов. Более поздние оптимизировали музыку под PCM, а PSG оставили незадействованным.

#### Комбинирование {.tab}

![Тада!](complete){.tab-float video="true"}

Наконец, все автоматически микшируется вместе и выводится через динамик/разъем наушников.

Несмотря на то, что в GBA только два канала PCM, некоторые игры волшебным образом проигрывают более двух сэмплов одновременно. Как такое возможно? Хотя на бумаге наличие только двух каналов может показаться немного слабым, основной процессор может использовать часть своих циклов для обеспечения секвенирования и микширования звука \[@audio-programming\] (это должно дать вам представление о мощности ARM7!). Более того, в разделе "Операционная система" вы узнаете, что в ROM BIOS-а входит аудиосиквенсер!

### Лучшее из обоих миров {.tabs-close}

Некоторые игры понесли дуальнось PCM-PSG еще дальше и "сменяют" ведущий чип в зависимости от контекста.

В этой игре (*Mother 3*) игрок может входить в две разные комнаты, одна *относительно нормальная*, а другая в *ностальгическом* сеттинге. В вазисимости от того, в какой комнате находится персонаж, та же самая музыка звучит *современно* или *восьмибитно*.

![Нормальная комната, используется только PCM.](crackers/cinema){.toleft video="true"}

![Ностальгическая комната, PSG ведет мелодию.](crackers/8bit){.toright video="true"}

## Операционная система

Вектор сброса ARM7 находится по адресу `0x000000`, который указывает на **16 KB BIOS ROM**. Это означает, что Game Boy Advance сначала загружается из BIOS, который, в свою очередь, показывает знакомую заставку, а затем решает, загружать игру или нет.

В этом ПЗУ также хранятся программные процедуры, которые игры могут вызывать для упрощения определенных операций и уменьшения размера картриджа [@operating_system-vijn]. К ним относятся:

- **Арифметические функции**: Маршруты для выполнения деления, квадратного корня и тангенса дуги.
- **Вычисление аффинной матрицы**: Учитывая значение 'zoom' и угол, вычисляет аффинную матрицу, которая будет введена в PPU для масштабирования/поворота фона или спрайта.
  - Есть две функции, одна для спрайтов, другая для фонов. Их параметры немного отличаются, но идея одна и та же.
- **Функции декомпрессии**: Реализует алгоритмы декомпрессии, включая Run-Length, LZ77 и Huffman. Он также обеспечивает распаковку битов и последовательное различие.
- **Копирование памяти**: Две функции, которые перемещают память. Первая копирует 32-байтовые блоки, используя специализированный опкод для этого типа передачи (`LDMIA` для загрузки и `SDMIA` для хранения) только один раз. Вторая копирует 2-байтовые или 4-байтовые блоки, используя повторяющиеся опкоды `LDRH/STRH` или `LDMIA/STMIA`, соответственно. Таким образом, вторая функция является более гибкой, но не такой быстрой.
- **Звук**: Реализует полный MIDI-секвенсор! Он включает в себя множество функций для управления им.
- ** Интерфейс питания**: ярлыки для сброса, очистки большей части оперативной памяти, остановки процессора до наступления определенного события (V-blank или пользовательского) или перехода в "режим низкого энергопотребления".
- **Мультизагрузка**: Загружает программу на другой GBA и запускает ее. Более подробную информацию можно найти в разделе "Игра".

BIOS подключен через 32-битную шину и реализован с использованием комбинации инструкций Arm и Thumb, хотя последняя является наиболее заметной.

Также помните, что все это будет работать только на ARM7. Другими словами, нет никакого аппаратного ускорения для ускорения этих операций. Таким образом, Nintendo обеспечила всю эту функциональность с помощью программного обеспечения.

## Игры

Программирование для GBA было аналогично программированию для SNES с добавлением всех преимуществ разработки игр в начале 2000-х годов: стандартизированные языки высокого уровня, лучшие компиляторы, более быстрые RISC-процессоры, не проприетарные решения для разработки, сравнительно лучшая документация и... Интернет доступ!

Программы в основном пишутся на языке C с критичными для производительности разделами на ассемблере (ARM и Thumb) для экономии тактов. Nintendo предоставила SDK с библиотеками и компиляторами.

Игры распространяются в новом проприетарном картридже под названием **Game Pak**.

### Доступ к данным картриджа

Хотя ARM7 имеет 32-битную адресную шину, к картриджу подключено только 24 адресных линии. Это должно означать, что до 16 МБ могут быть доступны на картридже без использования маппера, однако в официальной документации указано, что **32 МБ данных картриджа отображаются в памяти**. Как такое возможно? Дело в том, что Gamepak использует **25-битные адреса** (что объясняет блок размером 32 МБ), но его самый нижний бит фиксирован на нуле, поэтому все 24 оставшихся бита установлены. Вот как работает адресация Gamepak.

Означает ли это, что данные, расположенные по нечетным адресам (с младшим значащим битом '1'), будут недоступны? Нет, потому что шина данных 16-битная: При каждой передаче CPU/DMA получает расположенный байт плюс следующий, что позволяет читать как четные, так и нечетные адреса. Как видите, это еще одно произведение инженерной мысли, в котором полностью используются возможности аппаратного обеспечения при одновременном снижении затрат.

### Пространство оперативной памяти картриджа

Для хранения сохранений Game Paks может включать [@games-ziegler]:

- **SRAM**: Нуждается в батарейке для сохранения своего содержимого и может иметь размер до 64 КБ (хотя коммерческие игры не превышали 32 КБ). Доступ к нему осуществляется через GBA memory map.
- **Flash ROM**: аналогично SRAM без необходимости использования батареи, размер может достигать 128 КБ.
- **EEPROM**: Они требуют последовательного подключения и теоретически могут иметь любой размер (часто встречается до 8 КБ).

### Аксессуары

Знаменитый **Game Boy Link Cable** обеспечивал возможность многопользовательской игры. Кроме того, кабель имеет специальную функцию, известную как **Multi-boot**: Другая консоль (GBA или GameCube) может послать функциональную игру в EWRAM приемника, после чего последний загрузится оттуда (вместо того, чтобы использовать картридж).

## Борьба с пиратством и хоумбрю

В целом, использование проприетарных картриджей было большим препятствием по сравнению с постоянной игрой в кошки-мышки, с которой приходилось бороться другим производителям консолей при использовании CD-ROM.

Для борьбы с *контрафактом* картриджей (несанкционированными копиями) в BIOS GBA был встроен [ тот же процесс загрузки](game-boy#anti-piracy), что и в оригинальном Game Boy.

### Флеш-картриджи

По мере того как твердотельные накопители становились все более доступными, на рынке появился новый тип картриджей. **Flashcarts** выглядели как обычные Game Paks, но имели дополнительную перезаписываемую память или слот для карт памяти, позволяющий запускать игровые ПЗУ. Концепция на самом деле не нова, разработчики издревле использовали подобные инструменты для тестирования своих игр на реальной консоли (а производители предоставляли аппаратное обеспечение для этого).

Более ранние решения включали сгораемую NOR Flash память (не более 32 МБ) и некоторые SRAM с питанием от батарей. Для загрузки двоичных файлов на картридж в комплекте поставлялся кабель Link-to-USB, который использовался с GBA и ПК под управлением Windows XP. С помощью фирменной программы-флешера и драйверов компьютер загружал в GBA программу мультизагрузки, которая, в свою очередь, использовалась для передачи бинарного файла игры с ПК на Flashcart, вставленный в GBA. В целом, вся задача по загрузке игры была достаточно *медленной*. Более поздние флэш-карты (например, 'EZ-Flash') предлагали больший объем памяти и возможность прошивки картриджа без использования GBA в качестве промежуточного устройства [@anti_piracy-ezflash]. Последние полагались на съемные накопители (SD, MiniSD, MicroSD или любые другие).

Коммерческая доступность этих карт оказалась **серой зоной**: Nintendo осуждала их использование из-за возможности пиратства, в то время как некоторые пользователи защищали, что это единственный способ запуска **Homebrew** (программ, созданных вне игровых студий и, следовательно, без одобрения Nintendo). Аргумент Nintendo был подкреплен тем, что такие прошивальщики, как EZ-Writer, помогали пользователям патчить игровые ПЗУ, чтобы они могли без проблем запускаться в картриджах EZ-Flash. После юридических попыток Nintendo эти картриджи были запрещены в некоторых странах (например, в Великобритании). Тем не менее, они сохранялись повсеместно.

## Вот и всё, ребята

![Мой GBA и пара игр.<br> Жаль, что у нее нет подсветки!](mygba.png)
